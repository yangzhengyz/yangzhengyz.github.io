<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL索引及调优篇 | YZ</title><meta name="author" content="YZ"><meta name="copyright" content="YZ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第06章_索引的数据结构 1...."><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL索引及调优篇",
  "url": "http://example.com/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/",
  "image": "https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360",
  "datePublished": "2022-10-28T15:38:00.000Z",
  "dateModified": "2024-12-15T03:01:08.527Z",
  "author": [
    {
      "@type": "Person",
      "name": "YZ",
      "url": "https://github.com/yangzhengyz"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL索引及调优篇',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="YZ" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic2.zhimg.com%2F50%2Fv2-64c5dbd1e6a174f1371a13b018df0a8d_r.jpg&amp;refer=http%3A%2F%2Fpic2.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1654421720&amp;t=cf6b4b204d29dc42447fb634cdc8bd33));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">YZ</span></a><a class="nav-page-title" href="/"><span class="site-name">MySQL索引及调优篇</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MySQL索引及调优篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-28T15:38:00.000Z" title="发表于 2022-10-28 23:38:00">2022-10-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-15T03:01:08.527Z" title="更新于 2024-12-15 11:01:08">2024-12-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/%E9%AB%98%E7%BA%A7%E7%89%88/">高级版</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">84.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>284分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>第06章_索引的数据结构</p>
<h2 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1. 为什么使用索引"></a>1. 为什么使用索引</h2><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则<code>通过索引查找</code>相关数据，如果不符合则需要<code>全表扫描</code>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616141351236.png" alt="image-20220616141351236"></p>
<p>如上图所示，数据库没有索引的情况下，数据<code>分布在硬盘不同的位置上面</code>，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。如果<code>数据顺序摆放</code>，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，<code>依旧非常耗时</code>。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col 2 = 89 这条记录，就要逐行去查找、去比较。从Col 2 = 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有<code>上千万条数据</code>，就意味着要做<code>很多很多次硬盘I/0</code>才能找到。现在要查找 Col 2 = 89 这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘I/O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）</p>
<p>假如给数据使用 <code>二叉树</code> 这样的数据结构进行存储，如下图所示</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616142723266.png" alt="image-20220616142723266"></p>
<p>对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2 维护了一个索引的数据结构，即这个 <code>二叉搜索树</code>。二叉搜索树的每个结点存储的是 <code>(K, V) 结构</code>，key 是 Col 2，value 是该 key 所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：<code>(34, 0x07)</code>。现在对 Col 2 添加了索引，这时再去查找 Col 2 = 89 这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找）。读 34 到内存，89 &gt; 34; 继续右侧数据，读 89 到内存，89==89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要 <code>查找两次</code> 就可以定位到记录的地址，查询速度就提高了。</p>
<p>这就是我们为什么要建索引，目的就是为了 <code>减少磁盘I/O的次数</code>，加快查询速率。</p>
<h2 id="2-索引及其优缺点"><a href="#2-索引及其优缺点" class="headerlink" title="2. 索引及其优缺点"></a>2. 索引及其优缺点</h2><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。</p>
<p><strong>索引的本质</strong>：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 <code>高级查找算法</code> 。</p>
<p><code>索引是在存储引擎中实现的</code>，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 <code>最大索引数</code>和 <code>最大索引长度</code>。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p>
<h3 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h3><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 <strong>数据库的IO成本</strong> ，这也是创建索引最主要的原因。 </p>
<p>（2）通过创建唯一索引，可以保证数据库表中每一行 <strong>数据的唯一性</strong> 。 </p>
<p>（3）在实现数据的 参考完整性方面，可以 <strong>加速表和表之间的连接</strong> 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。 </p>
<p>（4）在使用分组和排序子句进行数据查询时，可以显著 <strong>减少查询中分组和排序的时间</strong> ，降低了CPU的消耗。</p>
<h3 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h3><p>增加索引也有许多不利的方面，主要表现在如下几个方面： </p>
<p>（1）创建索引和维护索引要 <strong>耗费时间</strong> ，并 且随着数据量的增加，所耗费的时间也会增加。 </p>
<p>（2）索引需要占 <strong>磁盘空间</strong> ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。 </p>
<p>（3）虽然索引大大提高了查询速度，同时却会 <strong>降低更新表的速度</strong> 。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<blockquote>
<p>提示：</p>
<p>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p>
</blockquote>
<h2 id="3-InnoDB中索引的推演"><a href="#3-InnoDB中索引的推演" class="headerlink" title="3. InnoDB中索引的推演"></a>3. InnoDB中索引的推演</h2><h3 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h3><p>先来看一个精确匹配的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;</span><br></pre></td></tr></table></figure>
<h4 id="1-在一个页中的查找"><a href="#1-在一个页中的查找" class="headerlink" title="1. 在一个页中的查找"></a>1. 在一个页中的查找</h4><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li><p>以主键为搜索条件</p>
<p>可以在页目录中使用 <code>二分法</code> 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。</p>
</li>
<li><p>以其他列作为搜索条件</p>
<p>因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从 <code>最小记录</code> 开始 <code>依次遍历单链表中的每条记录</code>， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p>
</li>
</ul>
<h4 id="2-在很多页中查找"><a href="#2-在很多页中查找" class="headerlink" title="2. 在很多页中查找"></a>2. 在很多页中查找</h4><p>在很多页中查找记录的活动可以分为两个步骤：</p>
<ol>
<li>定位到记录所在的页。</li>
<li>从所在的页内中查找相应的记录。</li>
</ol>
<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时 索引 应运而生。</p>
<h3 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h3><p>建一个表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">-&gt; c1 INT,</span><br><span class="line">-&gt; c2 INT,</span><br><span class="line">-&gt; c3 CHAR(1),</span><br><span class="line">-&gt; PRIMARY KEY(c1)</span><br><span class="line">-&gt; ) ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure>
<p>这个新建的 <strong>index_demo</strong> 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 <strong>Compact</strong> 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616152453203.png" alt="image-20220616152453203"></p>
<p>我们只在示意图里展示记录的这几个部分：</p>
<ul>
<li>record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过，下面讲。 </li>
<li>mysql&gt; CREATE TABLE index_demo( -&gt; c1 INT, -&gt; c2 INT, -&gt; c3 CHAR(1), -&gt; PRIMARY KEY(c1) -&gt; ) ROW_FORMAT = Compact; next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。 </li>
<li>各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。 </li>
<li>其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>
</ul>
<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616152727234.png" alt="image-20220616152727234" style="zoom:80%;"></p>
<p>把一些记录放到页里的示意图就是：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616152651878.png" alt="image-20220616152651878"></p>
<h4 id="1-一个简单的索引设计方案"><a href="#1-一个简单的索引设计方案" class="headerlink" title="1. 一个简单的索引设计方案"></a>1. 一个简单的索引设计方案</h4><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 <strong>想快速的定位到需要查找的记录在哪些数据页</strong> 中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录 ，建这个目录必须完成下边这些事：</p>
<ul>
<li><p><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></p>
<p>假设：每个数据结构最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO index_demo VALUES(1, 4, &#x27;u&#x27;), (3, 9, &#x27;d&#x27;), (5, 3, &#x27;y&#x27;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​       那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616153518456.png" alt="image-20220616153518456"></p>
<p>​      从图中可以看出来， index_demo 表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO index_demo VALUES(4, 4, &#x27;a&#x27;);</span><br></pre></td></tr></table></figure>
<p>因为 <strong>页10</strong> 最多只能放3条记录，所以我们不得不再分配一个新页：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616155306705.png" alt="image-20220616155306705"></p>
<p>注意：新分配的 <strong>数据页编号可能并不是连续的</strong>。它们只是通过维护者上一个页和下一个页的编号而建立了 <strong>链表</strong> 关系。另外，<strong>页10</strong>中用户记录最大的主键值是5，而<strong>页28</strong>中有一条记录的主键值是4，因为5&gt;4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次 <strong>记录移动</strong>，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616160216525.png" alt="image-20220616160216525"></p>
<p>这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如 <strong>记录移动</strong> 的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为 <strong>页分裂</strong>。</p>
<ul>
<li><strong>给所有的页建立一个目录项。</strong></li>
</ul>
<p>由于数据页的 <strong>编号可能是不连续</strong> 的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616160619525.png" alt="image-20220616160619525"></p>
<p>我们需要给它们做个 <strong>目录</strong>，每个页对应一个目录项，每个目录项包括下边两个部分：</p>
<p>1）页的用户记录中最小的主键值，我们用 <strong>key</strong> 来表示。</p>
<p>2）页号，我们用 <strong>page_on</strong> 表示。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616160857381.png" alt="image-20220616160857381"></p>
<p>以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p>
<ol>
<li>先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 &lt; 20 &lt; 209 ），它对应的页是 页9 。 </li>
<li>再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。</li>
</ol>
<p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 <strong>索引</strong> 。</p>
<h4 id="2-InnoDB中的索引方案"><a href="#2-InnoDB中的索引方案" class="headerlink" title="2. InnoDB中的索引方案"></a>2. InnoDB中的索引方案</h4><h5 id="①-迭代1次：目录项纪录的页"><a href="#①-迭代1次：目录项纪录的页" class="headerlink" title="① 迭代1次：目录项纪录的页"></a>① 迭代1次：目录项纪录的页</h5><p>InnoDB怎么区分一条记录是普通的 <strong>用户记录</strong> 还是 <strong>目录项记录</strong> 呢？使用记录头信息里的 <strong>record_type</strong> 属性，它的各自取值代表的意思如下：</p>
<ul>
<li>0：普通的用户记录</li>
<li>1：目录项记录</li>
<li>2：最小记录</li>
<li>3：最大记录</li>
</ul>
<p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616162944404.png" alt="image-20220616162944404"></p>
<p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 <strong>目录项记录</strong> 和普通的 <strong>用户记录</strong> 的不同点：</p>
<ul>
<li><strong>目录项记录</strong> 的 record_type 值是1，而 <strong>普通用户记录</strong> 的 record_type 值是0。 </li>
<li>目录项记录只有 <strong>主键值和页的编号</strong> 两个列，而普通的用户记录的列是用户自己定义的，可能包含 <strong>很多列</strong> ，另外还有InnoDB自己添加的隐藏列。 </li>
<li>了解：记录头信息里还有一个叫 <strong>min_rec_mask</strong> 的属性，只有在存储 <strong>目录项记录</strong> 的页中的主键值最小的 <strong>目录项记录</strong> 的 <strong>min_rec_mask</strong> 值为 <strong>1</strong> ，其他别的记录的 <strong>min_rec_mask</strong> 值都是 <strong>0</strong> 。</li>
</ul>
<p><strong>相同点</strong>：两者用的是一样的数据页，都会为主键值生成 <strong>Page Directory （页目录）</strong>，从而在按照主键值进行查找时可以使用 <strong>二分法</strong> 来加快查询速度。</p>
<p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<ol>
<li>先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。 </li>
<li>再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。</li>
</ol>
<h5 id="②-迭代2次：多个目录项纪录的页"><a href="#②-迭代2次：多个目录项纪录的页" class="headerlink" title="② 迭代2次：多个目录项纪录的页"></a>② 迭代2次：多个目录项纪录的页</h5><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616171135082.png" alt="image-20220616171135082"></p>
<p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p>
<ul>
<li>为存储该用户记录而新生成了 页31 。 </li>
<li>因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 页32 来存放 页31 对应的目录项。</li>
</ul>
<p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：</p>
<ol>
<li>确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。 </li>
<li>通过目录项记录页 确定用户记录真实所在的页 。 在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。 </li>
<li>在真实存储用户记录的页中定位到具体的记录。</li>
</ol>
<h5 id="③-迭代3次：目录项记录页的目录页"><a href="#③-迭代3次：目录项记录页的目录页" class="headerlink" title="③ 迭代3次：目录项记录页的目录页"></a>③ 迭代3次：目录项记录页的目录页</h5><p>如果我们表中的数据非常多则会<code>产生很多存储目录项记录的页</code>，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个<code>更高级的目录</code>，就像是一个多级目录一样，<code>大目录里嵌套小目录</code>，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616173512780.png" alt="image-20220616173512780"></p>
<p>如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。</p>
<p>我们可以用下边这个图来描述它：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616173717538.png" alt="image-20220616173717538"></p>
<p>这个数据结构，它的名称是 B+树 。</p>
<h5 id="④-B-Tree"><a href="#④-B-Tree" class="headerlink" title="④ B+Tree"></a>④ B+Tree</h5><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么：</p>
<ul>
<li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li>
<li>如果B+树有2层，最多能存放 1000×100=10,0000 条记录。 </li>
<li>如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。 </li>
<li>如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记录！</li>
</ul>
<p>你的表里能存放 <strong>100000000000</strong> 条记录吗？所以一般情况下，我们用到的 <strong>B+树都不会超过4层</strong> ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 <strong>Page Directory</strong> （页目录），所以在页面内也可以通过 <strong>二分法</strong> 实现快速 定位记录。</p>
<h3 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h3><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。</p>
<h4 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引"></a>1. 聚簇索引</h4><p>聚簇索引并不是一种单独的索引类型，而是<strong>一种数据存储方式</strong>（所有的用户记录都存储在了叶子结点），也就是所谓的 <code>索引即数据，数据即索引</code>。</p>
<blockquote>
<p>术语”聚簇”表示当前数据行和相邻的键值聚簇的存储在一起</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </p>
<ul>
<li><code>页内</code> 的记录是按照主键的大小顺序排成一个 <code>单向链表</code> 。 </li>
<li>各个存放 <code>用户记录的页</code> 也是根据页中用户记录的主键大小顺序排成一个 <code>双向链表</code> 。 </li>
<li>存放 <code>目录项记录的页</code> 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 <code>双向链表</code> 。 </li>
</ul>
</li>
<li><p>B+树的 叶子节点 存储的是完整的用户记录。 </p>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
</li>
</ul>
<p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX 语句去创建， <code>InnDB</code> 存储引擎会 <code>自动</code> 的为我们创建聚簇索引。</p>
<p><strong>优点：</strong></p>
<ul>
<li><code>数据访问更快</code> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 </li>
<li>聚簇索引对于主键的 <code>排序查找</code> 和 <code>范围查找</code> 速度非常快 </li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 <code>节省了大量的io操作</code> 。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code></li>
<li><code>更新主键的代价很高</code> ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li>
<li><code>二级索引访问需要两次索引查找</code> ，第一次找到主键值，第二次根据主键值找到行数据</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>对于MySQL数据目前只有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。</li>
<li>对于数据物理存储排序方式只能有一种，所有每个MySQL的<code>表只能有一个聚簇索引</code>，一般情况下就是该表的主键。</li>
<li>如果没有定义主键，InnoDB会选择<code>非空的唯一索引</code>代替。如果没有这样的索引，InnoDB会隐式的定义一个主键来作为聚簇索引。</li>
<li>为了充分利用聚簇索引的聚簇的特性，所以InnoDB表的主键列尽量<code>选用有序的顺序id</code>,而不建议无序的id,比如UUID、MD5、HASH、字符串列作为主键无法保证的顺序增长。</li>
</ul>
<h4 id="2-二级索引（辅助索引、非聚簇索引）"><a href="#2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="2. 二级索引（辅助索引、非聚簇索引）"></a>2. 二级索引（辅助索引、非聚簇索引）</h4><p>如果我们想以别的列作为搜索条件该怎么办？肯定不能是从头到尾沿着链表依次遍历记录一遍。</p>
<p>答案：我们可以<code>多建几颗B+树</code>，不同的B+树中的数据采用不同的排列规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一课B+树，效果如下图所示：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616203852043.png" alt="image-20220616203852043"></p>
<p>这个B+树与上边介绍的聚簇索引有几处不同：</p>
<ul>
<li>使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义:<ul>
<li>页内的记录是按照c2列的大小顺序排成一个<code>单向链表</code>。</li>
<li>各个存放<code>用户记录的页</code>也是根据页中记录的c2列大小顺序排成一个<code>双向链表</code>。</li>
<li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个<code>双向链表</code>。</li>
</ul>
</li>
<li>B+树的叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值</li>
<li>目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>c2列+页号</code>的搭配。</li>
</ul>
<p>所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为<code>4</code>的记录为例，查找过程如下:</p>
<ol>
<li>确定<code>目录项记录页</code></li>
</ol>
<p>​       根据<code>根页面</code>，也就是<code>页44</code>，可以快速定位到<code>目录项记录</code>所在的页为<code>页42</code>(因为<code>2&lt;4&lt; 9</code>)。</p>
<ol>
<li>通过<code>目录项记录</code>页确定用户记录真实所在的页。</li>
</ol>
<p>​       在<code>页42</code>中可以快速定位到实际存储用户记录的页，但是由于<code>c2</code>列并没有唯一性约束，所以<code>c2</code>列值为<code>4</code>的记录可能分布在多个数据页中，又因为<code>2&lt;4≤4</code>，所以                  确定实际存储用户记录的页在<code>页34</code>和<code>页35</code>中。</p>
<ol>
<li>在真实存储用户记录的页中定位到具体的记录。</li>
</ol>
<p>​       到<code>页34</code>和<code>页35</code>中定位到具体的记录。</p>
<ol>
<li>但是这个B+树的叶子节点中的记录只存储了<code>c2</code>和<code>c1</code>(也就是<code>主键</code>）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</li>
</ol>
<p><strong>概念：回表 </strong></p>
<p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为回表 。也就是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！</p>
<p><strong>问题</strong>：为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</p>
<p><strong>回答</strong>：</p>
<p>如果把完整的用户记录放到叶子结点是可以不用回表。但是<code>太占地方</code>了，相当于每建立一课B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p>
<p>因为这种按照<code>非主键列</code>建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<code>二级索引</code>，或者辅助索引。由于使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为c2列简历的索引。</p>
<p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616213109383.png" alt="image-20220616213109383"></p>
<p>小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p>
<ol>
<li>聚簇索引的<code>叶子节点</code>存储的就是我们的<code>数据记录</code>, 非聚簇索引的叶子节点存储的是<code>数据位置</code>。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li>一个表<code>只能有一个聚簇索引</code>，因为只能有一种排序存储的方式，但可以有<code>多个非聚簇索引</code>，也就是多个索引目录提供数据检索。</li>
<li>使用聚簇索引的时候，数据的<code>查询效率高</code>，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</li>
</ol>
<h4 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3.联合索引"></a>3.联合索引</h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义： </p>
<ul>
<li>先把各个记录和页按照c2列进行排序。 </li>
<li>在记录的c2列相同的情况下，采用c3列进行排序 </li>
</ul>
<p>为c2和c3建立的索引的示意图如下：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220616215251172.png" alt="image-20220616215251172"></p>
<p>如图所示，我们需要注意以下几点：</p>
<ul>
<li>每条目录项都有c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序</li>
<li>B+树叶子节点处的用户记录由c2、c3和主键c1列组成</li>
</ul>
<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下： </p>
<ul>
<li>建立 联合索引 只会建立如上图一样的1棵B+树。 </li>
<li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>
</ul>
<h3 id="3-4-InnoDB的B-树索引的注意事项"><a href="#3-4-InnoDB的B-树索引的注意事项" class="headerlink" title="3.4 InnoDB的B+树索引的注意事项"></a>3.4 InnoDB的B+树索引的注意事项</h3><h4 id="1-根页面位置万年不动"><a href="#1-根页面位置万年不动" class="headerlink" title="1. 根页面位置万年不动"></a>1. 根页面位置万年不动</h4><p>实际上B+树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 <code>根结点</code> 页面。最开始表中没有数据的时候，每个B+树索引对应的 <code>根结点</code> 中即没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code> 中。</li>
<li>当根节点中的可用 <code>空间用完时</code> 继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 <code>页a</code> 中，然后对这个新页进行 <code>页分裂</code> 的操作，得到另一个新页，比如<code>页b</code> 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 <code>页a</code> 或者 <code>页b</code> 中，而 <code>根节点</code> 便升级为存储目录项记录的页。</li>
</ul>
<p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建议一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是 <code>InnoDB</code> 存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引。</p>
<h4 id="2-内节点中目录项记录的唯一性"><a href="#2-内节点中目录项记录的唯一性" class="headerlink" title="2. 内节点中目录项记录的唯一性"></a>2. 内节点中目录项记录的唯一性</h4><p>我们知道B+树索引的内节点中目录项记录的内容是 <code>索引列 + 页号</code> 的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿 index_demo 表为例，假设这个表中的数据是这样的：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>c1</code></th>
<th><code>c2</code></th>
<th><code>c3</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>‘u’</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>‘d’</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>‘y’</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>‘a’</td>
</tr>
</tbody>
</table>
</div>
<p>如果二级索引中目录项记录的内容只是 <code>索引列 + 页号</code> 的搭配的话，那么为 <code>c2</code> 列简历索引后的B+树应该长这样：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617152906690.png" alt="image-20220617152906690"></p>
<p>如果我们想新插入一行记录，其中 <code>c1</code> 、<code>c2</code> 、<code>c3</code> 的值分别是: <code>9</code>、<code>1</code>、<code>c</code>, 那么在修改这个为 c2 列建立的二级索引对应的 B+ 树时便碰到了个大问题：由于 <code>页3</code> 中存储的目录项记录是由 <code>c2列 + 页号</code> 的值构成的，<code>页3</code> 中的两条目录项记录对应的 c2 列的值都是1，而我们 <code>新插入的这条记录</code> 的 c2 列的值也是 <code>1</code>，那我们这条新插入的记录到底应该放在 <code>页4</code> 中，还是应该放在 <code>页5</code> 中？答案：对不起，懵了</p>
<p>为了让新插入记录找到自己在那个页面，我们需要<strong>保证在B+树的同一层页节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录，这样就能保住 B+ 树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2建立二级索引后的示意图实际上应该是这样子的：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617154135258.png" alt="image-20220617154135258"></p>
<p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code> 时，由于 <code>页3</code> 中存储的目录项记录是由 <code>c2列 + 主键 + 页号</code> 的值构成的，可以先把新纪录的 <code>c2</code> 列的值和 <code>页3</code> 中各目录项记录的 <code>c2</code> 列的值作比较，如果 <code>c2</code> 列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的 <code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到 <code>页5</code> 中。</p>
<h4 id="3-一个页面最少存储-2-条记录"><a href="#3-一个页面最少存储-2-条记录" class="headerlink" title="3. 一个页面最少存储 2 条记录"></a>3. 一个页面最少存储 2 条记录</h4><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以 <strong>InnoDB 的一个数据页至少可以存放两条记录</strong>。</p>
<h2 id="4-MyISAM中的索引方案"><a href="#4-MyISAM中的索引方案" class="headerlink" title="4. MyISAM中的索引方案"></a>4. MyISAM中的索引方案</h2><p>B树索引使用存储引擎如表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">索引 / 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">B-Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody>
</table>
</div>
<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。</p>
<p>MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址 。</p>
<h3 id="4-1-MyISAM索引的原理"><a href="#4-1-MyISAM索引的原理" class="headerlink" title="4.1 MyISAM索引的原理"></a>4.1 MyISAM索引的原理</h3><p>我们知道<code>InnoDB中索引即数据</code>，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而<code>MyISAM</code>的索引方案虽然也使用树形结构，但是却<code>将索引和数据分开存储</code>:</p>
<ul>
<li>将表中的记录<code>按照记录的插入顺序</code>单独存储在一个文件中，称之为<code>数据文件</code>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并<code>没有刻意按照主键大小排序</code>，所以我们并不能在这些数据上使用二分法进行查找。</li>
<li>使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<code>主键值＋数据记录地址</code>的组合。</li>
</ul>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617160413479.png" alt="image-20220617160413479"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，上图是一个MyISAM表的主索引(Primary key)示意。可以看出<code>MyISAM的索引文件仅仅保存数据记录的地址</code>。在MylISAM中，主键索引和二级索引(Secondary key)在结构上没有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在col2上建立一个二级索引，则此索引的结构如下图所示：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617160625006.png" alt="image-20220617160625006"></p>
<p>同样也是一棵B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为:首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<h3 id="4-2-MyISAM-与-InnoDB对比"><a href="#4-2-MyISAM-与-InnoDB对比" class="headerlink" title="4.2 MyISAM 与 InnoDB对比"></a>4.2 MyISAM 与 InnoDB对比</h3><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：</strong></p>
<p>① 在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。</p>
<p> ② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的 ，索引文件仅保存数据记录的地址。</p>
<p> ③ InnoDB的非聚簇索引data域存储相应记录主键的值 ，而MyISAM索引记录的是地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。</p>
<p> ④ MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。 </p>
<p>⑤ InnoDB要求表必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>
<p><strong>小结：</strong></p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如:</p>
<p>举例1:知道了InnoDB的索引实现后，就很容易明白<code>为什么不建议使用过长的字段作为主键</code>，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</p>
<p>举例2:用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree，非单调的主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用<code>自增字段作为主键则是一个很好的选择</code>。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617161151125.png" alt="image-20220617161151125"></p>
<h2 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5. 索引的代价"></a>5. 索引的代价</h2><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>
<ul>
<li><p>空间上的代价</p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 <code>16KB</code>的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
</li>
<li><p>时间上的代价</p>
<p>每次对表中的数据进行 <code>增、删、改</code>操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值<code>从小到大的顺序排序</code> 而组成了 <code>双向链表</code>。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些<code>记录移位</code>，<code>页面分裂</code>、 <code>页面回收</code>等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
</li>
</ul>
<blockquote>
<p>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。</p>
</blockquote>
<h2 id="6-MySQL数据结构选择的合理性"><a href="#6-MySQL数据结构选择的合理性" class="headerlink" title="6. MySQL数据结构选择的合理性"></a>6. MySQL数据结构选择的合理性</h2><p>从MySQL的角度讲，不得不考虑一个现实问题就是磁盘IO。如果我们能让索引弓l的数据结构尽量减少硬盘的I/O操作，所消耗的时间也就越小。可以说，<code>磁盘的 I/O 操作次数</code>对索引的使用效率至关重要。</p>
<p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，<strong>数据库索引是存储在外部磁盘上的</strong>。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能<code>逐一加载</code>，那么MySQL衡量查询效率的标准就是磁盘IO次数。</p>
<h3 id="6-1-全表遍历"><a href="#6-1-全表遍历" class="headerlink" title="6.1 全表遍历"></a>6.1 全表遍历</h3><p>这里都懒得说了。</p>
<h3 id="6-2-Hash结构"><a href="#6-2-Hash结构" class="headerlink" title="6.2 Hash结构"></a>6.2 Hash结构</h3><p>Hash本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。</p>
<p>Hash算法是通过某种确定性的算法（比如MD5、SHA1、SHA2、SHA3)）将输入转变为输出。<code>相同的输入永远可以得到相同的输出</code>，假设输入内容有微小偏差，在输出中通常会有不同的结果。</p>
<p>举例:如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把Hash函数计算得到的结果告诉你即可，然后在本地同样对文件进行Hash 函数的运算最后通过比较这两个Hash 函数的结果是否相同，就可以知道这两个文件是否相同。</p>
<p><strong>加快查找速度的数据结构，常见的有两类：</strong></p>
<p>(1) 树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是 <code>O(log2N)</code>;</p>
<p>(2)哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是 <code>O(1)</code>; (key, value)</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617162153587.png" alt="image-20220617162153587"></p>
<p>采用Hash进行检索效率非常高，基本上一次检索就可以找到数据，而B+树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次I/O操作，<code>从效率来说Hash 比 B+树更快</code>。<br>在哈希的方式下，一个元素k处于h(k)中，即利用哈希函数h，根据关键字k计算出槽的位置。函数h将关键字域映射到哈希表T[0…m-1]的槽位上。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617162604272.png" alt="image-20220617162604272"></p>
<p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 链 接法 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617162703006.png" alt="image-20220617162703006"></p>
<p>实验：体会数组和hash表的查找方面的效率区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 算法复杂度为 O(n)</span><br><span class="line">@Test</span><br><span class="line">public void test1()&#123;</span><br><span class="line">    int[] arr = new int[100000];</span><br><span class="line">    for(int i = 0;i &lt; arr.length;i++)&#123;</span><br><span class="line">        arr[i] = i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line">    for(int j = 1; j&lt;=100000;j++)&#123;</span><br><span class="line">        int temp = j;</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++)&#123;</span><br><span class="line">            if(temp == arr[i])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    long end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;time： &quot; + (end - start)); //time： 823</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 算法复杂度为 O(1)</span><br><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(100000);</span><br><span class="line">    for(int i = 0;i &lt; 100000;i++)&#123;</span><br><span class="line">    	set.add(i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line">    for(int j = 1; j&lt;=100000;j++) &#123;</span><br><span class="line">        int temp = j;</span><br><span class="line">        boolean contains = set.contains(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    long end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;time： &quot; + (end - start)); //time： 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Hash结构效率高，那为什么索引结构要设计成树型呢？</strong></p>
<p>原因1: Hash索引仅能满足(=)(&lt;&gt;)和IN查询。如果进行<code>范围查询</code>，哈希型的索引，时间复杂度会退化为o(n);而树型的“有序”特性，依然能够保持O(log2N)的高效率。</p>
<p>原因2: Hash索引还有一个缺陷，数据的存储是<code>没有顺序的</code>，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。</p>
<p>原因3: 对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的,无法对单独的一个键或者几个索引键进行查询。</p>
<p>原因4: 对于等值查询来说，通常Hash 索引的效率更高，不过也存在一种情况，就是<code>索引列的重复值如果很多，效率就会降低</code>。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较找到查询的关键字，非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等</p>
<p><strong>Hash索引适用存储引擎如表所示：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引 / 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>HASH索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Hash索引的适用性：</strong></p>
<p>Hash索引存在着很多限制，相比之下在数据库中B+树索引的使用面会更广不过也有一些场景采用Hash索引效率更高，比如在键值型(Key-Value)数据库中， <code>Redis存储的核心就是 Hash表</code>。</p>
<p>MysQL中的Memory存储引擎支持Hash存储，如果我们需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行<code>等值查询</code>的时候，采用Hash索引是个不错的选择。</p>
<p>另外，InnoDB本身不支持 Hash索引，但是提供<code>自适应 Hash索引</code>(Adaptive Hash Index)。什么情况下才会使用自适应Hash索引呢?如果某个数据经常被访问，当满足一定条件的时候</p>
<p>Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash表引的优点。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617163657697.png" alt="image-20220617163657697"></p>
<p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p>
<p>我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%adaptive_hash_index&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-二叉搜索树"><a href="#6-3-二叉搜索树" class="headerlink" title="6.3 二叉搜索树"></a>6.3 二叉搜索树</h3><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p>
<p><strong>1. 二叉搜索树的特点</strong></p>
<ul>
<li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li>
<li>左子节点 &lt; 本节点; 右子节点 &gt;= 本节点，比我大的向右，比我小的向左</li>
</ul>
<p><strong>2. 查找规则</strong></p>
<p>我们先来看下最基础的二叉搜索树(Binary Search Tree)，搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为key:</p>
<ol>
<li>如果key大于根节点，则在右子树中进行查找;</li>
<li>如果key小于根节点，则在左子树中进行查找;</li>
<li>如果key等于根节点，也就是找到了这个节点，返回根节点即可。</li>
</ol>
<p>举个例子，我们对数列(34，22，89，5，23，77，91）创造出来的二分查找树如下图所示:</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617164022728.png" alt="image-20220617164022728"></p>
<p>但是特殊情况，就是有时候二叉树的深度非常大，比如：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617164053134.png" alt="image-20220617164053134"></p>
<p>为了提高查询效率，就需要 减少磁盘IO数 。为了减少磁盘IO的次数，就需要尽量 降低树的高度 ，需要把 原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p>
<h3 id="6-4-AVL树"><a href="#6-4-AVL树" class="headerlink" title="6.4 AVL树"></a>6.4 AVL树</h3><p>为了解决上面二叉查找树退化成链表的问题，人们提出了<code>平衡二叉搜索树(Balanced Binary Tree)</code>，又称为AVL树(有别于AVL算法)，它在二叉搜索树的基础上增加了约束，具有以下性质:</p>
<p><strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong></p>
<p>这里说一下，常见的平衡二叉树有很多种，包括了<code>平衡二叉搜索树</code>、<code>红黑树</code>、<code>数堆</code>、<code>伸展树</code>。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是<code>0( log2n)</code>。</p>
<p>数据查询的时间主要依赖于磁盘I/O的次数，如果我们采用二叉树的形式,即使通过平衡二叉搜索树进行了改进，树的深度也是O(log2n)，当n比较大时，深度也是比较高的，比如下图的情况:</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617165105005.png" alt="image-20220617165105005"></p>
<p><code>每访问一次节点就需要进行一次磁盘 I/O 操作</code>，对于上面的树来说，我们需要进行 5次 I/O 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率。</p>
<p>针对同样的数据，如果我们把二叉树改成<code>M 叉树</code> （M&gt;2）呢？当 M=3 时，同样的 31 个节点可以由下面的三叉树来进行存储：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617165124685.png" alt="image-20220617165124685"></p>
<p>你能看到此时树的高度降低了，当数据量 N 大的时候，以及树的分叉树 M 大的时候，M叉树的高度会远小于二叉树的高度 (M &gt; 2)。所以，我们需要把 `树从“瘦高” 变 “矮胖”。</p>
<h3 id="6-5-B-Tree"><a href="#6-5-B-Tree" class="headerlink" title="6.5 B-Tree"></a>6.5 B-Tree</h3><p>B 树的英文是 Balance Tree，也就是 <code>多路平衡查找树</code>。简写为 B-Tree。它的高度远小于平衡二叉树的高度。</p>
<p>B 树的结构如下图所示：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617165937875.png" alt="image-20220617165937875"></p>
<p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，<code>M称为B树的阶</code>。每个磁盘块中包了<code>关键字</code>和<code>子节点的指针</code>。如果一个磁盘块中包括了x个关键字，那么指针数就是x+1。对于一个100阶的B树来说，如果有3层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。</p>
<p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p>
<ol>
<li>根节点的儿子数的范围是 [2,M]。 </li>
<li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为 [ceil(M/2), M]。 </li>
<li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。 </li>
<li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li>
<li>所有叶子节点位于同一层。</li>
</ol>
<p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。</p>
<p>然后我们来看下如何用 B 树进行查找。假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步：</p>
<ol>
<li>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； </li>
<li>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； </li>
<li>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</li>
</ol>
<p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。 B 树相比于平衡二叉树来说磁盘 I/O 操作要少 ， 在数据查询中比平衡二叉树效率要高。所以 只要树的高度足够低，IO次数足够少，就可以提高查询性能 。</p>
<p><strong>小结:</strong></p>
<ol>
<li>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li>
<li>关键字集合分布在整棵树中,即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束。</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找。</li>
</ol>
<p><strong>再举例1：</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617170526488.png" alt="image-20220617170526488"></p>
<h3 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B+Tree"></a>6.6 B+Tree</h3><p>B+树也是一种多路搜索树，<code>基于B树做出了改进</code>，主流的DBMS都支持B树的索引方式，比如MySQL。相比于B-Tree，<code>B+Tree适合文件索引系统</code>。</p>
<ul>
<li>MySQL官网说明：</li>
</ul>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617170710329.png" alt="image-20220617170710329"></p>
<p><strong>B+ 树和 B 树的差异在于以下几点：</strong></p>
<ol>
<li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数 +1。</li>
<li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小）。 </li>
<li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非 叶子节点既保存索引，也保存数据记录 。 </li>
<li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大 小从小到大顺序链接。</li>
</ol>
<p>下图就是一棵B+树，阶数为3，根节点中的关键字1、18、35分别是子节点(1，8，14)，(18，24，31)和(35，41，53)中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个指向下一个节点的指针，这样就形成了一个链表。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617171106671.png" alt="image-20220617171106671"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617171131747.png" alt="image-20220617171131747"></p>
<p>比如，我们想要查找关键字16，B+树会自顶向下逐层进行查找:</p>
<ol>
<li>与根节点的关键字(1，18，35)进行比较，16在1和18之间，得到指针P1(指向磁盘块2)</li>
<li>找到磁盘块2，关键字为(1，8，14)，因为16大于14，所以得到指针P3(指向磁盘块7)</li>
<li>找到磁盘块7，关键字为(14，16，17)，然后我们找到了关键字16，所以可以找到关键字16所对应的数据。</li>
</ol>
<p>其次，<strong>B+树的查询效率更高</strong>。这是因为通常B+树比B树<code>更矮胖</code>(阶数更大，深度更低)，查询所需要的磁盘I/o也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。<br>不仅是对单个关键字的查询上，<strong>在查询范围上，B+树的效率也比B树高</strong>。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p>
<blockquote>
<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p>
</blockquote>
<p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p>
<blockquote>
<p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。<br>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是:逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p>
</blockquote>
<p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p>
<blockquote>
<p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页(B+Tree中的一个节点)中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3<em>10^3</em>10^3=10亿条记录。(这里假定一个数据页也存储10^3条行记录数据了)</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在2~4 层。MysQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁热I/o操作。</p>
</blockquote>
<p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<blockquote>
<ol>
<li>B+树的磁盘读写代价更低<br> B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说lo读写次数也就降低了。</li>
<li>B+树的查询效率更加稳定<br> 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ol>
</blockquote>
<p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong></p>
<blockquote>
<ol>
<li>Hash索引不能进行范围查询，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。</li>
<li>Hash索引不支持联合索引的最左侧原则(即联合索引的部分索引无法使用)，而B+树可以。对于联合索引来说，Hash 索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</li>
<li>Hash,索引不支持 ORDER BY排序，因为Hash索引指向的数据是无序的因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY排序优化的作用。同理，我们也无法用Hash索引进行模糊查询，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。</li>
<li>InnoDB 不支持哈希索引</li>
</ol>
</blockquote>
<p><strong>思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</strong></p>
<blockquote>
<p>你能看到，针对InnoDB和MyISAM存储引擎，都会默认采用B+树索引，无法使用Hash索引。InnoDB提供的自适应Hash是不需要手动指定的。如果是Memory/Heap和NDB存储引擎，是可以进行选择Hash索引的。</p>
</blockquote>
<h3 id="6-7-R树"><a href="#6-7-R树" class="headerlink" title="6.7 R树"></a>6.7 R树</h3><p>R-Tree在MySQL很少使用，仅支持 geometry数据类型 ，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度 地图这种超大数据库中，这种方法便必定不可行了。R树就很好的解决了这种高维空间搜索问题 。它把B树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R树就是一棵用来 存储高维数据的平衡树 。相对于B-Tree，R-Tree的优势在于范围查找。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引 / 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>R-Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
</div>
<h3 id="6-8-小结"><a href="#6-8-小结" class="headerlink" title="6.8 小结"></a>6.8 小结</h3><p>使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间,当我们使用索引时，需要平衡索引的利(提升查询效率）和弊（维护索引所需的代价)。</p>
<p>在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管<code>索引不是万能的</code>，但<code>数据量大的时候不使用索引是不可想象的</code>，毕竟索引的本质，是帮助我们提升数据检索的效率。</p>
<h3 id="附录：算法的时间复杂度"><a href="#附录：算法的时间复杂度" class="headerlink" title="附录：算法的时间复杂度"></a>附录：算法的时间复杂度</h3><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在 于选择合适算法和改进算法。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617175516191.png" alt="image-20220617175516191"></p>
<h1 id="第7章-InnoDB数据存储结构"><a href="#第7章-InnoDB数据存储结构" class="headerlink" title="第7章_InnoDB数据存储结构"></a>第7章_InnoDB数据存储结构</h1><h2 id="1-数据库的存储结构：页"><a href="#1-数据库的存储结构：页" class="headerlink" title="1. 数据库的存储结构：页"></a>1. 数据库的存储结构：页</h2><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的存储引擎负责对表中数据的读取和写入工作。不同存储引擎中<code>存放的格式</code>一般是不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p>
<p>由于<code>InnoDB</code>是MysQL的<code>默认存储引擎</code>，所以本章剖析InnoDB存储引擎的数据存储结构。</p>
<h3 id="1-1-磁盘与内存交互基本单位：页"><a href="#1-1-磁盘与内存交互基本单位：页" class="headerlink" title="1.1 磁盘与内存交互基本单位：页"></a>1.1 磁盘与内存交互基本单位：页</h3><p>lnnoDB将数据划分为若干个页，InnoDB中页的大小默认为<strong>16KB</strong>。</p>
<p>以<code>页</code>作为磁盘和内存之间交互的<code>基本单位</code>，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。<strong>也就是说，在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页(Page)，数据库I/O操作的最小单位是页。</strong>一个页中可以存储多个行记录。</p>
<blockquote>
<p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读(也就是一次I/O操作)只能处理一行数据，效率会非常低</p>
</blockquote>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617193939742.png" alt="image-20220617193939742"></p>
<h3 id="1-2-页结构概述"><a href="#1-2-页结构概述" class="headerlink" title="1.2 页结构概述"></a>1.2 页结构概述</h3><p>页a、页b、页c…页n这些页可以<code>不在物理结构上相连</code>，只要通过<code>双向链表</code>相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边的记录生成一个<code>页目录</code>，在通过主键查找某条记录的时候可以在页目录中<code>使用二分法</code>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
<h3 id="1-3-页的大小"><a href="#1-3-页的大小" class="headerlink" title="1.3 页的大小"></a>1.3 页的大小</h3><p>不同的数据库管理系统（简称DBMS）的页大小不同。比如在 MySQL 的 InnoDB 存储引擎中，默认页的大小是 <code>16KB</code>，我们可以通过下面的命令来进行查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%innodb_page_size%&#x27;</span><br></pre></td></tr></table></figure>
<p>SQL Server 中页的大小为 <code>8KB</code>，而在 Oracle 中我们用术语 “<code>块</code>“ （Block）来表示 “页”，Oracle 支持的快大小为2KB, 4KB, 8KB, 16KB, 32KB 和 64KB。</p>
<h3 id="1-4-页的上层结构"><a href="#1-4-页的上层结构" class="headerlink" title="1.4 页的上层结构"></a>1.4 页的上层结构</h3><p>另外在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图所示：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617194256988.png" alt="image-20220617194256988"></p>
<p>区(Extent)是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配<code>64 个连续的页</code>。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB= <code>1MB</code>。</p>
<p>段(Segment)由一个或多个区组成，区在文件系统是一个连续分配的空间(在InnoDB中是连续的64个页)，不过在段中不要求区与区之间是相邻的。<code>段是数据库中的分配单位</code>，<code>不同类型的数据库对象以不同的段形式存在</code>。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p>
<p>表空间（Tablespace)是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为<code>系统表空间</code>、<code>用户表空间</code>、<code>撤销表空间</code>、<code>临时表空间</code>等。</p>
<h2 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2. 页的内部结构"></a>2. 页的内部结构</h2><p>页如果按类型划分的话，常见的有 <code>数据页（保存B+树节点）、系统表、Undo 页 和 事物数据页</code> 等。数据页是我们最常使用的页。</p>
<p>数据页的 <code>16KB</code> 大小的存储空间被划分为七个部分，分别是文件头（File Header）、页头（Page Header）、最大最小记录（Infimum + supremum）、用户记录（User Records）、空闲空间（Free Space）、页目录（Page Directory）和文件尾（File Tailer）。</p>
<p>页结构的示意图如下所示：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617195012446.png" alt="image-20220617195012446"></p>
<p>如下表所示：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220617195148164.png" alt="image-20220617195148164"></p>
<p>我们可以把这7个结构分为3个部分。</p>
<h3 id="第一部分：File-Header-文件头部-和-File-Trailer-文件尾部"><a href="#第一部分：File-Header-文件头部-和-File-Trailer-文件尾部" class="headerlink" title="第一部分：File Header (文件头部) 和 File Trailer (文件尾部)"></a>第一部分：File Header (文件头部) 和 File Trailer (文件尾部)</h3><p>见文件InnoDB数据库存储结构.mmap</p>
<h3 id="第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间"><a href="#第二部分：User-Records-用户记录-、最大最小记录、Free-Space-空闲空间" class="headerlink" title="第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)"></a>第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)</h3><p>见文件InnoDB数据库存储结构.mmap</p>
<h3 id="第三部分：Page-Directory-页目录-和-Page-Header-页面头部"><a href="#第三部分：Page-Directory-页目录-和-Page-Header-页面头部" class="headerlink" title="第三部分：Page Directory (页目录) 和 Page Header (页面头部)"></a>第三部分：Page Directory (页目录) 和 Page Header (页面头部)</h3><p>见文件InnoDB数据库存储结构.mmap</p>
<h3 id="2-3-从数据库页的角度看B-树如何查询"><a href="#2-3-从数据库页的角度看B-树如何查询" class="headerlink" title="2.3 从数据库页的角度看B+树如何查询"></a>2.3 从数据库页的角度看B+树如何查询</h3><p>一颗B+树按照字节类型可以分为两部分：</p>
<ol>
<li>叶子节点，B+ 树最底层的节点，节点的高度为0，存储行记录。</li>
<li>非叶子节点，节点的高度大于0，存储索引键和页面指针，并不存储行记录本身。</li>
</ol>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220620221112635.png" alt="image-20220620221112635"></p>
<p>当我们从页结构来理解 B+ 树的结构的时候，可以帮我们理解一些通过索引进行检索的原理：</p>
<p><strong>1. B+树是如何进行记录检索的?</strong></p>
<p>如果通过B树的索引查询行记录，首先是从B+树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽（slot)）采用<code>二分查找</code>的方式先找到一个粗略的记录分组，然后再在分组中通过<code>链表遍历</code>的方式查找记录。</p>
<p><strong>2. 普通索引和唯一索引在查询效率上有什么不同?</strong></p>
<p>我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢?</p>
<p>唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB存储引擎的页大小为16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次“判断下一条记录””的操作，对于CPU来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。</p>
<h2 id="3-InnoDB行格式-或记录格式"><a href="#3-InnoDB行格式-或记录格式" class="headerlink" title="3. InnoDB行格式 (或记录格式)"></a>3. InnoDB行格式 (或记录格式)</h2><p>见文件InnoDB数据库存储结构.mmap</p>
<h2 id="4-区、段与碎片区"><a href="#4-区、段与碎片区" class="headerlink" title="4. 区、段与碎片区"></a>4. 区、段与碎片区</h2><h3 id="4-1-为什么要有区？"><a href="#4-1-为什么要有区？" class="headerlink" title="4.1 为什么要有区？"></a>4.1 为什么要有区？</h3><p><code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页为单位</code>来分配存储空间的话，双向链表相邻的两个页之间的<code>物理位置可能离得非常远</code>。我们介绍B+树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/0</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O是非常慢</code>的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</p>
<p>引入<code>区</code>的概念，一个区就是在物理位置上连续的<code>64个页</code>。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=<code>1MB</code>。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照<code>区为单位分配</code>，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成<code>一点点空间的浪费</code>（数据不足以填充满整个区)，但是从性能角度看，可以消除很多的随机I/O，<code>功大于过</code>!</p>
<h3 id="4-2-为什么要有段？"><a href="#4-2-为什么要有段？" class="headerlink" title="4.2 为什么要有段？"></a>4.2 为什么要有段？</h3><p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的<code>叶子节点</code>和<code>非叶子节点</code>进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个<code>段 ( segment)</code>，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个<code>叶子节点段</code>，一个<code>非叶子节点段</code>。</p>
<p>除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有<code>数据段</code>、<code>索引段</code>、<code>回滚段</code>。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。</p>
<p>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。</p>
<p>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p>
<h3 id="4-3-为什么要有碎片区？"><a href="#4-3-为什么要有碎片区？" class="headerlink" title="4.3 为什么要有碎片区？"></a>4.3 为什么要有碎片区？</h3><p>默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M(64<em>16Kb=1024Kb）存储空间，所以<em>*默认情况下一个只存了几条记录的小表也需要2M的存储空间么?</em></em>以后每次添加一个索引都要多申请2M的存储空间么?这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p>
<p>为了考虑以完整的区为单位分配给某个段对于<code>数据量较小</code>的表太浪费存储空间的这种情况，InnoDB提出了一个<code>碎片(fragment)区</code>的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。<code>碎片区直属于表空间</code>，并不属于任何一个段。</p>
<p>所以此后为某个段分配存储空间的策略是这样的:</p>
<ul>
<li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li>
<li>当某个段已经占用了<code>32个碎片区</code>页面之后，就会申请以完整的区为单位来分配存储空间。</li>
</ul>
<p>所以现在段不能仅定义为是某些区的集合，更精确的应该是<code>某些零散的页面</code>以及<code>一些完整的区</code>的集合。</p>
<h3 id="4-4-区的分类"><a href="#4-4-区的分类" class="headerlink" title="4.4 区的分类"></a>4.4 区的分类</h3><p>区大体上可以分为4种类型：</p>
<ul>
<li>空闲的区 (FREE) : 现在还没有用到这个区中的任何页面。</li>
<li>有剩余空间的碎片区 (FREE_FRAG)：表示碎片区中还有可用的页面。</li>
<li>没有剩余空间的碎片区 (FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面。</li>
<li>附属于某个段的区 (FSEG)：每一个索引都可以分为叶子节点段和非叶子节点段。</li>
</ul>
<p>处于FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，直属于表空间。而处于 FSEG 状态的区是附属于某个段的。</p>
<blockquote>
<p>如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于 FSEG 的区全部隶属于某个段，而处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。</p>
</blockquote>
<h2 id="5-表空间"><a href="#5-表空间" class="headerlink" title="5. 表空间"></a>5. 表空间</h2><p>表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p>
<p>表空间是一个<code>逻辑容器</code>，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为<code>系统表空间</code>(System tablespace)、<code>独立表空间</code>(File-per-table tablespace)、<code>撤销表空间</code>(Undo Tablespace)和<code>临时表空间</code><br>(Temporary Tablespace)等。</p>
<h3 id="5-1-独立表空间"><a href="#5-1-独立表空间" class="headerlink" title="5.1 独立表空间"></a>5.1 独立表空间</h3><p>独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间 (即：单表) 可以在不同的数据库之间进行 <code>迁移</code>。</p>
<p>空间可以回收 (DROP TABLE 操作可自动回收表空间；其他情况，表空间不能自己回收) 。如果对于统计分析或是日志表，删除大量数据后可以通过：alter table TableName engine=innodb; 回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</p>
<p><strong>独立表空间结构</strong></p>
<p>独立表空间由段、区、页组成。</p>
<p><strong>真实表空间对应的文件大小</strong></p>
<p>我们到数据目录里看，会发现一个新建的表对应的 .ibd 文件只占用了 96K，才6个页面大小 (MySQL5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些 .ibd 文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p>
<p><strong>查看 InnoDB 的表空间类型：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;innodb_file_per_table&#x27;</span><br></pre></td></tr></table></figure>
<p>你能看到 innodb_file_per_table=ON, 这就意味着每张表都会单词保存一个 .ibd 文件。</p>
<h3 id="5-2-系统表空间"><a href="#5-2-系统表空间" class="headerlink" title="5.2 系统表空间"></a>5.2 系统表空间</h3><p>系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</p>
<p><strong>InnoDB数据字典</strong></p>
<p>每当我们向一个表中插入一条记录的时候，<code>MySQL较验过程</code>如下:</p>
<p>先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的B+树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-某个表属于哪个表空间，表里边有多少列</span><br><span class="line">-表对应的每一个列的类型是什么</span><br><span class="line">-该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面-该表有哪些外键，外键对应哪个表的哪些列</span><br><span class="line">-某个表空间对应文件系统上文件路径是什么</span><br><span class="line">-...</span><br></pre></td></tr></table></figure>
<p>删除这些数据并不是我们使用 INSERT 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得以引入的一些额外数据，这些数据页称为 元数据。InnoDB 存储引擎特意定义了一些列的 内部系统表 (internal system table) 来记录这些元数据：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>表名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SYS_TABLES</td>
<td>整个InnoDB存储引擎中所有的表的信息</td>
</tr>
<tr>
<td>SYS_COLUMNS</td>
<td>整个InnoDB存储引擎中所有的列的信息</td>
</tr>
<tr>
<td>SYS_INDEXES</td>
<td>整个InnoDB存储引擎中所有的索引的信息</td>
</tr>
<tr>
<td>SYS_FIELDS</td>
<td>整个InnoDB存储引擎中所有的索引对应的列的信息</td>
</tr>
<tr>
<td>SYS_FOREIGN</td>
<td>整个InnoDB存储引擎中所有的外键的信息</td>
</tr>
<tr>
<td>SYS_FOREIGN_COLS</td>
<td>整个InnoDB存储引擎中所有的外键对应列的信息</td>
</tr>
<tr>
<td>SYS_TABLESPACES</td>
<td>整个InnoDB存储引擎中所有的表空间信息</td>
</tr>
<tr>
<td>SYS_DATAFILES</td>
<td>整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息</td>
</tr>
<tr>
<td>SYS_VIRTUAL</td>
<td>整个InnoDB存储引擎中所有的虚拟生成列的信息</td>
</tr>
</tbody>
</table>
</div>
<p>这些系统表也称为 <code>数据字典</code>，它们都是以 B+ 树的形式保存在系统表空间的某个页面中。其中 <code>SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS</code> 这四个表尤其重要，称之为基本系统表 (basic system tables) ，我们先看看这4个表的结构：</p>
<p><strong>SYS_TABLES表结构</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME</code></td>
<td>表的名称。主键</td>
</tr>
<tr>
<td><code>ID</code></td>
<td>InnoDB存储引擎中每个表都有一个唯一的ID。(二级索引)</td>
</tr>
<tr>
<td><code>N_coLs</code></td>
<td>该表拥有列的个数</td>
</tr>
<tr>
<td><code>TYPE</code></td>
<td>表的类型，记录了一些文件格式、行格式、压缩等信息</td>
</tr>
<tr>
<td><code>MIX_ID</code></td>
<td>已过时，忽略</td>
</tr>
<tr>
<td><code>MIX_LEN</code></td>
<td>表的一些额外的属性</td>
</tr>
<tr>
<td><code>CLUSTER_ID</code></td>
<td>未使用，忽略</td>
</tr>
<tr>
<td><code>SPACE</code></td>
<td>该表所属表空间的ID</td>
</tr>
</tbody>
</table>
</div>
<p><strong>SYS_COLUMNS表结构</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TABLE_ID</code></td>
<td>该列所属表对应的ID。(与POS一起构成联合主键)</td>
</tr>
<tr>
<td><code>POS</code></td>
<td>该列在表中是第几列</td>
</tr>
<tr>
<td><code>NAME</code></td>
<td>该列的名称</td>
</tr>
<tr>
<td><code>MTYPE</code></td>
<td>main data type，主数据类型，就是那堆INT、CHAR、VARCHAR、FLOAT、DOUBLE之类的东东</td>
</tr>
<tr>
<td><code>PRTYPE</code></td>
<td>precise type，精确数据类型，就是修饰主数据类型的那堆东东, 比如是否允许NULL值，是否允许负数啥的</td>
</tr>
<tr>
<td><code>LEN</code></td>
<td>该列最多占用存储空间的字节数</td>
</tr>
<tr>
<td><code>PREC</code></td>
<td>该列的精度，不过这列貌似都没有使用，默认值都是0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>SYS_INDEXES表结构</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>TABLE_ID</td>
<td>该索引所属表对应的ID。(与ID一起构成联合主键)</td>
</tr>
<tr>
<td>ID</td>
<td>InnoDB存储引擎中每个索引都有一个唯一的ID</td>
</tr>
<tr>
<td>NAME</td>
<td>该索引的名称</td>
</tr>
<tr>
<td>M_FIELDS</td>
<td>该索引包含列的个数</td>
</tr>
<tr>
<td>TYPE</td>
<td>该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型</td>
</tr>
<tr>
<td>SPACE</td>
<td>该索引根页面所在的表空间ID</td>
</tr>
<tr>
<td>PAGE_NO</td>
<td>该索引根页面所在的页面号</td>
</tr>
<tr>
<td>MERGE_ THRESHOLD</td>
<td>如果页面中的记录被删除到某个比例，就把该页面和相邻页面合并，这个值就是这个比例</td>
</tr>
</tbody>
</table>
</div>
<p><strong>SYS_FIELDS表结构</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>INDEX_ID</td>
<td>该索引所属的ID。（与POS一起构成联合主键）</td>
</tr>
<tr>
<td>POS</td>
<td>该索引列在某个索引中是第几列</td>
</tr>
<tr>
<td>COL_NAME</td>
<td>该索引列的名称</td>
</tr>
</tbody>
</table>
</div>
<p>注意：用户不能直接访问 InnoDB 的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库 <code>information_schema</code> 中提供了一些以 <code>innodb_sys</code> 开头的表:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE information_schema;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES LIKE &#x27;innodb_sys%&#x27;;</span><br></pre></td></tr></table></figure>
<p>在 <code>information_scheme</code> 数据库中的这些以 <code>INNODB_SYS</code> 开头的表并不是真正的内部系统表 (内部系统表就是我们上边以 <code>SYS</code> 开头的那些表)，而是在存储引擎启动时读取这些以 <code>SYS</code> 开头的系统表，然后填充到这些以 <code>INNODB_SYS</code> 开头的表中。以 <code>INNODB_SYS</code> 开头的表和以 <code>SYS</code> 开头的表中的字段并不完全一样，但仅供大家参考已经足矣。</p>
<h2 id="附录：数据页加载的三种方式"><a href="#附录：数据页加载的三种方式" class="headerlink" title="附录：数据页加载的三种方式"></a>附录：数据页加载的三种方式</h2><p>InnoDB从磁盘中读取数据 <code>最小单位</code> 是数据页。而你想得到的 id = xxx 的数据，就是这个数据页众多行中的一行。</p>
<p>对于MySQL存放的数据，逻辑概念上我们称之为表，在磁盘等物理层面而言是按 <code>数据页</code> 形式进行存放的，当其加载到 MySQL 中我们称之为 <code>缓存页</code>。</p>
<p>如果缓冲池没有该页数据，那么缓冲池有以下三种读取数据的方式，每种方式的读取速率是不同的：</p>
<p><strong>1. 内存读取</strong></p>
<p>如果该数据存在于内存中，基本上执行时间在 1ms 左右，效率还是很高的。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220621135638283.png" alt="image-20220621135638283"></p>
<p><strong>2. 随机读取</strong></p>
<p>如果数据没有在内存中，就需要在磁盘上对该页进行查找，整体时间预估在10ms左右，在10ms中有6ms是磁盘的实际繁忙时间（包括了寻道和半圈旋转时间），有3ms是对可能发生的排队实际的估计值，另外还有1ms的传输时间，将页从磁盘服务器缓冲区传输到数据库缓冲区中。这10ms看起来很快，但实际上对于数据库来说消耗的时间已经非常长了，因为这还只是一个页的读取时间。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220621135737422.png" alt="image-20220621135737422"></p>
<p><strong>3. 顺序读取</strong></p>
<p>顺序读取其实是一种批量读取的方式，因为我们请求的<code>数据在磁盘上往往都是相邻存储的</code>，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘I/O操作了。如果一个磁盘的吞吐量是40MB/S，那么对于一个16KB大小的页来说，一次可以顺序读取2560 (4OMB/16KB)个页，相当于一个页的读取时间为0.4ms。采用批量读取的方式，即使是从磁盘上进行读取效率也比从内存中只单独读取一个页的效率要高。</p>
<h1 id="第8章-索引的创建与设计原则"><a href="#第8章-索引的创建与设计原则" class="headerlink" title="第8章_索引的创建与设计原则"></a>第8章_索引的创建与设计原则</h1><h2 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1. 索引的声明与使用"></a>1. 索引的声明与使用</h2><h3 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a>1.1 索引的分类</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p>
<p>从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。 </p>
<p>按照 物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。 </p>
<p>按照 作用字段个数 进行划分，分成单列索引和联合索引。</p>
<p><strong>1. 普通索引</strong></p>
<p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在<code>任何数据类型</code>中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表<code>student</code>的字段<code>name</code>上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p>
<p><strong>2. 唯一性索引</strong></p>
<p>使用<code>UNIQUE参数</code>可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里<code>可以有多个</code>唯一索引。</p>
<p>例如，在表<code>student</code>的字段<code>email</code>中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯一性索引，可以更快速地确定某条记录。</p>
<p><strong>3. 主键索引</strong></p>
<p>主键索引就是一种<code>特殊的唯一性索引</code>，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL+UNIQUE，一张表里<code>最多只有一个</code>主键索引。</p>
<p><code>Why?</code>这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p>
<p><strong>4. 单列索引</strong></p>
<p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以<code>有多个</code>单列索引。</p>
<p><strong>5. 多列 (组合、联合) 索引</strong></p>
<p>多列索引是在表的<code>多个字段组合</code>上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引<code>idx_id_name_gender</code>，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循<code>最左前缀集合</code>。</p>
<p><strong>6. 全文检索</strong></p>
<p>全文索引（也称全文检索)是目前<code>搜索引擎</code>使用的一种关键技术。它能够利用【<code>分词技术</code>】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p>
<p>使用参数<code>FULLTEXT</code>可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在<code>CHAR</code>、<code>VARCHAR</code>或<code>TEXT</code>类型及其系列类型的字段上，<strong>查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度</strong>。例如，表<code>student</code>的字段<code>information</code>是<code>TEXT</code>类型，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p>
<p>全文索引典型的有两种类型:自然语言的全文索引和布尔全文索引。</p>
<ul>
<li>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。<strong>在整个索引中出现次数越少的词语，匹配时的相关度就越高</strong>。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</li>
</ul>
<p>MysQL数据库从3.23.23版开始支持全文索引，但MySQL5.6.4以前只有<code>Myisam</code>支持，5.6.4版本以后<code>innodb才支持</code>，但是官方版本不支持<code>中文分词</code>，需要第三方分词插件。在5.7.6版本，MySQL内置了<code>ngram全文解析器</code>，用来支持亚洲语种的分词。测试或使用全文索引时，要先看一下自己的MySQL版本、存储引擎和数据类型是否支持全文索引。</p>
<p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被<code>solr</code>、<code>ElasticSearch</code>等专门的搜索引擎所替代。</p>
<p><strong>7. 补充：空间索引</strong></p>
<p>使用参数<code>SPATIAL</code>可以设置索引为<code>空间索引</code>。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括<code>GEOMETRY</code>、<code>POINT</code>、<code>LINESTRING</code>和<code>POLYGON</code>等。目前只有MylISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。</p>
<p><strong>小结：不同的存储引擎支持的索引类型也不一样 </strong></p>
<p>InnoDB ：支持 B-tree、Full-text 等索引，不支持 Hash 索引； </p>
<p>MyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引； </p>
<p>Memory ：支持 B-tree、Hash 等 索引，不支持 Full-text 索引；</p>
<p>NDB ：支持 Hash 索引，不支持 B-tree、Full-text 等索引； </p>
<p>Archive ：不支 持 B-tree、Hash、Full-text 等索引；</p>
<h3 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a>1.2 创建索引</h3><p>MySQL支持多种方法在单个或多个列上创建索引：在创建表的定义语句<code>CREATE TABLE</code>中指定索引列，使用 <code>ALTER TABLE</code>语句在存在的表上创建索引，或者使用 <code>CREATE INDEX</code>语句在已存在的表上添加索引。</p>
<h4 id="1-创建表的时候创建索引"><a href="#1-创建表的时候创建索引" class="headerlink" title="1. 创建表的时候创建索引"></a>1. 创建表的时候创建索引</h4><p>使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dept(</span><br><span class="line">dept_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">dept_name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">emp_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">emp_name VARCHAR(20) UNIQUE,</span><br><span class="line">dept_id INT,</span><br><span class="line">CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>但是，如果显式创建表时创建索引的话，基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type]</span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC |</span><br><span class="line">DESC]</span><br></pre></td></tr></table></figure>
<ul>
<li>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引； </li>
<li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引； </li>
<li>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； </li>
<li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； </li>
<li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； </li>
<li>ASC 或 DESC 指定升序或者降序的索引值存储。</li>
</ul>
<p><strong>1. 创建普通索引</strong></p>
<p>在book表中的year_publication字段上建立普通索引，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE book(</span><br><span class="line">book_id INT ,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">authors VARCHAR(100),</span><br><span class="line">info VARCHAR(100) ,</span><br><span class="line">comment VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">INDEX(year_publication)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>2. 创建唯一索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test1(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name varchar(30) NOT NULL,</span><br><span class="line">UNIQUE INDEX uk_idx_id(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM test1 \G</span><br></pre></td></tr></table></figure>
<p><strong>3. 主键索引</strong></p>
<p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法：</p>
<ul>
<li>随表一起建索引：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">id INT(10) UNSIGNED AUTO_INCREMENT ,</span><br><span class="line">student_no VARCHAR(200),</span><br><span class="line">student_name VARCHAR(200),</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>删除主键索引：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">drop PRIMARY KEY;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引</li>
</ul>
<p><strong>4. 创建单列索引</strong></p>
<p>引举:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test2(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name CHAR(50) NULL,</span><br><span class="line">INDEX single_idx_name(name(20))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM test2 \G</span><br></pre></td></tr></table></figure>
<p><strong>5. 创建组合索引</strong></p>
<p>举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test3(</span><br><span class="line">id INT(11) NOT NULL,</span><br><span class="line">name CHAR(30) NOT NULL,</span><br><span class="line">age INT(11) NOT NULL,</span><br><span class="line">info VARCHAR(255),</span><br><span class="line">INDEX multi_idx(id,name,age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>该语句执行完毕之后，使用SHOW INDEX 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM test3 \G</span><br></pre></td></tr></table></figure>
<p>在test3表中，查询id和name字段，使用EXPLAIN语句查看索引的使用情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test3 WHERE id=1 AND name=&#x27;songhongkang&#x27; \G</span><br></pre></td></tr></table></figure>
<p>可以看到，查询id和name字段时，使用了名称为MultiIdx的索引，如果查询 (name, age) 组合或者单独查询name和age字段，会发现结果中possible_keys和key值为NULL, 并没有使用在t3表中创建的索引进行查询。</p>
<p><strong>6. 创建全文索引</strong></p>
<p>FULLTEXT全文索引可以用于全文检索，并且只为 <code>CHAR</code> 、<code>VARCHAR</code> 和 <code>TEXT</code> 列创建索引。索引总是对整个列进行，不支持局部 (前缀) 索引。</p>
<p>举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test4(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name CHAR(30) NOT NULL,</span><br><span class="line">age INT NOT NULL,</span><br><span class="line">info VARCHAR(255),</span><br><span class="line">FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。</p>
</blockquote>
<p>语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM test4 \G</span><br></pre></td></tr></table></figure>
<p>由结果可以看到，info字段上已经成功建立了一个名为futxt_idx_info的FULLTEXT索引。</p>
<p>举例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE articles (</span><br><span class="line">id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">title VARCHAR (200),</span><br><span class="line">body TEXT,</span><br><span class="line">FULLTEXT index (title, body)</span><br><span class="line">) ENGINE = INNODB;</span><br></pre></td></tr></table></figure>
<p>创建了一个给title和body字段添加全文索引的表。</p>
<p>举例3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `papers` (</span><br><span class="line">`id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">`title` varchar(200) DEFAULT NULL,</span><br><span class="line">`content` text,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">FULLTEXT KEY `title` (`title`,`content`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p>不同于like方式的的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;</span><br></pre></td></tr></table></figure>
<p>全文索引用match+against方式查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);</span><br></pre></td></tr></table></figure>
<p>明显的提高查询效率。</p>
<blockquote>
<p>注意点 </p>
<ol>
<li>使用全文索引前，搞清楚版本支持情况； </li>
<li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li>
<li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</li>
</ol>
</blockquote>
<p><strong>7. 创建空间索引</strong></p>
<p>空间索引创建中，要求空间类型的字段必须为 非空 。</p>
<p>举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test5(</span><br><span class="line">geo GEOMETRY NOT NULL,</span><br><span class="line">SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>
<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM test5 \G</span><br></pre></td></tr></table></figure>
<p>可以看到，test5表的geo字段上创建了名称为spa_idx_geo的空间索引。注意创建时指定空间类型字段值的非空约束，并且表的存储引擎为MyISAM。</p>
<h4 id="2-在已经存在的表上创建索引"><a href="#2-在已经存在的表上创建索引" class="headerlink" title="2. 在已经存在的表上创建索引"></a>2. 在已经存在的表上创建索引</h4><p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。</p>
<p><strong>1. 使用ALTER TABLE语句创建索引</strong> ALTER TABLE语句创建索引的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]</span><br><span class="line">[index_name] (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>
<p><strong>2. 使用CREATE INDEX创建索引</strong> CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中， CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name</span><br><span class="line">ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>
<h3 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a>1.3 删除索引</h3><p><strong>1. 使用ALTER TABLE删除索引</strong>  ALTER TABLE删除索引的基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure>
<p><strong>2. 使用DROP INDEX语句删除索引</strong> DROP INDEX删除索引的基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示: 删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p>
</blockquote>
<h2 id="2-MySQL8-0索引新特性"><a href="#2-MySQL8-0索引新特性" class="headerlink" title="2. MySQL8.0索引新特性"></a>2. MySQL8.0索引新特性</h2><h3 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a>2.1 支持降序索引</h3><p>降序索引以降序存储键值。虽然在语法上，从MySQL 4版本开始就已经支持降序索引的语法了，但实际上DESC定义是被忽略的，直到MySQL 8.x版本才开始真正支持降序索引 (仅限于InnoDB存储引擎)。</p>
<p>MySQL在<code>8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率</code>。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</p>
<p>举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));</span><br></pre></td></tr></table></figure>
<p>在MySQL 5.7版本中查看数据表ts1的结构，结果如下:</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220622224124267.png" alt="image-20220622224124267"></p>
<p>从结果可以看出，索引仍然是默认的升序</p>
<p>在MySQL 8.0版本中查看数据表ts1的结构，结果如下：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220622224205048.png" alt="image-20220622224205048"></p>
<p>从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。</p>
<p>分别在MySQL 5.7版本和MySQL 8.0版本的数据表ts1中插入800条随机数据，执行语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE ts_insert()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	WHILE i &lt; 800</span><br><span class="line">	DO</span><br><span class="line">		insert into ts1 select rand()*80000, rand()*80000;</span><br><span class="line">		SET i = i+1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	commit;</span><br><span class="line">END //</span><br><span class="line">DELIMITER;</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line">CALL ts_insert();</span><br></pre></td></tr></table></figure>
<p>在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a, b DESC LIMIT 5;</span><br></pre></td></tr></table></figure>
<p>在MySQL 8.0版本中查看数据表 ts1 的执行计划。</p>
<p>从结果可以看出，修改后MySQL 5.7 的执行计划要明显好于MySQL 8.0。</p>
<h3 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a>2.2 隐藏索引</h3><p>在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较 大，这种操作就会消耗系统过多的资源，操作成本非常高。</p>
<p>从MySQL 8.x开始支持 <code>隐藏索引（invisible indexes）</code> ，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引）， 确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 <code>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</code>。</p>
<p>同时，如果你想验证某个索引删除之后的 <code>查询性能影响</code>，就可以暂时先隐藏该索引。</p>
<blockquote>
<p>注意：</p>
<p>主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。</p>
</blockquote>
<p>索引默认是可见的，在使用CREATE TABLE, CREATE INDEX 或者 ALTER TABLE 等语句时可以通过 <code>VISIBLE</code> 或者 <code>INVISIBLE</code> 关键词设置索引的可见性。</p>
<p><strong>1. 创建表时直接创建</strong></p>
<p>在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">propname1 type1[CONSTRAINT1],</span><br><span class="line">propname2 type2[CONSTRAINT2],</span><br><span class="line">……</span><br><span class="line">propnamen typen,</span><br><span class="line">INDEX [indexname](propname1 [(length)]) INVISIBLE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。</p>
<p><strong>2. 在已经存在的表上创建</strong></p>
<p>可以为已经存在的表设置隐藏索引，其语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX indexname</span><br><span class="line">ON tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>
<p><strong>3. 通过ALTER TABLE语句创建</strong></p>
<p>语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tablename</span><br><span class="line">ADD INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>
<p><strong>4. 切换索引可见状态</strong></p>
<p>已存在的索引可通过如下语句切换可见状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引</span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure>
<p>如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引。</p>
<blockquote>
<p>注意 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p>
</blockquote>
<p>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</p>
<p><strong>5. 使隐藏索引对查询优化器可见</strong></p>
<p>在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关 (use_invisible_indexes) 来打开某个设置，使隐藏索引对查询优化器可见。如果use_invisible_indexes 设置为off (默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计 划时仍会考虑使用隐藏索引。</p>
<p>（1）在MySQL命令行执行如下命令查看查询优化器的开关设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G</span><br></pre></td></tr></table></figure>
<p>在输出的结果信息中找到如下属性配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use_invisible_indexes=off</span><br></pre></td></tr></table></figure>
<p>此属性配置值为off，说明隐藏索引默认对查询优化器不可见。</p>
<p>（2）使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=on&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>SQL语句执行成功，再次查看查询优化器的开关设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@optimizer_switch:</span><br><span class="line">index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_</span><br><span class="line">intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_co</span><br><span class="line">st_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on</span><br><span class="line">,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on</span><br><span class="line">,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_ind</span><br><span class="line">exes=on,skip_scan=on,hash_join=on</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>此时，在输出结果中可以看到如下属性配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use_invisible_indexes=on</span><br></pre></td></tr></table></figure>
<p>use_invisible_indexes属性的值为on，说明此时隐藏索引对查询优化器可见。</p>
<p>（3）使用EXPLAIN查看以字段invisible_column作为查询条件时的索引使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from classes where cname = &#x27;高一2班&#x27;;</span><br></pre></td></tr></table></figure>
<p>查询优化器会使用隐藏索引来查询数据。</p>
<p>（4）如果需要使隐藏索引对查询优化器不可见，则只需要执行如下命令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=off&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>再次查看查询优化器的开关设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G</span><br></pre></td></tr></table></figure>
<p>此时，use_invisible_indexes属性的值已经被设置为“off”。</p>
<h2 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3. 索引的设计原则"></a>3. 索引的设计原则</h2><p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。<strong>索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。</strong>高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。</p>
<h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><p><strong>第1步：创建数据库、创建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE atguigudb1;</span><br><span class="line">USE atguigudb1;</span><br><span class="line">#1.创建学生表和课程表</span><br><span class="line">CREATE TABLE `student_info` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`student_id` INT NOT NULL ,</span><br><span class="line">`name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">`course_id` INT NOT NULL ,</span><br><span class="line">`class_id` INT(11) DEFAULT NULL,</span><br><span class="line">`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `course` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`course_id` INT NOT NULL ,</span><br><span class="line">`course_name` VARCHAR(40) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p><strong>第2步：创建模拟数据必需的存储函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#函数1：创建随机产生字符串函数</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_string(n INT)</span><br><span class="line">	RETURNS VARCHAR(255) #该函数会返回一个字符串</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">	DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">    	SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">    	SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    RETURN return_str;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#函数2：创建随机数函数</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;</span><br><span class="line">RETURN i;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>创建函数，假如报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This function has none of DETERMINISTIC......</span><br></pre></td></tr></table></figure>
<p>由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。</p>
<p>主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使 用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置。</p>
<ul>
<li>查看mysql是否允许创建函数：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;log_bin_trust_function_creators&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>命令开启：允许创建函数设置：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>mysqld重启，上述参数又会消失。永久方法：</p>
<ul>
<li><p>windows下：my.ini[mysqld]加上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log_bin_trust_function_creators=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>linux下：/etc/my.cnf下my.cnf[mysqld]加上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log_bin_trust_function_creators=1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>第3步：创建插入模拟数据的存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 存储过程1：创建插入课程表存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_course( max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line">SET i = i + 1; #赋值</span><br><span class="line">INSERT INTO course (course_id, course_name ) VALUES</span><br><span class="line">(rand_num(10000,10100),rand_string(6));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT; #提交事务</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 存储过程2：创建插入学生信息表存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_stu( max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line">SET i = i + 1; #赋值</span><br><span class="line">INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES</span><br><span class="line">(rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT; #提交事务</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p><strong>第4步：调用存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL insert_course(100);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL insert_stu(1000000);</span><br></pre></td></tr></table></figure>
<h3 id="3-2-哪些情况适合创建索引"><a href="#3-2-哪些情况适合创建索引" class="headerlink" title="3.2 哪些情况适合创建索引"></a>3.2 哪些情况适合创建索引</h3><h4 id="1-字段的数值有唯一性的限制"><a href="#1-字段的数值有唯一性的限制" class="headerlink" title="1. 字段的数值有唯一性的限制"></a>1. 字段的数值有唯一性的限制</h4><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果<code>某个字段是唯一性的</code>，就可以直接创建<code>唯一性索引</code>，或者<code>主键索引</code>。这样可以更快速地通过该索引来确定某条记录。</p>
<p>例如，学生表中<code>学号</code>是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用<code>姓名</code>的话，可能存在同名现象，从而降低查询速度。</p>
<blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。(来源: Alibaba)</p>
<p>说明:不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
</blockquote>
<h4 id="2-频繁作为-WHERE-查询条件的字段"><a href="#2-频繁作为-WHERE-查询条件的字段" class="headerlink" title="2. 频繁作为 WHERE 查询条件的字段"></a>2. 频繁作为 WHERE 查询条件的字段</h4><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。 </p>
<p>比如student_info数据表（含100万条数据），假设我们想要查询 student_id=123110 的用户信息。</p>
<h4 id="3-经常-GROUP-BY-和-ORDER-BY-的列"><a href="#3-经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="3. 经常 GROUP BY 和 ORDER BY 的列"></a>3. 经常 GROUP BY 和 ORDER BY 的列</h4><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立组合索引 。</p>
<h4 id="4-UPDATE、DELETE-的-WHERE-条件列"><a href="#4-UPDATE、DELETE-的-WHERE-条件列" class="headerlink" title="4. UPDATE、DELETE 的 WHERE 条件列"></a>4. UPDATE、DELETE 的 WHERE 条件列</h4><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p>
<h4 id="5-DISTINCT-字段需要创建索引"><a href="#5-DISTINCT-字段需要创建索引" class="headerlink" title="5.DISTINCT 字段需要创建索引"></a>5.DISTINCT 字段需要创建索引</h4><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。 </p>
<p>比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure>
<p>运行结果（600637 条记录，运行时间 0.683s ）</p>
<p>如果我们对 student_id 创建索引，再执行 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure>
<p>运行结果（600637 条记录，运行时间 0.010s ）</p>
<p>你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</p>
<h4 id="6-多表-JOIN-连接操作时，创建索引注意事项"><a href="#6-多表-JOIN-连接操作时，创建索引注意事项" class="headerlink" title="6. 多表 JOIN 连接操作时，创建索引注意事项"></a>6. 多表 JOIN 连接操作时，创建索引注意事项</h4><p>首先， <code>连接表的数量尽量不要超过 3 张</code> ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增 长会非常快，严重影响查询的效率。 </p>
<p>其次， <code>对 WHERE 条件创建索引</code> ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下， 没有 WHERE 条件过滤是非常可怕的。 </p>
<p>最后， <code>对用于连接的字段创建索引</code> ，并且该字段在多张表中的 类型必须一致 。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p>
<p>举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT s.course_id, name, s.student_id, c.course_name</span><br><span class="line">FROM student_info s JOIN course c</span><br><span class="line">ON s.course_id = c.course_id</span><br><span class="line">WHERE name = &#x27;462eed7ac6e791292a79&#x27;;</span><br></pre></td></tr></table></figure>
<p>运行结果（1 条数据，运行时间 0.189s ）</p>
<p>这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。</p>
<h4 id="7-使用列的类型小的创建索引"><a href="#7-使用列的类型小的创建索引" class="headerlink" title="7. 使用列的类型小的创建索引"></a>7. 使用列的类型小的创建索引</h4><p>我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。</p>
<p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<code>TINYINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用<code>INT</code>就不要使用<code>BIGINT</code>，能使用<code>MEDIUMINT</code> 就不要使用<code>INT</code>。这是因为:</p>
<ul>
<li><p>数据类型越小，在查询时进行的比较操作越快</p>
</li>
<li><p>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以<code>放下更多的记录</code>，从而减少磁盘<code>I/0</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</p>
</li>
</ul>
<p>这个建议对于表的<code>主键来说更加适用</code>，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/0。</p>
<h4 id="8-使用字符串前缀创建索引"><a href="#8-使用字符串前缀创建索引" class="headerlink" title="8. 使用字符串前缀创建索引"></a>8. 使用字符串前缀创建索引</h4><p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题:</p>
<ul>
<li>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，<code>在索引中占用的存储空间越大</code>。</li>
<li>如果B+树索引中索引列存储的字符串很长，那在做字符串<code>比较时会占用更多的时间</code>。</li>
</ul>
<p>我们可以通过截取字段的前面一部分内容建立索引，这个就叫<code>前缀索引</code>。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既<code>节约空间</code>，又<code>减少了字符串的比较时间</code>，还大体能解决排序的问题。</p>
<p>例如，<code>TEXT</code>和<code>BLOG</code>类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。</p>
<p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table shop(address varchar(120) not null);</span><br><span class="line">alter table shop add index(address(12));</span><br></pre></td></tr></table></figure>
<p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字 段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？</p>
<p>先看一下字段在全部数据中的选择度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct address) / count(*) from shop</span><br></pre></td></tr></table></figure>
<p>通过不同长度去计算，与全表的选择性对比：</p>
<p>公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count(distinct left(列名, 索引长度))/count(*)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度</span><br><span class="line">count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度</span><br><span class="line">count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度</span><br><span class="line">count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度</span><br><span class="line">from shop;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>越接近于1越好，说明越有区分度</p>
</blockquote>
<p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p>
<p>如果使用了索引列前缀，比方说前边只把address列的 <code>前12个字符</code> 放到了二级索引中，下边这个查询可能就有点尴尬了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM shop</span><br><span class="line">ORDER BY address</span><br><span class="line">LIMIT 12;</span><br></pre></td></tr></table></figure>
<p>因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式 <code>无法支持使用索引排序</code> ，只能使用文件排序。</p>
<p><strong>拓展：Alibaba《Java开发手册》</strong></p>
<p>【 <code>强制</code>】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本 区分度决定索引长度。 </p>
<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会<code>高达 90% 以上</code> ，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p>
<h4 id="9-区分度高-散列性高-的列适合作为索引"><a href="#9-区分度高-散列性高-的列适合作为索引" class="headerlink" title="9. 区分度高(散列性高)的列适合作为索引"></a>9. 区分度高(散列性高)的列适合作为索引</h4><p><code>列的基数</code> 指的是某一列中不重复数据的个数，比方说某个列包含值 <code>2, 5, 8, 2, 5, 8, 2, 5, 8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。</strong>这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列简历索引，为基数太小的列的简历索引效果可能不好。</p>
<p>可以使用公式<code>select count(distinct a) / count(*) from t1</code> 计算区分度，越接近1越好，一般超过33%就算比较高效的索引了。</p>
<p>扩展：联合索引把区分度搞(散列性高)的列放在前面。</p>
<h4 id="10-使用最频繁的列放到联合索引的左侧"><a href="#10-使用最频繁的列放到联合索引的左侧" class="headerlink" title="10. 使用最频繁的列放到联合索引的左侧"></a>10. 使用最频繁的列放到联合索引的左侧</h4><p>这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。</p>
<h4 id="11-在多个字段都要创建索引的情况下，联合索引优于单值索引"><a href="#11-在多个字段都要创建索引的情况下，联合索引优于单值索引" class="headerlink" title="11. 在多个字段都要创建索引的情况下，联合索引优于单值索引"></a>11. 在多个字段都要创建索引的情况下，联合索引优于单值索引</h4><h3 id="3-3-限制索引的数目"><a href="#3-3-限制索引的数目" class="headerlink" title="3.3 限制索引的数目"></a>3.3 限制索引的数目</h3><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<code>不超过6个</code>。原因:</p>
<ul>
<li>每个索引都需要占用<code>磁盘空间</code>，索引越多，需要的磁盘空间就越大。</li>
<li>索引会影响<code>INSERT、DELETE、UPDATE等语句的性能</code>，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li>
<li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的<code>索引来进行评估</code>，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MysQL优化器生成执行计划时间，降低查询性能。</li>
</ul>
<h3 id="3-4-哪些情况不适合创建索引"><a href="#3-4-哪些情况不适合创建索引" class="headerlink" title="3.4 哪些情况不适合创建索引"></a>3.4 哪些情况不适合创建索引</h3><h4 id="1-在where中使用不到的字段，不要设置索引"><a href="#1-在where中使用不到的字段，不要设置索引" class="headerlink" title="1. 在where中使用不到的字段，不要设置索引"></a>1. 在where中使用不到的字段，不要设置索引</h4><p>WHERE条件 (包括 GROUP BY、ORDER BY) 里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT course_id, student_id, create_time</span><br><span class="line">FROM student_info</span><br><span class="line">WHERE student_id = 41251;</span><br></pre></td></tr></table></figure>
<p>因为我们是按照 student_id 来进行检索的，所以不需要对其他字段创建索引，即使这些字段出现在SELECT字段中。</p>
<h4 id="2-数据量小的表最好不要使用索引"><a href="#2-数据量小的表最好不要使用索引" class="headerlink" title="2. 数据量小的表最好不要使用索引"></a>2. 数据量小的表最好不要使用索引</h4><p>如果表记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，是否创建索引 <code>对查询效率的影响并不大</code>。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</p>
<p>举例：创建表1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_without_index(</span><br><span class="line">a INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">b INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>提供存储过程1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE t_wout_insert()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 1;</span><br><span class="line">    WHILE i &lt;= 900</span><br><span class="line">    DO</span><br><span class="line">        INSERT INTO t_without_index(b) SELECT RAND()*10000;</span><br><span class="line">        SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL t_wout_insert()</span><br></pre></td></tr></table></figure>
<p>创建表2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_with_index(</span><br><span class="line">a INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">b INT,</span><br><span class="line">INDEX idx_b(b)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>创建存储过程2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE t_with_insert()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 1;</span><br><span class="line">    WHILE i &lt;= 900</span><br><span class="line">    DO</span><br><span class="line">        INSERT INTO t_with_index(b) SELECT RAND()*10000;</span><br><span class="line">        SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL t_with_insert();</span><br></pre></td></tr></table></figure>
<p>查询对比：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t_without_index where b = 9879;</span><br><span class="line">+------+------+</span><br><span class="line">| a | b |</span><br><span class="line">+------+------+</span><br><span class="line">| 1242 | 9879 |</span><br><span class="line">+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_with_index where b = 9879;</span><br><span class="line">+-----+------+</span><br><span class="line">| a | b |</span><br><span class="line">+-----+------+</span><br><span class="line">| 112 | 9879 |</span><br><span class="line">+-----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>你能看到运行结果相同，但是在数据量不大的情况下，索引就发挥不出作用了。</p>
<blockquote>
<p>结论：在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。</p>
</blockquote>
<h4 id="3-有大量重复数据的列上不要建立索引"><a href="#3-有大量重复数据的列上不要建立索引" class="headerlink" title="3. 有大量重复数据的列上不要建立索引"></a>3. 有大量重复数据的列上不要建立索引</h4><p>在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的<code>性别</code>字段上只有“男”与“女”两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会<code>严重降低数据更新速度</code>。</p>
<p>举例1：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先 访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p>
<p>举例2：假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。</p>
<p>学生表 student_gender 结构如下。其中数据表中的 student_gender 字段取值为 0 或 1，0 代表女性，1 代表男性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student_gender(</span><br><span class="line">    student_id INT(11) NOT NULL,</span><br><span class="line">    student_name VARCHAR(50) NOT NULL,</span><br><span class="line">    student_gender TINYINT(1) NOT NULL,</span><br><span class="line">    PRIMARY KEY(student_id)</span><br><span class="line">)ENGINE = INNODB;</span><br></pre></td></tr></table></figure>
<p>如果我们要筛选出这个学生表中的男性，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student_gender WHERE student_gender = 1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。</p>
</blockquote>
<h4 id="4-避免对经常更新的表创建过多的索引"><a href="#4-避免对经常更新的表创建过多的索引" class="headerlink" title="4.  避免对经常更新的表创建过多的索引"></a>4.  避免对经常更新的表创建过多的索引</h4><p>第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。</p>
<p>第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却降低更新表的速度。</p>
<h4 id="5-不建议用无序的值作为索引"><a href="#5-不建议用无序的值作为索引" class="headerlink" title="5. 不建议用无序的值作为索引"></a>5. 不建议用无序的值作为索引</h4><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p>
<h4 id="6-删除不再使用或者很少使用的索引"><a href="#6-删除不再使用或者很少使用的索引" class="headerlink" title="6. 删除不再使用或者很少使用的索引"></a>6. 删除不再使用或者很少使用的索引</h4><p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p>
<h4 id="7-不要定义夯余或重复的索引"><a href="#7-不要定义夯余或重复的索引" class="headerlink" title="7. 不要定义夯余或重复的索引"></a>7. 不要定义夯余或重复的索引</h4><p>① 冗余索引 </p>
<p>举例：建表语句如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">    id INT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    phone_number CHAR(11) NOT NULL,</span><br><span class="line">    country varchar(100) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),</span><br><span class="line">    KEY idx_name (name(10))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name 列进行快速搜索，再创建一 个专门针对 name 列的索引就算是一个冗余索引 ，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p>
<p>② 重复索引 </p>
<p>另一种情况，我们可能会对某个列 重复建立索引 ，比方说这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE repeat_index_demo (</span><br><span class="line">col1 INT PRIMARY KEY,</span><br><span class="line">col2 INT,</span><br><span class="line">UNIQUE uk_idx_c1 (col1),</span><br><span class="line">INDEX idx_c1 (col1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p>
<h1 id="第09章-性能分析工具的使用"><a href="#第09章-性能分析工具的使用" class="headerlink" title="第09章_性能分析工具的使用"></a>第09章_性能分析工具的使用</h1><p>在数据库调优中，我们的目标是 <code>响应时间更快, 吞吐量更大</code> 。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p>
<h2 id="1-数据库服务器的优化步骤"><a href="#1-数据库服务器的优化步骤" class="headerlink" title="1. 数据库服务器的优化步骤"></a>1. 数据库服务器的优化步骤</h2><p>当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。</p>
<p>整个流程划分成了 <code>观察（Show status）</code> 和 <code>行动（Action）</code> 两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220627162248635.png" alt="image-20220627162248635"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220627162345815.png" alt="image-20220627162345815"></p>
<p>我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。</p>
<p><strong>详细解释一下这张图：</strong></p>
<p>首先在S1部分，我们需要观察服务器的状态是否存在周期性的波动。如果<code>存在周期性波动</code>，有可能是周期性节点的原因，比如双十一、促销活动等。这样的话，我们可以通过A1这一步骤解决，也就是加缓存，或者更改缓存失效策略。</p>
<p>如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步<code>分析查询延迟和卡顿的原因</code>。接下来进入S2这一步，我们需要开启慢查询。慢查询可以帮我们定位执行慢的SQL语句我们可以通过设置long_query_time参数定义“慢”的阈值，如果SQL执行时间超过了<code>long_query_time</code>，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。</p>
<p>在S3这一步骤中，我们就知道了执行慢的SQL，这样就可以针对性地用<code>EXPLAIN</code>查看对应SQL语句的执行计划，或者使用<code>show profile</code>查看SQL中每一个步骤的时间成本。这样我们就可以了解SQL查询慢是因为执行时间长，还是等待时间长。</p>
<p>如果是sQL等待时间长，我们进入A2步骤。在这一步骤中，我们可以<code>调优服务器的参数</code>，比如适当增加数据库缓冲池等。如果是SQL执行时间长，就进入A3步骤，这一步中我们需要考虑是索引设计的问题?还是查询关联的数据表过多?还是因为数据表的字段设计问题导致了这一现象。然后在这些维度上进行对应的调整。</p>
<p>如果A2和A3都不能解决问题，我们需要考虑数据库自身的sQL查询性能是否已经达到了瓶颈，如果确认没有达到<code>性能瓶颈</code>，就需要重新检查，重复以上的步骤。如果已经达到了性能瓶颈进入A4阶段，需要考虑<code>增加服务器</code>，采用<code>读写分离</code>的架构，或者考虑对数据库进行<code>分库分表</code>，比如垂直分库、垂直分表和水平分表等。</p>
<p>以上就是数据库调优的流程思路。如果我们发现执行SQL时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的SQL，这三种分析工具你可以理解是SQL调优的三个步骤:<code>慢查询</code>、<code>EXPLAIN</code>和<code>SHOW PROFILING</code>。</p>
<p><strong>小结：</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220627164114562.png" alt="image-20220627164114562" style="float:center;"></p>
<h2 id="2-查看系统性能参数"><a href="#2-查看系统性能参数" class="headerlink" title="2. 查看系统性能参数"></a>2. 查看系统性能参数</h2><p>在MySQL中，可以使用 <code>SHOW STATUS</code> 语句查询一些MySQL数据库服务器的<code>性能参数、执行频率</code>。</p>
<p>SHOW STATUS语句语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] STATUS LIKE &#x27;参数&#x27;;</span><br></pre></td></tr></table></figure>
<p>一些常用的性能参数如下：</p>
<ul>
<li>Connections：连接MySQL服务器的次数。 </li>
<li>Uptime：MySQL服务器的上线时间。 </li>
<li>Slow_queries：慢查询的次数。 </li>
<li>Innodb_rows_read：Select查询返回的行数 </li>
<li>Innodb_rows_inserted：执行INSERT操作插入的行数 </li>
<li>Innodb_rows_updated：执行UPDATE操作更新的 行数 </li>
<li>Innodb_rows_deleted：执行DELETE操作删除的行数 </li>
<li>Com_select：查询操作的次数。 </li>
<li>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。 </li>
<li>Com_update：更新操作 的次数。 </li>
<li>Com_delete：删除操作的次数。</li>
</ul>
<p>若查询MySQL服务器的连接次数，则可以执行如下语句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Connections&#x27;;</span><br></pre></td></tr></table></figure>
<p>若查询服务器工作时间，则可以执行如下语句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Uptime&#x27;;</span><br></pre></td></tr></table></figure>
<p>若查询MySQL服务器的慢查询次数，则可以执行如下语句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Slow_queries&#x27;;</span><br></pre></td></tr></table></figure>
<p>慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行<code>表结构优化</code>或者<code>查询语句优化</code>。</p>
<p>再比如，如下的指令可以查看相关的指令情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Innodb_rows_%&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="3-统计SQL的查询成本-last-query-cost"><a href="#3-统计SQL的查询成本-last-query-cost" class="headerlink" title="3. 统计SQL的查询成本: last_query_cost"></a>3. 统计SQL的查询成本: last_query_cost</h2><p>一条SQL查询语句在执行前需要查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择<code>成本最小</code>的一个作为最终执行的执行计划。</p>
<p>如果我们想要查看某条SQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的<code>last_query_cost</code>变量值来得到当前查询的成本。它通常也是我们<code>评价一个查询的执行效率</code>的一个常用指标。这个查询成本对应的是<code>SQL 语句所需要读取的读页的数量</code>。</p>
<p>我们依然使用第8章的 student_info 表为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `student_info` (</span><br><span class="line">    `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `student_id` INT NOT NULL ,</span><br><span class="line">    `name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">    `course_id` INT NOT NULL ,</span><br><span class="line">    `class_id` INT(11) DEFAULT NULL,</span><br><span class="line">    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p>如果我们想要查询 id=900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT student_id, class_id, NAME, create_time FROM student_info WHERE id = 900001;</span><br></pre></td></tr></table></figure>
<p>运行结果（1 条记录，运行时间为 0.042s ）</p>
<p>然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#x27;last_query_cost&#x27;;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   |   Value  |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Last_query_cost | 1.000000 |</span><br><span class="line">+-----------------+----------+</span><br></pre></td></tr></table></figure>
<p>如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT student_id, class_id, NAME, create_time FROM student_info WHERE id BETWEEN 900001 AND 900100;</span><br></pre></td></tr></table></figure>
<p>运行结果（100 条记录，运行时间为 0.046s ）： </p>
<p>然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#x27;last_query_cost&#x27;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   |   Value   |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Last_query_cost | 21.134453 |</span><br><span class="line">+-----------------+-----------+</span><br></pre></td></tr></table></figure>
<p>你能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间 基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然 页 数量（last_query_cost）增加了不少 ，但是通过缓冲池的机制，并 没有增加多少查询时间 。 </p>
<p><strong>使用场景：</strong>它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p>
<blockquote>
<p>SQL查询时一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p>
<ol>
<li><code>位置决定效率</code>。如果页就在数据库 <code>缓冲池</code> 中，那么效率是最高的，否则还需要从 <code>内存</code> 或者 <code>磁盘</code> 中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li>
<li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的(差不多10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li>
</ol>
<p>所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是进程使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p>
</blockquote>
<h2 id="4-定位执行慢的-SQL：慢查询日志"><a href="#4-定位执行慢的-SQL：慢查询日志" class="headerlink" title="4. 定位执行慢的 SQL：慢查询日志"></a>4. 定位执行慢的 SQL：慢查询日志</h2><p>MysQL的慢查询日志，用来记录在MySQL中<code>响应时间超过阀值</code>的语句，具体指运行时间超过<code>long_query_time</code>值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为<code>10</code>，意思是运行10秒以上(不含10秒)的语句，认为是超出了我们的最大忍耐时间值。</p>
<p>它的主要作用是，帮助我们发现那些执行时间特别长的SQL查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条sql执行超过5秒钟，我们就算慢QL，希望能收集超过5秒的sql，结合explain进行全面分析。</p>
<p>默认情况下，MySQL数据库<code>没有开启慢查询日志</code>，需要我们手动来设置这个参数。<strong>如果不是调优需要的话，一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。</p>
<p>慢查询日志支持将日志记录写入文件。</p>
<h3 id="4-1-开启慢查询日志参数"><a href="#4-1-开启慢查询日志参数" class="headerlink" title="4.1 开启慢查询日志参数"></a>4.1 开启慢查询日志参数</h3><p><strong>1. 开启 slow_query_log</strong></p>
<p>在使用前，我们需要先查下慢查询是否已经开启，使用下面这条命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; show variables like &#x27;%slow_query_log&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628173525966.png" alt="image-20220628173525966" style="float:left;"></p>
<p>我们可以看到 <code>slow_query_log=OFF</code>，我们可以把慢查询日志打开，注意设置变量值的时候需要使用 global，否则会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; set global slow_query_log=&#x27;ON&#x27;;</span><br></pre></td></tr></table></figure>
<p>然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628175226812.png" alt="image-20220628175226812" style="float:left;"></p>
<p>你能看到这时慢查询分析已经开启，同时文件保存在 <code>/var/lib/mysql/atguigu02-slow.log</code> 文件 中。</p>
<p><strong>2. 修改 long_query_time 阈值</strong></p>
<p>接下来我们来看下慢查询的时间阈值设置，使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628175353233.png" alt="image-20220628175353233" style="float:left;"></p>
<p>这里如果我们想把时间缩短，比如设置为 1 秒，可以这样设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并</span><br><span class="line">执行下述语句</span><br><span class="line">mysql &gt; set global long_query_time = 1;</span><br><span class="line">mysql&gt; show global variables like &#x27;%long_query_time%&#x27;;</span><br><span class="line"></span><br><span class="line">mysql&gt; set long_query_time=1;</span><br><span class="line">mysql&gt; show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628175425922.png" alt="image-20220628175425922" style="zoom:80%; float:left;"></p>
<p><strong>补充：配置文件中一并设置参数</strong></p>
<p>如下的方式相较于前面的命令行方式，可以看做是永久设置的方式。</p>
<p>修改 <code>my.cnf</code> 文件，[mysqld] 下增加或修改参数 <code>long_query_time、slow_query_log</code> 和 <code>slow_query_log_file</code> 后，然后重启 MySQL 服务器。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">ON  # 开启慢查询日志开关</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=<span class="string">/var/lib/mysql/atguigu-low.log  # 慢查询日志的目录和文件名信息</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">3  # 设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志</span></span><br><span class="line"><span class="attr">log_output</span>=<span class="string">FILE</span></span><br></pre></td></tr></table></figure>
<p>如果不指定存储路径，慢查询日志默认存储到MySQL数据库的数据文件夹下。如果不指定文件名，默认文件名为hostname_slow.log。</p>
<h3 id="4-2-查看慢查询数目"><a href="#4-2-查看慢查询数目" class="headerlink" title="4.2 查看慢查询数目"></a>4.2 查看慢查询数目</h3><p>查询当前系统中有多少条慢查询记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;%Slow_queries%&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-案例演示"><a href="#4-3-案例演示" class="headerlink" title="4.3 案例演示"></a>4.3 案例演示</h3><p><strong>步骤1. 建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">    `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `stuno` INT NOT NULL ,</span><br><span class="line">    `name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">    `age` INT(3) DEFAULT NULL,</span><br><span class="line">    `classId` INT(11) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p><strong>步骤2：设置参数 log_bin_trust_function_creators</strong></p>
<p>创建函数，假如报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This function has none of DETERMINISTIC......</span><br></pre></td></tr></table></figure>
<ul>
<li>命令开启：允许创建函数设置：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure>
<p><strong>步骤3：创建函数</strong></p>
<p>随机产生字符串：（同上一章）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_string(n INT)</span><br><span class="line">	RETURNS VARCHAR(255) #该函数会返回一个字符串</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">	DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">    	SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">    	SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    RETURN return_str;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">SELECT rand_string(10);</span><br></pre></td></tr></table></figure>
<p>产生随机数值：（同上一章）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;</span><br><span class="line">    RETURN i;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#测试：</span><br><span class="line">SELECT rand_num(10,100);</span><br></pre></td></tr></table></figure>
<p><strong>步骤4：创建存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_stu1( START INT , max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0; #设置手动提交事务</span><br><span class="line">    REPEAT #循环</span><br><span class="line">    SET i = i + 1; #赋值</span><br><span class="line">    INSERT INTO student (stuno, NAME ,age ,classId ) VALUES</span><br><span class="line">    ((START+i),rand_string(6),rand_num(10,100),rand_num(10,1000));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT; #提交事务</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p><strong>步骤5：调用存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#调用刚刚写好的函数, 4000000条记录,从100001号开始</span><br><span class="line"></span><br><span class="line">CALL insert_stu1(100001,4000000);</span><br></pre></td></tr></table></figure>
<h3 id="4-4-测试及分析"><a href="#4-4-测试及分析" class="headerlink" title="4.4 测试及分析"></a>4.4 测试及分析</h3><p><strong>1. 测试</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM student WHERE stuno = 3455655;</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">|   id    |  stuno  |  name  | age  | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 3523633 | 3455655 | oQmLUr |  19  |    39   |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">1 row in set (2.09 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM student WHERE name = &#x27;oQmLUr&#x27;;</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">|   id    |  stuno  |  name  |  age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 1154002 | 1243200 | OQMlUR | 266  |   28    |</span><br><span class="line">| 1405708 | 1437740 | OQMlUR | 245  |   439   |</span><br><span class="line">| 1748070 | 1680092 | OQMlUR | 240  |   414   |</span><br><span class="line">| 2119892 | 2051914 | oQmLUr | 17   |   32    |</span><br><span class="line">| 2893154 | 2825176 | OQMlUR | 245  |   435   |</span><br><span class="line">| 3523633 | 3455655 | oQmLUr | 19   |   39    |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">6 rows in set (2.39 sec)</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看出来，查询学生编号为“3455655”的学生信息花费时间为2.09秒。查询学生姓名为 “oQmLUr”的学生信息花费时间为2.39秒。已经达到了秒的数量级，说明目前查询效率是比较低的，下面 的小节我们分析一下原因。</p>
<p><strong>2. 分析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show status like &#x27;slow_queries&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628195650079.png" alt="image-20220628195650079" style="float:left;"></p>
<h3 id="4-5-慢查询日志分析工具：mysqldumpslow"><a href="#4-5-慢查询日志分析工具：mysqldumpslow" class="headerlink" title="4.5 慢查询日志分析工具：mysqldumpslow"></a>4.5 慢查询日志分析工具：mysqldumpslow</h3><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具 <code>mysqldumpslow</code> 。</p>
<p>查看mysqldumpslow的帮助信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">--help</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628195821440.png" alt="image-20220628195821440" style="float:left;"></p>
<p>mysqldumpslow 命令的具体参数如下：</p>
<ul>
<li>-a: 不将数字抽象成N，字符串抽象成S</li>
<li>-s: 是表示按照何种方式排序：<ul>
<li>c: 访问次数 </li>
<li>l: 锁定时间 </li>
<li>r: 返回记录 </li>
<li>t: 查询时间 </li>
<li>al:平均锁定时间 </li>
<li>ar:平均返回记录数 </li>
<li>at:平均查询时间 （默认方式） </li>
<li>ac:平均查询次数</li>
</ul>
</li>
<li>-t: 即为返回前面多少条的数据；</li>
<li>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</li>
</ul>
<p>举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s t -t 5 /var/lib/mysql/atguigu01-slow.log</span></span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[root@bogon</span> <span class="string">~]# mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Reading</span> <span class="string">mysql slow query log from /var/lib/mysql/atguigu01-slow.log</span></span><br><span class="line"><span class="attr">Count</span>: <span class="string">1 Time=2.39s (2s) Lock=0.00s (0s) Rows=13.0 (13), root[root]@localhost</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM student WHERE name = &#x27;S&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Count</span>: <span class="string">1 Time=2.09s (2s) Lock=0.00s (0s) Rows=2.0 (2), root[root]@localhost</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM student WHERE stuno = N</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Died</span> <span class="string">at /usr/bin/mysqldumpslow line 162, &lt;&gt; chunk 2.</span></span><br></pre></td></tr></table></figure>
<p><strong>工作常用参考：</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#得到返回记录集最多的10个SQL</span></span><br><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s r -t 10 /var/lib/mysql/atguigu-slow.log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#得到访问次数最多的10个SQL</span></span><br><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s c -t 10 /var/lib/mysql/atguigu-slow.log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span></span><br></pre></td></tr></table></figure>
<h3 id="4-6-关闭慢查询日志"><a href="#4-6-关闭慢查询日志" class="headerlink" title="4.6 关闭慢查询日志"></a>4.6 关闭慢查询日志</h3><p>MySQL服务器停止慢查询日志功能有两种方法：</p>
<p><strong>方式1：永久性方式</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">OFF</span></span><br></pre></td></tr></table></figure>
<p>或者，把slow_query_log一项注释掉 或 删除</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#slow_query_log =OFF</span></span><br></pre></td></tr></table></figure>
<p>重启MySQL服务，执行如下语句查询慢日志功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%slow%&#x27;; #查询慢查询日志所在目录</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27;; #查询超时时长</span><br></pre></td></tr></table></figure>
<p><strong>方式2：临时性方式</strong></p>
<p>使用SET语句来设置。 </p>
<p>（1）停止MySQL慢查询日志功能，具体SQL语句如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL slow_query_log=off;</span><br></pre></td></tr></table></figure>
<p>（2）<strong>重启MySQL服务</strong>，使用SHOW语句查询慢查询日志功能信息，具体SQL语句如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%slow%&#x27;;</span><br><span class="line">#以及</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="4-7-删除慢查询日志"><a href="#4-7-删除慢查询日志" class="headerlink" title="4.7 删除慢查询日志"></a>4.7 删除慢查询日志</h3><p>使用SHOW语句显示慢查询日志信息，具体SQL语句如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE `slow_query_log%`;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628203545536.png" alt="image-20220628203545536" style="float:left;"></p>
<p>从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下 <code>手动删除慢查询日志文件</code> 即可。</p>
<p>使用命令 <code>mysqladmin flush-logs</code> 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mysqladmin</span> <span class="string">-uroot -p flush-logs slow</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示</p>
<p>慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p>
</blockquote>
<h2 id="5-查看-SQL-执行成本：SHOW-PROFILE"><a href="#5-查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="5. 查看 SQL 执行成本：SHOW PROFILE"></a>5. 查看 SQL 执行成本：SHOW PROFILE</h2><p>show profile 在《逻辑架构》章节中讲过，这里作为复习。</p>
<p>show profile 是 MySQL 提供的可以用来分析当前会话中 SQL 都做了什么、执行的资源消耗工具的情况，可用于 sql 调优的测量。<code>默认情况下处于关闭状态</code>，并保存最近15次的运行结果。</p>
<p>我们可以在会话级别开启这个功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; show variables like &#x27;profiling&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628204922556.png" alt="image-20220628204922556" style="float:left;"></p>
<p>通过设置 profiling=’ON’ 来开启 show profile:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; set profiling = &#x27;ON&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628205029208.png" alt="image-20220628205029208" style="zoom:80%;float:left"></p>
<p>然后执行相关的查询语句。接着看下当前会话都有哪些 profiles，使用下面这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; show profiles;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628205243769.png" alt="image-20220628205243769" style="zoom:80%;float:left"></p>
<p>你能看到当前会话一共有 2 个查询。如果我们想要查看最近一次查询的开销，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; show profile;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628205317257.png" alt="image-20220628205317257" style="float:left;"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 2</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628205354230.png" alt="image-20220628205354230" style="float:left;"></p>
<p><strong>show profile的常用查询参数： </strong></p>
<p>① ALL：显示所有的开销信息。 </p>
<p>② BLOCK IO：显示块IO开销。 </p>
<p>③ CONTEXT SWITCHES：上下文切换开销。 </p>
<p>④ CPU：显示CPU开销信息。 </p>
<p>⑤ IPC：显示发送和接收开销信息。</p>
<p>⑥ MEMORY：显示内存开销信 息。 </p>
<p>⑦ PAGE FAULTS：显示页面错误开销信息。 </p>
<p>⑧ SOURCE：显示和Source_function，Source_file， Source_line相关的开销信息。 </p>
<p>⑨ SWAPS：显示交换次数开销信息。</p>
<p><strong>日常开发需注意的结论：</strong></p>
<p>① <code>converting HEAP to MyISAM</code>: 查询结果太大，内存不够，数据往磁盘上搬了。 </p>
<p>② <code>Creating tmp table</code>：创建临时表。先拷贝数据到临时表，用完后再删除临时表。 </p>
<p>③ <code>Copying to tmp table on disk</code>：把内存中临时表复制到磁盘上，警惕！ </p>
<p>④ <code>locked</code>。 </p>
<p>如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。</p>
<p><strong>注意：</strong></p>
<p>不过SHOW PROFILE命令将被启用，我们可以从 information_schema 中的 profiling 数据表进行查看。</p>
<h2 id="6-分析查询语句：EXPLAIN"><a href="#6-分析查询语句：EXPLAIN" class="headerlink" title="6. 分析查询语句：EXPLAIN"></a>6. 分析查询语句：EXPLAIN</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><strong>定位了查询慢的sQL之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。</strong>DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。</p>
<p>MySQL中有专门负责优化SELECT语句的优化器模块，主要功能:通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的<code>执行计划</code>（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)。</p>
<p>这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了<code>EXPLAIN</code>语句来帮助我们查看某个查询语句的具体执行计划，大家看懂<code>EXPLAIN</code>语句的各个输出项，可以有针对性的提升我们查询语句的性能。</p>
<p><strong>1. 能做什么？</strong></p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li><strong>哪些索引被实际使用</strong></li>
<li>表之间的引用</li>
<li><strong>每张表有多少行被优化器查询</strong></li>
</ul>
<p><strong>2. 官网介绍</strong></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a> </p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">https://dev.mysql.com/doc/refman/8.0/en/explain-output.html</a></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628211207436.png" alt="image-20220628211207436"></p>
<p><strong>3. 版本情况</strong></p>
<ul>
<li>MySQL 5.6.3以前只能 EXPLAIN SELECT ；MYSQL 5.6.3以后就可以 EXPLAIN SELECT，UPDATE， DELETE </li>
<li>在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示 filtered 需要使用 explain extended 命令。在5.7版本后，默认explain直接显示partitions和 filtered中的信息。</li>
</ul>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628211351678.png" alt="image-20220628211351678" style="float:left;"></p>
<h3 id="6-2-基本语法"><a href="#6-2-基本语法" class="headerlink" title="6.2 基本语法"></a>6.2 基本语法</h3><p>EXPLAIN 或 DESCRIBE语句的语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT select_options</span><br><span class="line">或者</span><br><span class="line">DESCRIBE SELECT select_options</span><br></pre></td></tr></table></figure>
<p>如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628212029574.png" alt="image-20220628212029574" style="float:left;"></p>
<p>输出的上述信息就是所谓的<code>执行计划</code>。在这个执行计划的辅助下，我们需要知道应该怎样改进自己的查询语句以使查询执行起来更高效。其实除了以<code>SELECT</code>开头的查询语句，其余的<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code>以及<code>UPDATE</code>语句等都可以加上<code>EXPLAIN</code>，用来查看这些语句的执行计划，只是平时我们对<code>SELECT</code>语句更感兴趣。</p>
<p>注意:执行EXPLAIN时并没有真正的执行该后面的语句，因此可以安全的查看执行计划。</p>
<p>EXPLAIN 语句输出的各个列的作用如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td>在一个大的查询语句中每个SELECT关键字都对应一个<code>唯一的id</code></td>
</tr>
<tr>
<td><code>select_type</code></td>
<td>SELECT关键字对应的那个查询的类型</td>
</tr>
<tr>
<td><code>table</code></td>
<td>表名</td>
</tr>
<tr>
<td><code>partitions</code></td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td><code>type</code></td>
<td>针对单表的访问方法</td>
</tr>
<tr>
<td><code>possible_keys</code></td>
<td>可能用到的索引</td>
</tr>
<tr>
<td><code>key</code></td>
<td>实际上使用的索引</td>
</tr>
<tr>
<td><code>key_len</code></td>
<td>实际使用到的索引长度</td>
</tr>
<tr>
<td><code>ref</code></td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td><code>rows</code></td>
<td>预估的需要读取的记录条数</td>
</tr>
<tr>
<td><code>filtered</code></td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td><code>Extra</code></td>
<td>一些额外的信息</td>
</tr>
</tbody>
</table>
</div>
<p>在这里把它们都列出来知识为了描述一个轮廓，让大家有一个大致的印象。</p>
<h3 id="6-3-数据准备"><a href="#6-3-数据准备" class="headerlink" title="6.3 数据准备"></a>6.3 数据准备</h3><p><strong>1. 建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE s1 (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE s2 (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p><strong>2. 设置参数 log_bin_trust_function_creators</strong></p>
<p>创建函数，假如报错，需开启如下命令：允许创建函数设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure>
<p><strong>3. 创建函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_string1(n INT)</span><br><span class="line">	RETURNS VARCHAR(255) #该函数会返回一个字符串</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">    DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">        SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">        SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    RETURN return_str;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p><strong>4. 创建存储过程</strong></p>
<p>创建往s1表中插入数据的存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_s1 (IN min_num INT (10),IN max_num INT (10))</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0;</span><br><span class="line">    REPEAT</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    INSERT INTO s1 VALUES(</span><br><span class="line">        (min_num + i),</span><br><span class="line">        rand_string1(6),</span><br><span class="line">        (min_num + 30 * i + 5),</span><br><span class="line">        rand_string1(6),</span><br><span class="line">        rand_string1(10),</span><br><span class="line">        rand_string1(5),</span><br><span class="line">        rand_string1(10),</span><br><span class="line">        rand_string1(10));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>创建往s2表中插入数据的存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_s2 (IN min_num INT (10),IN max_num INT (10))</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0;</span><br><span class="line">    REPEAT</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    INSERT INTO s2 VALUES(</span><br><span class="line">        (min_num + i),</span><br><span class="line">        rand_string1(6),</span><br><span class="line">        (min_num + 30 * i + 5),</span><br><span class="line">        rand_string1(6),</span><br><span class="line">        rand_string1(10),</span><br><span class="line">        rand_string1(5),</span><br><span class="line">        rand_string1(10),</span><br><span class="line">        rand_string1(10));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p><strong>5. 调用存储过程</strong></p>
<p>s1表数据的添加：加入1万条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL insert_s1(10001,10000);</span><br></pre></td></tr></table></figure>
<p>s2表数据的添加：加入1万条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL insert_s2(10001,10000);</span><br></pre></td></tr></table></figure>
<h3 id="6-4-EXPLAIN各列作用"><a href="#6-4-EXPLAIN各列作用" class="headerlink" title="6.4 EXPLAIN各列作用"></a>6.4 EXPLAIN各列作用</h3><p>为了让大家有比较好的体验，我们调整了下 <code>EXPLAIN</code> 输出列的顺序。</p>
<h4 id="1-table"><a href="#1-table" class="headerlink" title="1. table"></a>1. table</h4><p>不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所 以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该 表的表名（有时不是真实的表名字，可能是简称）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; EXPLAIN SELECT * FROM s1;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628221143339.png" alt="image-20220628221143339"></p>
<p>这个查询语句只涉及对s1表的单表查询，所以 <code>EXPLAIN</code> 输出中只有一条记录，其中的table列的值为s1，表明这条记录是用来说明对s1表的单表访问方法的。</p>
<p>下边我们看一个连接查询的执行计划</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628221414097.png" alt="image-20220628221414097"></p>
<p>可以看出这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。</p>
<h4 id="2-id"><a href="#2-id" class="headerlink" title="2. id"></a>2. id</h4><p>我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比 如下边这个查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p>稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM s1 INNER JOIN s2</span><br><span class="line">ON s1.key1 = s2.key1</span><br><span class="line">WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p>但是下边两种情况下在一条查询语句中会出现多个SELECT关键字：</p>
<ul>
<li><p><strong>查询中包含子查询的情况</strong></p>
<p>比如下边这个查询语句中就包含2个<code>SELECT</code>关键字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM s1</span><br><span class="line">WHERE key1 IN ( SELECT key3 FROM s2。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询中包含<code>UNION</code>语句的情况</strong></p>
<p>比如下边这个查询语句中也包含2个<code>SELECT</code>关键字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure>
<p><strong>查询语句中每出现一个<code>SELECT</code>关键字，MySQL就会为它分配一个唯一的<code>id</code>值。</strong>这个<code>id</code>值就是<code>EXPLAIN</code>语句的第一个列，比如下边这个查询中只有一个<code>SELECT</code>关键字，所以<code>EXPLAIN</code>的结果中也就只有一条<code>id</code>列为<code>1</code>的记录:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628222055716.png" alt="image-20220628222055716"></p>
<p>对于连接查询来说，一个SELECT关键字后边的FROM字句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220628222251309.png" alt="image-20220628222251309"></p>
<p>可以看到，上述连接查询中参与连接的s1和s2表分别对应一条记录，但是这两条记录对应的<code>id</code>都是1。这里需要大家记住的是，<strong>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的</strong>，出现在前边的表表示<code>驱动表</code>，出现在后面的表表示<code>被驱动表</code>。所以从上边的EXPLAIN输出中我们可以看到，查询优化器准备让s1表作为驱动表，让s2表作为被驱动表来执行查询。</p>
<p>对于包含子查询的查询语句来说，就可能涉及多个<code>SELECT</code>关键字，所以在**包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的id值，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629165122837.png" alt="image-20220629165122837"></p>
<p>从输出结果中我们可以看到; s1表在外层查询中，外层查询有一个独立的<code>SELECT</code>关键字，所以第一条记录的<code>id</code>值就是1，s2表在子查询中，子查询有一个<code>独立的SELECT</code>关键字，所以第二条记录的<code>id</code>值就是<code>2</code>。</p>
<p>但是这里大家需要特别注意，<strong>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询</strong>。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作。  </span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629165603072.png" alt="image-20220629165603072"></p>
<p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的<code>id</code>值全部是1，这就表明<code>查询优化器将子查询转换为了连接查询</code>。</p>
<p>对于包含<code>UNION</code>子句的查询语句来说，每个<code>SELECT</code>关键字对应一个<code>id</code>值也是没错的，不过还是有点儿特别的东西，比方说下边的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Union去重</span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629165909340.png" alt="image-20220629165909340"></p>
<p>这个语句的执行计划的第三条记录是什么?为何<code>id</code>值是<code>NULL</code>，而且table列也很奇怪?<code>UNION</code>!它会把多个查询的结果集合并起来并对结果集中的记录<code>进行去重</code>，怎么去重呢?MySQL使用的是内部的<code>临时表</code>。正如上边的查询计划中所示，UNION子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重，所以在内部创建了一个名为<code>&lt;union1，2&gt;</code>的临时表（就是执行计划第三条记录的table列的名称)，id为<code>NULL</code>表明这个临时表是为了合并两个查询的结果集而创建的。</p>
<p>跟UNION对比起来，<code>UNION ALL</code>就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含<code>UNION ALL</code>子句的查询的执行计划中，就没有那个id为NULL的记录，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629171138065.png" alt="image-20220629171138065"></p>
<p><strong>小结:</strong></p>
<ul>
<li>id如果相同，可以认为是一组，从上往下顺序执行 </li>
<li>在所有组中，id值越大，优先级越高，越先执行 </li>
<li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li>
</ul>
<h4 id="3-select-type"><a href="#3-select-type" class="headerlink" title="3. select_type"></a>3. select_type</h4><p>一条大的查询语句里边可以包含若干个SELECT关键字，<code>每个SELECT关键字代表着一个小的查询语句</code>，而每个SELECT关键字的FROM子句中都可以包含若干张表(这些表用来做连接查询)，<code>每一张表都对应着执行计划输出中的一条记录</code>，对于在同一个SELECT关键字中的表来说，它们的id值是相同的。</p>
<p>MysQL为每一个SELECT关键字代表的小查询都定义了一个称之为<code>select_type</code>的属性，意思是我们只要知道了某个小查询的<code>select_type</code>属性，就知道了这个`小查询在整个大查询中扮演了一个什么角色，我们看一下select_type都能取哪些值，请看官方文档:</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629171442624.png" alt="image-20220629171442624"></p>
<p>具体分析如下：</p>
<ul>
<li><p>SIMPLE</p>
<p>查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型，比方说下边这个单表查询<code>select_type</code>的值就是<code>SIMPLE</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629171840300.png" alt="image-20220629171840300"></p>
<p>​        当然，连接查询也算是 SIMPLE 类型，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629171904912.png" alt="image-20220629171904912"></p>
<ul>
<li><p>PRIMARY</p>
<p>对于包含<code>UNION、UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>的值就是<code>PRIMARY</code>,比方说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629171929924.png" alt="image-20220629171929924"></p>
<p>从结果中可以看到，最左边的小查询<code>SELECT * FROM s1</code>对应的是执行计划中的第一条记录，它的<code>select_type</code>的值就是<code>PRIMARY</code>。</p>
</li>
<li><p>UNION</p>
<p>对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询意外，其余的小查询的<code>select_type</code>值就是UNION，可以对比上一个例子的效果。</p>
</li>
<li><p>UNION RESULT</p>
<p>MySQL 选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>, 例子上边有。</p>
</li>
<li><p>SUBQUERY</p>
<p>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>，比如下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629172449267.png" alt="image-20220629172449267"></p>
</li>
<li><p>DEPENDENT SUBQUERY</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629172525236.png" alt="image-20220629172525236"></p>
</li>
<li><p>DEPENDENT UNION</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = &#x27;a&#x27; UNION SELECT key1 FROM s1 WHERE key1 = &#x27;b&#x27;);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629172555603.png" alt="image-20220629172555603"></p>
</li>
<li><p>DERIVED</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c &gt; 1;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629172622893.png" alt="image-20220629172622893"></p>
<p>从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的select_type是DERIVED, 说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的table列显示的是derived2，表示该查询时针对将派生表物化之后的表进行查询的。</p>
</li>
<li><p>MATERIALIZED</p>
<p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后的外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是DERIVED，比如下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629172646367.png" alt="image-20220629172646367"></p>
</li>
<li><p>UNCACHEABLE SUBQUERY</p>
<p>不常用，就不多说了。</p>
</li>
<li><p>UNCACHEABLE UNION</p>
<p>不常用，就不多说了。</p>
</li>
</ul>
<h4 id="4-partitions-可略"><a href="#4-partitions-可略" class="headerlink" title="4. partitions (可略)"></a>4. partitions (可略)</h4><ul>
<li>代表分区表中的命中情况，非分区表，该项为<code>NULL</code>。一般情况下我们的额查询语句的执行计划的<code>partitions</code>列的值为<code>NULL</code>。</li>
<li><a>https://dev.mysql.com/doc/refman/5.7/en/alter-table-partition-operations.html</a></li>
<li>如果想详细了解，可以如下方式测试。创建分区表：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建分区表，</span><br><span class="line">-- 按照id分区，id&lt;100 p0分区，其他p1分区</span><br><span class="line">CREATE TABLE user_partitions (id INT auto_increment,</span><br><span class="line">NAME VARCHAR(12),PRIMARY KEY(id))</span><br><span class="line">PARTITION BY RANGE(id)(</span><br><span class="line">PARTITION p0 VALUES less than(100),</span><br><span class="line">PARTITION p1 VALUES less than MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629190304966.png" alt="image-20220629190304966" style="float:left;"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC SELECT * FROM user_partitions WHERE id&gt;200;</span><br></pre></td></tr></table></figure>
<p>查询id大于200（200&gt;100，p1分区）的记录，查看执行计划，partitions是p1，符合我们的分区规则</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220629190335371.png" alt="image-20220629190335371" style="float:left;"></p>
<h4 id="5-type-☆"><a href="#5-type-☆" class="headerlink" title="5. type ☆"></a>5. type ☆</h4><p>执行计划的一条记录就代表着MySQL对某个表的 <code>执行查询时的访问方法</code> , 又称“访问类型”，其中的 <code>type</code> 列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到<code>type</code>列的值是<code>ref</code>，表明<code>MySQL</code>即将使用<code>ref</code>访问方法来执行对<code>s1</code>表的查询。</p>
<p>完整的访问方法如下： <code>system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL</code> 。</p>
<p>我们详细解释一下：</p>
<ul>
<li><p><code>system</code></p>
<p>当表中<code>只有一条记录</code>并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是<code>system</code>。比方说我们新建一个<code>MyISAM</code>表，并为其插入一条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(i int) Engine=MyISAM;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO t VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>然后我们看一下查询这个表的执行计划：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220630164434315.png" alt="image-20220630164434315" style="float:left;"></p>
<p>可以看到<code>type</code>列的值就是<code>system</code>了，</p>
<blockquote>
<p>测试，可以把表改成使用InnoDB存储引擎，试试看执行计划的<code>type</code>列是什么。ALL</p>
</blockquote>
</li>
<li><p><code>const</code></p>
<p>当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是<code>const</code>, 比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE id = 10005;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220630164724548.png" alt="image-20220630164724548" style="float:left;"></p>
</li>
<li><p><code>eq_ref</code></p>
<p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较）。则对该被驱动表的访问方法就是<code>eq_ref</code>，比方说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220630164802559.png" alt="image-20220630164802559" style="float:left;"></p>
<p>从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问 方法是 <code>eq_ref</code> ，表明在访问s1表的时候可以 <code>通过主键的等值匹配</code> 来进行访问。</p>
</li>
<li><p><code>ref</code></p>
<p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是<code>ref</code>，比方说下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220630164930020.png" alt="image-20220630164930020" style="float:left;"></p>
</li>
<li><p><code>fulltext</code></p>
<p>全文索引</p>
</li>
<li><p><code>ref_or_null</code></p>
<p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是<code>NULL</code>值时，那么对该表的访问方法就可能是<code>ref_or_null</code>，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key1 IS NULL;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220630175133920.png" alt="image-20220630175133920" style="float:left;"></p>
</li>
<li><p><code>index_merge</code></p>
<p>一般情况下对于某个表的查询只能使用到一个索引，但单表访问方法时在某些场景下可以使用<code>Interseation、union、Sort-Union</code>这三种索引合并的方式来执行查询。我们看一下执行计划中是怎么体现MySQL使用索引合并的方式来对某个表执行查询的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220630175511644.png" alt="image-20220630175511644" style="float:left;"></p>
<p>从执行计划的 <code>type</code> 列的值是 <code>index_merge</code> 就可以看出，MySQL 打算使用索引合并的方式来执行 对 s1 表的查询。</p>
</li>
<li><p><code>unique_subquery</code></p>
<p>类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code>，比如下边的这个查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220630180123913.png" alt="image-20220630180123913" style="float:left;"></p>
</li>
</ul>
<ul>
<li><p><code>index_subquery</code></p>
<p><code>index_subquery</code> 与 <code>unique_subquery</code> 类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220703214407225.png" alt="image-20220703214407225"></p>
<ul>
<li><p><code>range</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220703214633338.png" alt="image-20220703214633338"></p>
<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;a&#x27; AND key1 &lt; &#x27;b&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220703214657251.png" alt="image-20220703214657251"></p>
</li>
<li><p><code>index</code></p>
<p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是<code>index</code>，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220703214844885.png" alt="image-20220703214844885"></p>
<p>上述查询中的所有列表中只有key_part2 一个列，而且搜索条件中也只有 key_part3 一个列，这两个列又恰好包含在idx_key_part这个索引中，可是搜索条件key_part3不能直接使用该索引进行<code>ref</code>和<code>range</code>方式的访问，只能扫描整个<code>idx_key_part</code>索引的记录，所以查询计划的<code>type</code>列的值就是<code>index</code>。</p>
<blockquote>
<p>再一次强调，对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p>
</blockquote>
</li>
<li><p><code>ALL</code></p>
<p>最熟悉的全表扫描，就不多说了，直接看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220703215958374.png" alt="image-20220703215958374"></p>
</li>
</ul>
<p><strong>小结: </strong></p>
<p><strong>结果值从最好到最坏依次是： </strong></p>
<p><strong>system &gt; const &gt; eq_ref &gt; ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p>
<p><strong>其中比较重要的几个提取出来（见上图中的粗体）。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴开发手册要求）</strong></p>
<h4 id="6-possible-keys和key"><a href="#6-possible-keys和key" class="headerlink" title="6. possible_keys和key"></a>6. possible_keys和key</h4><p>在EXPLAIN语句输出的执行计划中，<code>possible_keys</code>列表示在某个查询语句中，对某个列执行<code>单表查询时可能用到的索引</code>有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。<code>key</code>列表示<code>实际用到的索引</code>有哪些，如果为NULL，则没有使用索引。比方说下面这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220703220724964.png" alt="image-20220703220724964"></p>
<p>上述执行计划的<code>possible_keys</code>列的值是<code>idx_key1, idx_key3</code>，表示该查询可能使用到<code>idx_key1, idx_key3</code>两个索引，然后<code>key</code>列的值是<code>idx_key3</code>，表示经过查询优化器计算使用不同索引的成本后，最后决定采用<code>idx_key3</code>。</p>
<h4 id="7-key-len-☆"><a href="#7-key-len-☆" class="headerlink" title="7. key_len ☆"></a>7. key_len ☆</h4><p>实际使用到的索引长度 (即：字节数)</p>
<p>帮你检查<code>是否充分的利用了索引</code>，<code>值越大越好</code>，主要针对于联合索引，有一定的参考意义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE id = 10005;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704130030692.png" alt="image-20220704130030692"></p>
<blockquote>
<p>int 占用 4 个字节</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 = 10126;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704130138204.png" alt="image-20220704130138204"></p>
<blockquote>
<p>key2上有一个唯一性约束，是否为NULL占用一个字节，那么就是5个字节</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704130214482.png" alt="image-20220704130214482"></p>
<blockquote>
<p>key1 VARCHAR(100) 一个字符占3个字节，100*3，是否为NULL占用一个字节，varchar的长度信息占两个字节。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704130442095.png" alt="image-20220704130442095"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704130515031.png" alt="image-20220704130515031"></p>
<blockquote>
<p>联合索引中可以比较，key_len=606的好于key_len=303</p>
</blockquote>
<p><strong>练习： </strong></p>
<p>key_len的长度计算公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">varchar(10)变长字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)</span><br><span class="line"></span><br><span class="line">varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)</span><br><span class="line"></span><br><span class="line">char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)</span><br><span class="line"></span><br><span class="line">char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)</span><br></pre></td></tr></table></figure>
<h4 id="8-ref"><a href="#8-ref" class="headerlink" title="8. ref"></a>8. ref</h4><p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p>
<p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是<code>const</code>、<code>eq_re</code> 、<code>ref</code> 、<code>ref_or_null</code>、<code>unique_subquery</code>、<code>index_subquery</code>其中之一时，ref列展示的就是与索引列作等值匹配的结构是什么，比如只是一个常数或者是某个列。大家看下边这个查询:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704130837498.png" alt="image-20220704130837498"></p>
<p>可以看到<code>ref</code>列的值是<code>const</code>，表明在使用<code>idx_key1</code>索引执行查询时，与<code>key1</code>列作等值匹配的对象是一个常数，当然有时候更复杂一点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704130925426.png" alt="image-20220704130925426"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704130957359.png" alt="image-20220704130957359"></p>
<h4 id="9-rows-☆"><a href="#9-rows-☆" class="headerlink" title="9. rows ☆"></a>9. rows ☆</h4><p>预估的需要读取的记录条数，<code>值越小越好</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704131050496.png" alt="image-20220704131050496"></p>
<h4 id="10-filtered"><a href="#10-filtered" class="headerlink" title="10. filtered"></a>10. filtered</h4><p>某个表经过搜索条件过滤后剩余记录条数的百分比</p>
<p>如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704131323242.png" alt="image-20220704131323242"></p>
<p>对于单表查询来说，这个filtered的值没有什么意义，我们<code>更关注在连接查询中驱动表对应的执行计划记录的filtered值</code>，它决定了被驱动表要执行的次数 (即: rows * filtered)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704131644615.png" alt="image-20220704131644615"></p>
<p>从执行计划中可以看出来，查询优化器打算把<code>s1</code>作为驱动表，<code>s2</code>当做被驱动表。我们可以看到驱动表<code>s1</code>表的执行计划的<code>rows</code>列为<code>9688</code>，filtered列为<code>10.00</code>，这意味着驱动表<code>s1</code>的扇出值就是<code>9688 x 10.00% = 968.8</code>，这说明还要对被驱动表执行大约<code>968</code>次查询。</p>
<h4 id="11-Extra-☆"><a href="#11-Extra-☆" class="headerlink" title="11. Extra ☆"></a>11. Extra ☆</h4><p>顾名思义，<code>Extra</code>列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来<code>更准确的理解MySQL到底将如何执行给定的查询语句</code>。MySQL提供的额外信息有好几十个，我们就不一个一个介绍了，所以我们只挑选比较重要的额外信息介绍给大家。</p>
<ul>
<li><p><code>No tables used</code></p>
<p>当查询语句没有<code>FROM</code>子句时将会提示该额外信息，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704132345383.png" alt="image-20220704132345383"></p>
</li>
<li><p><code>Impossible WHERE</code></p>
<p>当查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时将会提示该额外信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE 1 != 1;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704132458978.png" alt="image-20220704132458978"></p>
</li>
<li><p><code>Using where</code></p>
</li>
</ul>
<p>不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤。表明使用了where过滤。</p>
<p>当我们使用全表扫描来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有针对该表的搜索条件时，在<code>Extra</code>列中会提示上述额外信息。比如下边这个查询:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704132655342.png" alt="image-20220704132655342"></p>
<p>当使用索引访问来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有除了该索引包含的列之外的其他搜索条件时，在Extra列中也会提示上述额外信息。比如下边这个查询虽然使用<code>idx_key1</code>索引执行查询，但是搜索条件中除了包含<code>key1</code>的搜索条件<code>key1 = &#39;a&#39;</code>，还包含<code>common_field</code>的搜索条件，所以<code>Extra</code>列会显示<code>Using where</code>的提示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; AND common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704133130515.png" alt="image-20220704133130515"></p>
<ul>
<li><p><code>No matching min/max row</code></p>
<p>当查询列表处有<code>MIN</code>或者<code>MAX</code>聚合函数，但是并没有符合<code>WHERE</code>子句中的搜索条件的记录时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = &#x27;abcdefg&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704134324354.png" alt="image-20220704134324354"></p>
</li>
<li><p><code>Using index</code></p>
<p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在<code>Extra</code>列将会提示该额外信息。比方说下边这个查询中只需要用到<code>idx_key1</code>而不需要回表操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key1 FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704134931220.png" alt="image-20220704134931220"></p>
</li>
<li><p><code>Using index condition</code></p>
<p>有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%a&#x27;;</span><br></pre></td></tr></table></figure>
<p>其中的<code>key1 &gt; &#39;z&#39;</code>可以使用到索引，但是<code>key1 LIKE &#39;%a&#39;</code>却无法使用到索引，在以前版本的MysQL中，是按照下边步骤来执行这个查询的:</p>
<ul>
<li>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，从二级索引<code>idx_key1</code>中获取到对应的二级索引记录。</li>
<li>根据上一步骤得到的二级索引记录中的主键值进行<code>回表</code>，找到完整的用户记录再检测该记录是否符合<code>key1 LIKE &#39;%a&#39;</code>这个条件，将符合条件的记录加入到最后的结果集。</li>
</ul>
<p>但是虽然<code>key1 LIKE &#39;%a&#39;</code>不能组成范围区间参与<code>range</code>访问方法的执行,但这个条件毕竟只涉及到了<code>key1</code>列，所以MySQL把上边的步骤改进l—下:</p>
<ul>
<li>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，定位到二级索引<code>idx_key1</code>中对应的二级索引记录。</li>
<li>对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足<code>key1 LIKE ‘%a&#39;</code>这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。</li>
<li>对于满足<code>key1 LIKE &#39;%a&#39;</code>这个条件的二级索引记录执行回表操作。</li>
</ul>
<p>我们说回表操作其实是一个<code>随机IO</code>，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。MySQL把他们的这个改进称之为<code>索引条件下推</code>(英文名: <code>Index Condition Pushdown</code> )。</p>
<p>如果在查询语句的执行过程中将要使用<code>索引条件下推</code>这个特性，在Extra列中将会显示<code>Using index condition</code>，比如这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%b&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704140441702.png" alt="image-20220704140441702"></p>
</li>
<li><p><code>Using join buffer (Block Nested Loop)</code></p>
<p>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<code>基于块的嵌套循环算法</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704140815955.png" alt="image-20220704140815955"></p>
</li>
<li><p><code>Not exists</code></p>
<p>当我们使用左(外)连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列是不允许存储<code>NULL</code>值的，那么在该表的执行计划的Extra列就会提示这个信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704142059555.png" alt="image-20220704142059555"></p>
</li>
<li><p><code>Using intersect(...) 、 Using union(...) 和 Using sort_union(...)</code></p>
<p>如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；</p>
<p>如果出现<code>Using union(...)</code>提示，说明准备使用<code>Union</code>索引合并的方式执行查询;</p>
<p>如果出现<code>Using sort_union(...)</code>提示，说明准备使用<code>Sort-Union</code>索引合并的方式执行查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704142552890.png" alt="image-20220704142552890"></p>
</li>
<li><p><code>Zero limit</code></p>
<p>当我们的<code>LIMIT</code>子句的参数为<code>0</code>时，表示压根儿不打算从表中读取任何记录，将会提示该额外信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 LIMIT 0;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704142754394.png" alt="image-20220704142754394"></p>
</li>
<li><p><code>Using filesort</code></p>
<p>有一些情况下对结果集中的记录进行排序是可以使用到索引的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704142901857.png" alt="image-20220704142901857"></p>
<p>这个查询语句可以利用<code>idx_key1</code>索引直接取出<code>key1</code>列的10条记录，然后再进行回表操作就好了。但是很多情况下排序操作无法使用到索引，只能在内存中(记录较少的时候）或者磁盘中（记录较多的时候）进行排序，MysQL把这种在内存中或者磁盘上进行排序的方式统称为文件排序(英文名: <code>filesort</code> )。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的<code>Extra</code>列中显示<code>Using filesort</code>提示，比如这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704143518857.png" alt="image-20220704143518857"></p>
<p>需要注意的是，如果查询中需要使用<code>filesort</code>的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法<code>将使用文件排序的执行方式改为索引进行排序</code>。</p>
</li>
<li><p><code>Using temporary</code></p>
<p>在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重排序之类的，比如我们在执行许多包含<code>DISTINCT</code>、<code>GROUP BY</code>、<code>UNION</code>等子句的查询过程中，如果不能有效利用索引来完成查询，MysQL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的<code>Extra</code>列将会显示<code>Using temporary</code>提示，比方说这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT DISTINCT common_field FROM s1;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704150030005.png" alt="image-20220704150030005"></p>
<p>再比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704150156416.png" alt="image-20220704150156416"></p>
<p>执行计划中出现<code>Using temporary</code>并不是一个好的征兆，因为建立与维护临时表要付出很大的成本的，所以我们<code>最好能使用索引来替代掉使用临时表</code>，比方说下边这个包含<code>GROUP BY</code>子句的查询就不需要使用临时表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704150308189.png" alt="image-20220704150308189"></p>
<p>从 <code>Extra</code> 的 <code>Using index</code> 的提示里我们可以看出，上述查询只需要扫描 <code>idx_key1</code> 索引就可以搞 定了，不再需要临时表了。</p>
</li>
<li><p>其他</p>
<p>其它特殊情况这里省略。</p>
</li>
</ul>
<h4 id="12-小结"><a href="#12-小结" class="headerlink" title="12. 小结"></a>12. 小结</h4><ul>
<li>EXPLAIN不考虑各种Cache </li>
<li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作 </li>
<li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况 </li>
<li>部分统计信息是估算的，并非精确值</li>
</ul>
<h2 id="7-EXPLAIN的进一步使用"><a href="#7-EXPLAIN的进一步使用" class="headerlink" title="7. EXPLAIN的进一步使用"></a>7. EXPLAIN的进一步使用</h2><h3 id="7-1-EXPLAIN四种输出格式"><a href="#7-1-EXPLAIN四种输出格式" class="headerlink" title="7.1 EXPLAIN四种输出格式"></a>7.1 EXPLAIN四种输出格式</h3><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式： <code>传统格式</code> ，<code>JSON格式</code> ， <code>TREE格式</code> 以及 <code>可视化输出</code> 。用户可以根据需要选择适用于自己的格式。</p>
<h4 id="1-传统格式"><a href="#1-传统格式" class="headerlink" title="1. 传统格式"></a>1. 传统格式</h4><p>传统格式简单明了，输出是一个表格形式，概要说明查询计划。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704161702384.png" alt="image-20220704161702384"></p>
<h4 id="2-JSON格式"><a href="#2-JSON格式" class="headerlink" title="2. JSON格式"></a>2. JSON格式</h4><p>第1种格式中介绍的<code>EXPLAIN</code>语句输出中缺少了一个衡量执行好坏的重要属性 —— <code>成本</code>。而JSON格式是四种格式里面输出<code>信息最详尽</code>的格式，里面包含了执行的成本信息。</p>
<ul>
<li>JSON格式：在EXPLAIN单词和真正的查询语句中间加上 FORMAT=JSON 。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN FORMAT=JSON SELECT ....</span><br></pre></td></tr></table></figure>
<ul>
<li>EXPLAIN的Column与JSON的对应关系：(来源于MySQL 5.7文档)</li>
</ul>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704164236909.png" alt="image-20220704164236909"></p>
<p>这样我们就可以得到一个json格式的执行计划，里面包含该计划花费的成本。比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = &#x27;a&#x27;\G</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704172833362.png" alt="image-20220704172833362"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704172920158.png" alt="image-20220704172920158"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704173012413.png" alt="image-20220704173012413"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704173045190.png" alt="image-20220704173045190"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704173108888.png" alt="image-20220704173108888"></p>
<p>我们使用 # 后边跟随注释的形式为大家解释了 <code>EXPLAIN FORMAT=JSON</code> 语句的输出内容，但是大家可能 有疑问 “<code>cost_info</code>“ 里边的成本看着怪怪的，它们是怎么计算出来的？先看 s1 表的 “<code>cost_info</code>“ 部 分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">    &quot;read_cost&quot;: &quot;1840.84&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;2034.60&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>read_cost</code> 是由下边这两部分组成的：</p>
<ul>
<li>IO 成本</li>
<li>检测 rows × (1 - filter) 条记录的 CPU 成本</li>
</ul>
<blockquote>
<p>小贴士： rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows 相当于rows_examined_per_scan，filtered名称不变。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>eval_cost</code> 是这样计算的：</p>
<p>检测 rows × filter 条记录的成本。</p>
</li>
<li><p><code>prefix_cost</code> 就是单独查询 s1 表的成本，也就是：</p>
<p><code>read_cost + eval_cost</code></p>
</li>
<li><p><code>data_read_per_join</code> 表示在此次查询中需要读取的数据量。</p>
</li>
</ul>
<p>对于 <code>s2</code> 表的 “<code>cost_info</code>“ 部分是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">    &quot;read_cost&quot;: &quot;968.80&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;3197.16&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>s2</code> 表是被驱动表，所以可能被读取多次，这里的<code>read_cost</code> 和 <code>eval_cost</code> 是访问多次 <code>s2</code> 表后累加起来的值，大家主要关注里边儿的 <code>prefix_cost</code> 的值代表的是整个连接查询预计的成本，也就是单次查询 <code>s1</code> 表和多次查询 <code>s2</code> 表后的成本的和，也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">968.80 + 193.76 + 2034.60 = 3197.16</span><br></pre></td></tr></table></figure>
<h4 id="3-TREE格式"><a href="#3-TREE格式" class="headerlink" title="3. TREE格式"></a>3. TREE格式</h4><p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的 <code>各个部分之间的关系</code> 和 <code>各部分的执行顺序</code> 来描述如何查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT=tree SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE</span><br><span class="line">s1.common_field = &#x27;a&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Nested loop inner join (cost=1360.08 rows=990)</span><br><span class="line">-&gt; Filter: ((s1.common_field = &#x27;a&#x27;) and (s1.key1 is not null)) (cost=1013.75</span><br><span class="line">rows=990)</span><br><span class="line">-&gt; Table scan on s1 (cost=1013.75 rows=9895)</span><br><span class="line">-&gt; Single-row index lookup on s2 using idx_key2 (key2=s1.key1), with index</span><br><span class="line">condition: (cast(s1.key1 as double) = cast(s2.key2 as double)) (cost=0.25 rows=1)</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<h4 id="4-可视化输出"><a href="#4-可视化输出" class="headerlink" title="4. 可视化输出"></a>4. 可视化输出</h4><p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。通过点击Workbench的放大镜图标，即可生成可视化的查询计划。 </p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704174401970.png" alt="image-20220704174401970"></p>
<p>上图按从左到右的连接顺序显示表。红色框表示 <code>全表扫描</code> ，而绿色框表示使用 <code>索引查找</code> 。对于每个表， 显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表的成本。</p>
<h3 id="7-2-SHOW-WARNINGS的使用"><a href="#7-2-SHOW-WARNINGS的使用" class="headerlink" title="7.2 SHOW WARNINGS的使用"></a>7.2 SHOW WARNINGS的使用</h3><p>在我们使用<code>EXPLAIN</code>语句查看了某个查询的执行计划后，紧接着还可以使用<code>SHOW WARNINGS</code>语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704174543663.png" alt="image-20220704174543663"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    Level: Note</span><br><span class="line">     Code: 1003</span><br><span class="line">Message: /* select#1 */ select `atguigu`.`s1`.`key1` AS `key1`,`atguigu`.`s2`.`key1`</span><br><span class="line">AS `key1` from `atguigu`.`s1` join `atguigu`.`s2` where ((`atguigu`.`s1`.`key1` =</span><br><span class="line">`atguigu`.`s2`.`key1`) and (`atguigu`.`s2`.`common_field` is not null))</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>大家可以看到<code>SHOW WARNINGS</code>展示出来的信息有三个字段，分别是<code>Level、Code、Message</code>。我们最常见的就是Code为1003的信息，当Code值为1003时，<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左(外)连接查询，但是有一个s2.common_field IS NOT NULL的条件，这就会导致查询优化器把左(外)连接查询优化为内连接查询，从<code>SHOW WARNINGS</code>的<code>Message</code>字段也可以看出来，原本的LEFE JOIN已经变成了JOIN。</p>
<p>0但是大家一定要注意，我们说<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句<code>重写后的语句</code>，并不是等价于，也就是说<code>Message</code>字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解MySQL将如何执行查询语句的一个参考依据而已。</p>
<h2 id="8-分析优化器执行计划：trace"><a href="#8-分析优化器执行计划：trace" class="headerlink" title="8. 分析优化器执行计划：trace"></a>8. 分析优化器执行计划：trace</h2><p><code>OPTIMIZER_TRACE</code>是MySQL5.6引入的一项跟踪功能，它可以跟踪优化器做出的各种决策〈(比如访问表的方法、各种开销计算、各种转换等)，并将跟踪结果记录到<code>INFORMATION_SCHEMA.OPTIMIZER_TRACE</code>表中。</p>
<p>此功能默认关闭。开启trace，并设置格式为JSON，同时设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on;</span><br><span class="line">set optimizer_trace_max_mem_size=1000000;</span><br></pre></td></tr></table></figure>
<p>开启后，可分析如下语句： </p>
<ul>
<li>SELECT </li>
<li>INSERT </li>
<li>REPLACE</li>
<li>UPDATE </li>
<li>DELETE </li>
<li>EXPLAIN </li>
<li>SET </li>
<li>DECLARE </li>
<li>CASE </li>
<li>IF </li>
<li>RETURN </li>
<li>CALL</li>
</ul>
<p>测试：执行如下SQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where id &lt; 10;</span><br></pre></td></tr></table></figure>
<p>最后， 查询 information_schema.optimizer_trace 就可以知道MySQL是如何执行SQL的 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from information_schema.optimizer_trace\G</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">//第1部分：查询语句</span><br><span class="line">QUERY: select * from student where id &lt; 10</span><br><span class="line">//第2部分：QUERY字段对应语句的跟踪信息</span><br><span class="line">TRACE: &#123;</span><br><span class="line">&quot;steps&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">    &quot;join_preparation&quot;: &#123; //预备工作</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">            &quot;expanded_query&quot;: &quot;/* select#1 */ select `student`.`id` AS</span><br><span class="line">            `id`,`student`.`stuno` AS `stuno`,`student`.`name` AS `name`,`student`.`age` AS</span><br><span class="line">            `age`,`student`.`classId` AS `classId` from `student` where (`student`.`id` &lt; 10)&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">    &#125; /* join_preparation */</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;join_optimization&quot;: &#123; //进行优化</span><br><span class="line">    &quot;select#&quot;: 1,</span><br><span class="line">    &quot;steps&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">        &quot;condition_processing&quot;: &#123; //条件处理</span><br><span class="line">        &quot;condition&quot;: &quot;WHERE&quot;,</span><br><span class="line">        &quot;original_condition&quot;: &quot;(`student`.`id` &lt; 10)&quot;,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;transformation&quot;: &quot;equality_propagation&quot;,</span><br><span class="line">            &quot;resulting_condition&quot;: &quot;(`student`.`id` &lt; 10)&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;transformation&quot;: &quot;constant_propagation&quot;,</span><br><span class="line">            &quot;resulting_condition&quot;: &quot;(`student`.`id` &lt; 10)&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,</span><br><span class="line">            &quot;resulting_condition&quot;: &quot;(`student`.`id` &lt; 10)&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">    &#125; /* condition_processing */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;substitute_generated_columns&quot;: &#123; //替换生成的列</span><br><span class="line">        &#125; /* substitute_generated_columns */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;table_dependencies&quot;: [ //表的依赖关系</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;table&quot;: &quot;`student`&quot;,</span><br><span class="line">            &quot;row_may_be_null&quot;: false,</span><br><span class="line">            &quot;map_bit&quot;: 0,</span><br><span class="line">            &quot;depends_on_map_bits&quot;: [</span><br><span class="line">            ] /* depends_on_map_bits */</span><br><span class="line">        &#125;</span><br><span class="line">    ] /* table_dependencies */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;ref_optimizer_key_uses&quot;: [ //使用键</span><br><span class="line">        ] /* ref_optimizer_key_uses */</span><br><span class="line">        &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;rows_estimation&quot;: [ //行判断</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;table&quot;: &quot;`student`&quot;,</span><br><span class="line">            &quot;range_analysis&quot;: &#123;</span><br><span class="line">                &quot;table_scan&quot;: &#123;</span><br><span class="line">                    &quot;rows&quot;: 3973767,</span><br><span class="line">                    &quot;cost&quot;: 408558</span><br><span class="line">            &#125; /* table_scan */, //扫描表</span><br><span class="line">            &quot;potential_range_indexes&quot;: [ //潜在的范围索引</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                    &quot;usable&quot;: true,</span><br><span class="line">                    &quot;key_parts&quot;: [</span><br><span class="line">                    &quot;id&quot;</span><br><span class="line">                    ] /* key_parts */</span><br><span class="line">                &#125;</span><br><span class="line">            ] /* potential_range_indexes */,</span><br><span class="line">        &quot;setup_range_conditions&quot;: [ //设置范围条件</span><br><span class="line">        ] /* setup_range_conditions */,</span><br><span class="line">        &quot;group_index_range&quot;: &#123;</span><br><span class="line">            &quot;chosen&quot;: false,</span><br><span class="line">            &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;</span><br><span class="line">        &#125; /* group_index_range */,</span><br><span class="line">            &quot;skip_scan_range&quot;: &#123;</span><br><span class="line">                &quot;potential_skip_scan_indexes&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                        &quot;usable&quot;: false,</span><br><span class="line">                        &quot;cause&quot;: &quot;query_references_nonkey_column&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ] /* potential_skip_scan_indexes */</span><br><span class="line">            &#125; /* skip_scan_range */,</span><br><span class="line">        &quot;analyzing_range_alternatives&quot;: &#123; //分析范围选项</span><br><span class="line">            &quot;range_scan_alternatives&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                    &quot;ranges&quot;: [</span><br><span class="line">                        &quot;id &lt; 10&quot;</span><br><span class="line">                    ] /* ranges */,</span><br><span class="line">                &quot;index_dives_for_eq_ranges&quot;: true,</span><br><span class="line">                &quot;rowid_ordered&quot;: true,</span><br><span class="line">                &quot;using_mrr&quot;: false,</span><br><span class="line">                &quot;index_only&quot;: false,</span><br><span class="line">                &quot;rows&quot;: 9,</span><br><span class="line">                &quot;cost&quot;: 1.91986,</span><br><span class="line">                &quot;chosen&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ] /* range_scan_alternatives */,</span><br><span class="line">        &quot;analyzing_roworder_intersect&quot;: &#123;</span><br><span class="line">            &quot;usable&quot;: false,</span><br><span class="line">            &quot;cause&quot;: &quot;too_few_roworder_scans&quot;</span><br><span class="line">        	&#125; /* analyzing_roworder_intersect */</span><br><span class="line">        &#125; /* analyzing_range_alternatives */,</span><br><span class="line">        &quot;chosen_range_access_summary&quot;: &#123; //选择范围访问摘要</span><br><span class="line">            &quot;range_access_plan&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;range_scan&quot;,</span><br><span class="line">                &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                &quot;rows&quot;: 9,</span><br><span class="line">                &quot;ranges&quot;: [</span><br><span class="line">                &quot;id &lt; 10&quot;</span><br><span class="line">                ] /* ranges */</span><br><span class="line">                &#125; /* range_access_plan */,</span><br><span class="line">                &quot;rows_for_plan&quot;: 9,</span><br><span class="line">                &quot;cost_for_plan&quot;: 1.91986,</span><br><span class="line">                &quot;chosen&quot;: true</span><br><span class="line">                &#125; /* chosen_range_access_summary */</span><br><span class="line">                &#125; /* range_analysis */</span><br><span class="line">            &#125;</span><br><span class="line">        ] /* rows_estimation */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;considered_execution_plans&quot;: [ //考虑执行计划</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;plan_prefix&quot;: [</span><br><span class="line">    ] /* plan_prefix */,</span><br><span class="line">        &quot;table&quot;: &quot;`student`&quot;,</span><br><span class="line">        &quot;best_access_path&quot;: &#123; //最佳访问路径</span><br><span class="line">        &quot;considered_access_paths&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;rows_to_scan&quot;: 9,</span><br><span class="line">            &quot;access_type&quot;: &quot;range&quot;,</span><br><span class="line">            &quot;range_details&quot;: &#123;</span><br><span class="line">            &quot;used_index&quot;: &quot;PRIMARY&quot;</span><br><span class="line">        &#125; /* range_details */,</span><br><span class="line">        &quot;resulting_rows&quot;: 9,</span><br><span class="line">        &quot;cost&quot;: 2.81986,</span><br><span class="line">        &quot;chosen&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">    ] /* considered_access_paths */</span><br><span class="line">    &#125; /* best_access_path */,</span><br><span class="line">        &quot;condition_filtering_pct&quot;: 100, //行过滤百分比</span><br><span class="line">        &quot;rows_for_plan&quot;: 9,</span><br><span class="line">        &quot;cost_for_plan&quot;: 2.81986,</span><br><span class="line">        &quot;chosen&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">    ] /* considered_execution_plans */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;attaching_conditions_to_tables&quot;: &#123; //将条件附加到表上</span><br><span class="line">        &quot;original_condition&quot;: &quot;(`student`.`id` &lt; 10)&quot;,</span><br><span class="line">        &quot;attached_conditions_computation&quot;: [</span><br><span class="line">        ] /* attached_conditions_computation */,</span><br><span class="line">        &quot;attached_conditions_summary&quot;: [ //附加条件概要</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;table&quot;: &quot;`student`&quot;,</span><br><span class="line">        &quot;attached&quot;: &quot;(`student`.`id` &lt; 10)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ] /* attached_conditions_summary */</span><br><span class="line">    &#125; /* attaching_conditions_to_tables */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;finalizing_table_conditions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;table&quot;: &quot;`student`&quot;,</span><br><span class="line">        &quot;original_table_condition&quot;: &quot;(`student`.`id` &lt; 10)&quot;,</span><br><span class="line">        &quot;final_table_condition &quot;: &quot;(`student`.`id` &lt; 10)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ] /* finalizing_table_conditions */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;refine_plan&quot;: [ //精简计划</span><br><span class="line">    &#123;</span><br><span class="line">    	&quot;table&quot;: &quot;`student`&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ] /* refine_plan */</span><br><span class="line">    &#125;</span><br><span class="line">    ] /* steps */</span><br><span class="line">    &#125; /* join_optimization */</span><br><span class="line">&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">        &quot;join_execution&quot;: &#123; //执行</span><br><span class="line">            &quot;select#&quot;: 1,</span><br><span class="line">            &quot;steps&quot;: [</span><br><span class="line">            ] /* steps */</span><br><span class="line">        	&#125; /* join_execution */</span><br><span class="line">        &#125;</span><br><span class="line">    ] /* steps */</span><br><span class="line">&#125;</span><br><span class="line">//第3部分：跟踪信息过长时，被截断的跟踪信息的字节数。</span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0 //丢失的超出最大容量的字节</span><br><span class="line">//第4部分：执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为1且TRACE字段为空，一般在</span><br><span class="line">调用带有SQL SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题。</span><br><span class="line">INSUFFICIENT_PRIVILEGES: 0 //缺失权限</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="9-MySQL监控分析视图-sys-schema"><a href="#9-MySQL监控分析视图-sys-schema" class="headerlink" title="9. MySQL监控分析视图-sys schema"></a>9. MySQL监控分析视图-sys schema</h2><p>关于MySQL的性能监控和问题诊断，我们一般都从performance_schema中去获取想要的数据，在MySQL5.7.7版本中新增sys schema，它将performance_schema和information_schema中的数据以更容易理解的方式总结归纳为”视图”，其目的就是为了<code>降低查询performance_schema的复杂度</code>，让DBA能够快速的定位问题。下面看看这些库中都有哪些监控表和视图，掌握了这些，在我们开发和运维的过程中就起到了事半功倍的效果。</p>
<h3 id="9-1-Sys-schema视图摘要"><a href="#9-1-Sys-schema视图摘要" class="headerlink" title="9.1 Sys schema视图摘要"></a>9.1 Sys schema视图摘要</h3><ol>
<li><strong>主机相关</strong>：以host_summary开头，主要汇总了IO延迟的信息。 </li>
<li><strong>Innodb相关</strong>：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。 </li>
<li><strong>I/o相关</strong>：以io开头，汇总了等待I/O、I/O使用量情况。 </li>
<li><strong>内存使用情况</strong>：以memory开头，从主机、线程、事件等角度展示内存的使用情况 </li>
<li><strong>连接与会话信息</strong>：processlist和session相关视图，总结了会话相关信息。 </li>
<li><strong>表相关</strong>：以schema_table开头的视图，展示了表的统计信息。 </li>
<li><strong>索引信息</strong>：统计了索引的使用情况，包含冗余索引和未使用的索引情况。 </li>
<li><strong>语句相关</strong>：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。 </li>
<li><strong>用户相关</strong>：以user开头的视图，统计了用户使用的文件I/O、执行语句统计信息。 </li>
<li><strong>等待事件相关信息</strong>：以wait开头，展示等待事件的延迟情况。</li>
</ol>
<h3 id="9-2-Sys-schema视图使用场景"><a href="#9-2-Sys-schema视图使用场景" class="headerlink" title="9.2 Sys schema视图使用场景"></a>9.2 Sys schema视图使用场景</h3><p>索引情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. 查询冗余索引</span><br><span class="line">select * from sys.schema_redundant_indexes;</span><br><span class="line">#2. 查询未使用过的索引</span><br><span class="line">select * from sys.schema_unused_indexes;</span><br><span class="line">#3. 查询索引的使用情况</span><br><span class="line">select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line">from sys.schema_index_statistics where table_schema=&#x27;dbname&#x27;;</span><br></pre></td></tr></table></figure>
<p>表相关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 查询表的访问量</span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from</span><br><span class="line">sys.schema_table_statistics group by table_schema,table_name order by io desc;</span><br><span class="line"># 2. 查询占用bufferpool较多的表</span><br><span class="line">select object_schema,object_name,allocated,data</span><br><span class="line">from sys.innodb_buffer_stats_by_table order by allocated limit 10;</span><br><span class="line"># 3. 查看表的全表扫描情况</span><br><span class="line">select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;;</span><br></pre></td></tr></table></figure>
<p>语句相关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. 监控SQL执行的频率</span><br><span class="line">select db,exec_count,query from sys.statement_analysis</span><br><span class="line">order by exec_count desc;</span><br><span class="line">#2. 监控使用了排序的SQL</span><br><span class="line">select db,exec_count,first_seen,last_seen,query</span><br><span class="line">from sys.statements_with_sorting limit 1;</span><br><span class="line">#3. 监控使用了临时表或者磁盘临时表的SQL</span><br><span class="line">select db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line">from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0</span><br><span class="line">order by (tmp_tables+tmp_disk_tables) desc;</span><br></pre></td></tr></table></figure>
<p>IO相关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. 查看消耗磁盘IO的文件</span><br><span class="line">select file,avg_read,avg_write,avg_read+avg_write as avg_io</span><br><span class="line">from sys.io_global_by_file_by_bytes order by avg_read limit 10;</span><br></pre></td></tr></table></figure>
<p>Innodb 相关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1. 行锁阻塞情况</span><br><span class="line">select * from sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704192020603.png" alt="image-20220704192020603" style="float:left;"></p>
<h2 id="10-小结"><a href="#10-小结" class="headerlink" title="10. 小结"></a>10. 小结</h2><p>查询是数据库中最频繁的操作，提高查询速度可以有效地提高MySQL数据库的性能。通过对查询语句的分析可以了解查询语句的执行情况，找出查询语句执行的瓶颈，从而优化查询语句。</p>
<h1 id="第10章-索引优化与查询优化"><a href="#第10章-索引优化与查询优化" class="headerlink" title="第10章_索引优化与查询优化"></a>第10章_索引优化与查询优化</h1><p>都有哪些维度可以进行数据库调优？简言之：</p>
<ul>
<li>索引失效、没有充分利用到索引——建立索引</li>
<li>关联查询太多JOIN（设计缺陷或不得已的需求）——SQL优化</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li>
<li>数据过多——分库分表</li>
</ul>
<p>关于数据库调优的知识非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。</p>
<p>虽然SQL查询优化的技术有很多，但是大方向上完全可以分成<code>物理查询优化</code>和<code>逻辑查询优化</code>两大块。</p>
<ul>
<li>物理查询优化是通过<code>索引</code>和<code>表连接方式</code>等技术来进行优化，这里重点需要掌握索引的使用。</li>
<li>逻辑查询优化就是通过SQL<code>等价变换</code>提升查询效率，直白一点就是说，换一种查询写法效率可能更高。</li>
</ul>
<h2 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h2><p><code>学员表</code> 插 <code>50万</code> 条，<code>班级表</code> 插 <code>1万</code> 条。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE atguigudb2;</span><br><span class="line">USE atguigudb2;</span><br></pre></td></tr></table></figure>
<p><strong>步骤1：建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `class` (</span><br><span class="line">    `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `className` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">    `address` VARCHAR(40) DEFAULT NULL,</span><br><span class="line">    `monitor` INT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">    `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `stuno` INT NOT NULL ,</span><br><span class="line">    `name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">    `age` INT(3) DEFAULT NULL,</span><br><span class="line">    `classId` INT(11) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">    #CONSTRAINT `fk_class_id` FOREIGN KEY (`classId`) REFERENCES `t_class` (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p><strong>步骤2：设置参数</strong></p>
<ul>
<li>命令开启：允许创建函数设置：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure>
<p><strong>步骤3：创建函数</strong></p>
<p>保证每条数据都不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#随机产生字符串</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">WHILE i &lt; n DO</span><br><span class="line">SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">SET i = i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line">RETURN return_str;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#drop function rand_string;</span><br></pre></td></tr></table></figure>
<p>随机产生班级编号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#用于随机产生多少到多少的编号</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;</span><br><span class="line">RETURN i;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#drop function rand_num;</span><br></pre></td></tr></table></figure>
<p><strong>步骤4：创建存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建往stu表中插入数据的存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_stu( START INT , max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line">SET i = i + 1; #赋值</span><br><span class="line">INSERT INTO student (stuno, name ,age ,classId ) VALUES</span><br><span class="line">((START+i),rand_string(6),rand_num(1,50),rand_num(1,1000));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT; #提交事务</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#drop PROCEDURE insert_stu;</span><br></pre></td></tr></table></figure>
<p>创建往class表中插入数据的存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#执行存储过程，往class表添加随机数据</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE `insert_class`( max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0;</span><br><span class="line">REPEAT</span><br><span class="line">SET i = i + 1;</span><br><span class="line">INSERT INTO class ( classname,address,monitor ) VALUES</span><br><span class="line">(rand_string(8),rand_string(10),rand_num(1,100000));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#drop PROCEDURE insert_class;</span><br></pre></td></tr></table></figure>
<p><strong>步骤5：调用存储过程</strong></p>
<p>class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#执行存储过程，往class表添加1万条数据</span><br><span class="line">CALL insert_class(10000);</span><br></pre></td></tr></table></figure>
<p>stu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#执行存储过程，往stu表添加50万条数据</span><br><span class="line">CALL insert_stu(100000,500000);</span><br></pre></td></tr></table></figure>
<p><strong>步骤6：删除某表上的索引</strong></p>
<p>创建存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE `proc_drop_index`(dbname VARCHAR(200),tablename VARCHAR(200))</span><br><span class="line">BEGIN</span><br><span class="line">        DECLARE done INT DEFAULT 0;</span><br><span class="line">        DECLARE ct INT DEFAULT 0;</span><br><span class="line">        DECLARE _index VARCHAR(200) DEFAULT &#x27;&#x27;;</span><br><span class="line">        DECLARE _cur CURSOR FOR SELECT index_name FROM</span><br><span class="line">information_schema.STATISTICS WHERE table_schema=dbname AND table_name=tablename AND</span><br><span class="line">seq_in_index=1 AND index_name &lt;&gt;&#x27;PRIMARY&#x27; ;</span><br><span class="line">#每个游标必须使用不同的declare continue handler for not found set done=1来控制游标的结束</span><br><span class="line">		DECLARE CONTINUE HANDLER FOR NOT FOUND set done=2 ;</span><br><span class="line">#若没有数据返回,程序继续,并将变量done设为2</span><br><span class="line">        OPEN _cur;</span><br><span class="line">        FETCH _cur INTO _index;</span><br><span class="line">        WHILE _index&lt;&gt;&#x27;&#x27; DO</span><br><span class="line">            SET @str = CONCAT(&quot;drop index &quot; , _index , &quot; on &quot; , tablename );</span><br><span class="line">            PREPARE sql_str FROM @str ;</span><br><span class="line">            EXECUTE sql_str;</span><br><span class="line">            DEALLOCATE PREPARE sql_str;</span><br><span class="line">            SET _index=&#x27;&#x27;;</span><br><span class="line">            FETCH _cur INTO _index;</span><br><span class="line">        END WHILE;</span><br><span class="line">    CLOSE _cur;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>执行存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL proc_drop_index(&quot;dbname&quot;,&quot;tablename&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="2-索引失效案例"><a href="#2-索引失效案例" class="headerlink" title="2. 索引失效案例"></a>2. 索引失效案例</h2><p>MysQL中<code>提高性能</code>的一个最有效的方式是对数据表<code>设计合理的索引</code>。索引提供了高效访问数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p>
<ul>
<li>使用索引可以<code>快速地定位</code>表中的某条记录，从而提高数据库查询的速度提高数据库的性能。</li>
<li>如果查询时没有使用索引，查询语句就会<code>扫描表中的所有记录</code>。在数据量大的情况下，这样查询的速度会很慢。</li>
</ul>
<p>大多数情况下都（默认）采用<code>B+</code>树来构建索引。只是空间列类型的索引使用<code>R-</code>树，并且MEMORY表还支持<code>hash索引</code>。</p>
<p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器?基于<code>cost开销(CostBaseOptimizer)</code>，它不是基于<code>规则(Rule-BasedOptimizer)</code>，也不是基于<code>语义</code>。怎么样开销小就怎么来。另外，<strong>SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</strong></p>
<h3 id="2-1-全值匹配我最爱"><a href="#2-1-全值匹配我最爱" class="headerlink" title="2.1 全值匹配我最爱"></a>2.1 全值匹配我最爱</h3><p>系统中经常出现的sql语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4 AND name = &#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure>
<p>建立索引前执行：（关注执行时间）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4 AND name = &#x27;abcd&#x27;;</span><br><span class="line">Empty set, 1 warning (0.28 sec)</span><br></pre></td></tr></table></figure>
<p><strong>建立索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_age ON student(age);</span><br><span class="line">CREATE INDEX idx_age_classid ON student(age,classId);</span><br><span class="line">CREATE INDEX idx_age_classid_name ON student(age,classId,name);</span><br></pre></td></tr></table></figure>
<p>建立索引后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE age=30 AND classId=4 AND name = &#x27;abcd&#x27;;</span><br><span class="line">Empty set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704204140589.png" alt="image-20220704204140589" style="float:left;"></p>
<h3 id="2-2-最佳左前缀法则"><a href="#2-2-最佳左前缀法则" class="headerlink" title="2.2 最佳左前缀法则"></a>2.2 最佳左前缀法则</h3><p>在MySQL建立联合索引时会遵守最佳左前缀原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<p>举例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = &#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure>
<p>举例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classId=1 AND student.name = &#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure>
<p>举例3：索引<code>idx_age_classid_name</code>还能否正常使用？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classId=4 AND student.age=30 AND student.name = &#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure>
<p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = &#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704211116351.png" alt="image-20220704211116351"></p>
<p>虽然可以正常使用，但是只有部分被使用到了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classId=1 AND student.name = &#x27;abcd&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704211254581.png" alt="image-20220704211254581"></p>
<p>完全没有使用上索引。</p>
<p>结论：MySQL可以为多个字段创建索引，一个索引可以包含16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong>。如果查询条件中没有用这些字段中第一个字段时，多列（或联合）索引不会被使用。</p>
<blockquote>
<p>拓展：Alibaba《Java开发手册》 </p>
<p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
</blockquote>
<h3 id="2-3-主键插入顺序"><a href="#2-3-主键插入顺序" class="headerlink" title="2.3 主键插入顺序"></a>2.3 主键插入顺序</h3><p>对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录<code>主键值从小到大</code>的顺序进行排序，所以如果我们<code>插入</code>的记录的<code>主键值是依次增大</code>的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的<code>主键值忽大忽小</code>的话，就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在<code>1~100</code>之间:</p>
<p>如果此时再插入一条主键值为 9 的记录，那它插入的位置就如下图：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704212428607.png" alt="image-20220704212428607"></p>
<p>可这个数据页已经满了，再插进来咋办呢？我们需要把当前 <code>页面分裂</code> 成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着： <code>性能损耗</code> ！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的 <code>主键值依次递增</code> ，这样就不会发生这样的性能损耗了。 所以我们建议：让主键具有 <code>AUTO_INCREMENT</code> ，让存储引擎自己为表生成主键，而不是我们手动插入 ， 比如： <code>person_info</code> 表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">    id INT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    phone_number CHAR(11) NOT NULL,</span><br><span class="line">    country varchar(100) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们自定义的主键列 <code>id</code> 拥有 <code>AUTO_INCREMENT</code> 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p>
<h3 id="2-4-计算、函数、类型转换-自动或手动-导致索引失效"><a href="#2-4-计算、函数、类型转换-自动或手动-导致索引失效" class="headerlink" title="2.4 计算、函数、类型转换(自动或手动)导致索引失效"></a>2.4 计算、函数、类型转换(自动或手动)导致索引失效</h3><ol>
<li><p>这两条sql哪种写法更好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_name ON student(NAME);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一种：索引优化生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| id | stuno | name | age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 5301379 | 1233401 | AbCHEa | 164 | 259 |</span><br><span class="line">| 7170042 | 3102064 | ABcHeB | 199 | 161 |</span><br><span class="line">| 1901614 | 1833636 | ABcHeC | 226 | 275 |</span><br><span class="line">| 5195021 | 1127043 | abchEC | 486 | 72 |</span><br><span class="line">| 4047089 | 3810031 | AbCHFd | 268 | 210 |</span><br><span class="line">| 4917074 | 849096 | ABcHfD | 264 | 442 |</span><br><span class="line">| 1540859 | 141979 | abchFF | 119 | 140 |</span><br><span class="line">| 5121801 | 1053823 | AbCHFg | 412 | 327 |</span><br><span class="line">| 2441254 | 2373276 | abchFJ | 170 | 362 |</span><br><span class="line">| 7039146 | 2971168 | ABcHgI | 502 | 465 |</span><br><span class="line">| 1636826 | 1580286 | ABcHgK | 71 | 262 |</span><br><span class="line">| 374344 | 474345 | abchHL | 367 | 212 |</span><br><span class="line">| 1596534 | 169191 | AbCHHl | 102 | 146 |</span><br><span class="line">...</span><br><span class="line">| 5266837 | 1198859 | abclXe | 292 | 298 |</span><br><span class="line">| 8126968 | 4058990 | aBClxE | 316 | 150 |</span><br><span class="line">| 4298305 | 399962 | AbCLXF | 72 | 423 |</span><br><span class="line">| 5813628 | 1745650 | aBClxF | 356 | 323 |</span><br><span class="line">| 6980448 | 2912470 | AbCLXF | 107 | 78 |</span><br><span class="line">| 7881979 | 3814001 | AbCLXF | 89 | 497 |</span><br><span class="line">| 4955576 | 887598 | ABcLxg | 121 | 385 |</span><br><span class="line">| 3653460 | 3585482 | AbCLXJ | 130 | 174 |</span><br><span class="line">| 1231990 | 1283439 | AbCLYH | 189 | 429 |</span><br><span class="line">| 6110615 | 2042637 | ABcLyh | 157 | 40 |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">401 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种：索引优化失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704214905412.png" alt="image-20220704214905412"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| id | stuno | name | age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 5301379 | 1233401 | AbCHEa | 164 | 259 |</span><br><span class="line">| 7170042 | 3102064 | ABcHeB | 199 | 161 |</span><br><span class="line">| 1901614 | 1833636 | ABcHeC | 226 | 275 |</span><br><span class="line">| 5195021 | 1127043 | abchEC | 486 | 72 |</span><br><span class="line">| 4047089 | 3810031 | AbCHFd | 268 | 210 |</span><br><span class="line">| 4917074 | 849096 | ABcHfD | 264 | 442 |</span><br><span class="line">| 1540859 | 141979 | abchFF | 119 | 140 |</span><br><span class="line">| 5121801 | 1053823 | AbCHFg | 412 | 327 |</span><br><span class="line">| 2441254 | 2373276 | abchFJ | 170 | 362 |</span><br><span class="line">| 7039146 | 2971168 | ABcHgI | 502 | 465 |</span><br><span class="line">| 1636826 | 1580286 | ABcHgK | 71 | 262 |</span><br><span class="line">| 374344 | 474345 | abchHL | 367 | 212 |</span><br><span class="line">| 1596534 | 169191 | AbCHHl | 102 | 146 |</span><br><span class="line">...</span><br><span class="line">| 5266837 | 1198859 | abclXe | 292 | 298 |</span><br><span class="line">| 8126968 | 4058990 | aBClxE | 316 | 150 |</span><br><span class="line">| 4298305 | 399962 | AbCLXF | 72 | 423 |</span><br><span class="line">| 5813628 | 1745650 | aBClxF | 356 | 323 |</span><br><span class="line">| 6980448 | 2912470 | AbCLXF | 107 | 78 |</span><br><span class="line">| 7881979 | 3814001 | AbCLXF | 89 | 497 |</span><br><span class="line">| 4955576 | 887598 | ABcLxg | 121 | 385 |</span><br><span class="line">| 3653460 | 3585482 | AbCLXJ | 130 | 174 |</span><br><span class="line">| 1231990 | 1283439 | AbCLYH | 189 | 429 |</span><br><span class="line">| 6110615 | 2042637 | ABcLyh | 157 | 40 |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">401 rows in set, 1 warning (3.62 sec)</span><br></pre></td></tr></table></figure>
<p>type为“ALL”，表示没有使用到索引，查询时间为 3.62 秒，查询效率较之前低很多。</p>
</li>
</ol>
<p><strong>再举例：</strong></p>
<ul>
<li><p>student表的字段stuno上设置有索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_sno ON student(stuno);</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引优化失效：（假设：student表的字段stuno上设置有索引）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 = 900001;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">![image-20220704215159768](MySQL索引及调优篇/image-20220704215159768.png)</span><br><span class="line"></span><br><span class="line">* 索引优化生效：</span><br><span class="line"></span><br><span class="line">  ```mysql</span><br><span class="line">  EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno = 900000;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>再举例：</strong></p>
<ul>
<li><p>student表的字段name上设置有索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_name ON student(NAME);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id, stuno, name FROM student WHERE SUBSTRING(name, 1,3)=&#x27;abc&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704215533871.png" alt="image-20220704215533871"></p>
</li>
<li><p>索引优化生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id, stuno, NAME FROM student WHERE NAME LIKE &#x27;abc%&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704215600507.png" alt="image-20220704215600507"></p>
</li>
</ul>
<h3 id="2-5-类型转换导致索引失效"><a href="#2-5-类型转换导致索引失效" class="headerlink" title="2.5 类型转换导致索引失效"></a>2.5 类型转换导致索引失效</h3><p>下列哪个sql语句可以用到索引。（假设name字段上设置有索引）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704215658526.png" alt="image-20220704215658526"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=&#x27;123&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704215721216.png" alt="image-20220704215721216"></p>
<p>name=123发生类型转换，索引失效。</p>
<h3 id="2-6-范围条件右边的列索引失效"><a href="#2-6-范围条件右边的列索引失效" class="headerlink" title="2.6 范围条件右边的列索引失效"></a>2.6 范围条件右边的列索引失效</h3><ol>
<li>系统经常出现的sql如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student DROP INDEX idx_name;</span><br><span class="line">ALTER TABLE student DROP INDEX idx_age;</span><br><span class="line">ALTER TABLE student DROP INDEX idx_age_classid;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student</span><br><span class="line">WHERE student.age=30 AND student.classId&gt;20 AND student.name = &#x27;abc&#x27; ;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704220123647.png" alt="image-20220704220123647"></p>
<ol>
<li>那么索引 idx_age_classId_name 这个索引还能正常使用么？</li>
</ol>
<ul>
<li>不能，范围右边的列不能使用。比如：(&lt;) (&lt;=) (&gt;) (&gt;=) 和 between 等</li>
<li>如果这种sql出现较多，应该建立：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index idx_age_name_classId on student(age,name,classId);</span><br></pre></td></tr></table></figure>
<ul>
<li>将范围查询条件放置语句最后：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = &#x27;abc&#x27; AND student.classId&gt;20;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）</p>
</blockquote>
<ol>
<li>效果</li>
</ol>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704223211981.png" alt="image-20220704223211981"></p>
<h3 id="2-7-不等于-或者-lt-gt-索引失效"><a href="#2-7-不等于-或者-lt-gt-索引失效" class="headerlink" title="2.7 不等于(!= 或者&lt;&gt;)索引失效"></a>2.7 不等于(!= 或者&lt;&gt;)索引失效</h3><ul>
<li>为name字段创建索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_name ON student(NAME);</span><br></pre></td></tr></table></figure>
<ul>
<li>查看索引是否失效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name &lt;&gt; &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704224552374.png" alt="image-20220704224552374"></p>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name != &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704224916117.png" alt="image-20220704224916117"></p>
<p>场景举例：用户提出需求，将财务数据，产品利润金额不等于0的都统计出来。</p>
<h3 id="2-8-is-null可以使用索引，is-not-null无法使用索引"><a href="#2-8-is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="2.8 is null可以使用索引，is not null无法使用索引"></a>2.8 is null可以使用索引，is not null无法使用索引</h3><ul>
<li>IS NULL: 可以触发索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NULL;</span><br></pre></td></tr></table></figure>
<ul>
<li>IS NOT NULL: 无法触发索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NOT NULL;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220704225333199.png" alt="image-20220704225333199"></p>
<blockquote>
<p>结论：最好在设计数据库的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将 INT 类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)。</p>
<p>扩展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描。</p>
</blockquote>
<h3 id="2-9-like以通配符-开头索引失效"><a href="#2-9-like以通配符-开头索引失效" class="headerlink" title="2.9 like以通配符%开头索引失效"></a>2.9 like以通配符%开头索引失效</h3><p>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为’%’，索引就不会起作用。只有’%’不在第一个位置，索引才会起作用。</p>
<ul>
<li>使用到索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name LIKE &#x27;ab%&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705131643304.png" alt="image-20220705131643304"></p>
<ul>
<li>未使用到索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name LIKE &#x27;%ab%&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705131717329.png" alt="image-20220705131717329"></p>
<blockquote>
<p>拓展：Alibaba《Java开发手册》 </p>
<p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p>
</blockquote>
<h3 id="2-10-OR-前后存在非索引的列，索引失效"><a href="#2-10-OR-前后存在非索引的列，索引失效" class="headerlink" title="2.10 OR 前后存在非索引的列，索引失效"></a>2.10 OR 前后存在非索引的列，索引失效</h3><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，<strong>OR前后的两个条件中的列都是索引时，查询中才使用索引。</strong></p>
<p>因为OR的含义就是两个只要满足一个即可，因此<code>只有一个条件列进行了索引是没有意义的</code>，只要有条件列没有进行索引，就会进行<code>全表扫描</code>，因此所以的条件列也会失效。</p>
<p>查询语句使用OR关键字的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705132221045.png" alt="image-20220705132221045"></p>
<p>因为classId字段上没有索引，所以上述查询语句没有使用索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR name = &#x27;Abel&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705132239232.png" alt="image-20220705132239232"></p>
<p>因为age字段和name字段上都有索引，所以查询中使用了索引。你能看到这里使用到了<code>index_merge</code>，简单来说index_merge就是对age和name分别进行了扫描，然后将这两个结果集进行了合并。这样做的好处就是<code>避免了全表扫描</code>。</p>
<h3 id="2-11-数据库和表的字符集统一使用utf8mb4"><a href="#2-11-数据库和表的字符集统一使用utf8mb4" class="headerlink" title="2.11 数据库和表的字符集统一使用utf8mb4"></a>2.11 数据库和表的字符集统一使用utf8mb4</h3><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不 同的 <code>字符集</code> 进行比较前需要进行 <code>转换</code> 会造成索引失效。</p>
<h3 id="2-12-练习及一般性建议"><a href="#2-12-练习及一般性建议" class="headerlink" title="2.12 练习及一般性建议"></a>2.12 练习及一般性建议</h3><p><strong>练习：</strong>假设：index(a,b,c)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Where语句</th>
<th>索引是否被使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>where a= 3</td>
<td>Y,使用到a</td>
</tr>
<tr>
<td>where a= 3 and b= 5</td>
<td>Y,使用到a,b</td>
</tr>
<tr>
<td>where a= 3 and b=5 and c= 4</td>
<td>Y,使用到a,b,c</td>
</tr>
<tr>
<td>where b= 3或者where b= 3 and c= 4或者where c= 4</td>
<td>N</td>
</tr>
<tr>
<td>where a= 3 and c=5</td>
<td>使用到a，但是c不可以，b中间断了</td>
</tr>
<tr>
<td>where a = 3 and b &gt; 4 and c= 5</td>
<td>使用到a和b，c不能用在范围之后，b断了</td>
</tr>
<tr>
<td>where a is null and b is not null</td>
<td>is null支持索引 但是is not null不支持。所以a可以使用索引，但是b不可以使用</td>
</tr>
<tr>
<td>where a &lt;&gt;3</td>
<td>不能使用索引</td>
</tr>
<tr>
<td>where abs(a) =3</td>
<td>不能使用索引</td>
</tr>
<tr>
<td><code>where a = 3 and b like &#39;kk%&#39;’ and c=4</code></td>
<td>Y,使用到a,b,c</td>
</tr>
<tr>
<td>where a= 3 and b like ‘%kk’ and c= 4</td>
<td>Y,只用到a</td>
</tr>
<tr>
<td>where a= 3 and b like “%kk%’ and c= 4</td>
<td>Y,只用到a</td>
</tr>
<tr>
<td><code>where a = 3 and b like &#39;k%kk%&#39; and c=4</code></td>
<td>Y,使用到a,b,c</td>
</tr>
</tbody>
</table>
</div>
<p><strong>一般性建议</strong></p>
<ul>
<li>对于单列索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择能够当前query中where子句中更多的索引。</li>
<li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li>
</ul>
<p><strong>总之，书写SQL语句时，尽量避免造成索引失效的情况</strong></p>
<h2 id="3-关联查询优化"><a href="#3-关联查询优化" class="headerlink" title="3. 关联查询优化"></a>3. 关联查询优化</h2><h3 id="3-1-数据准备-1"><a href="#3-1-数据准备-1" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 分类</span><br><span class="line">CREATE TABLE IF NOT EXISTS `type` (</span><br><span class="line">`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">`card` INT(10) UNSIGNED NOT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">);</span><br><span class="line">#图书</span><br><span class="line">CREATE TABLE IF NOT EXISTS `book` (</span><br><span class="line">`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">`card` INT(10) UNSIGNED NOT NULL,</span><br><span class="line">PRIMARY KEY (`bookid`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#向分类表中添加20条记录</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO `type`(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line"></span><br><span class="line">#向图书表中添加20条记录</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br></pre></td></tr></table></figure>
<h3 id="3-2-采用左外连接"><a href="#3-2-采用左外连接" class="headerlink" title="3.2 采用左外连接"></a>3.2 采用左外连接</h3><p>下面开始 EXPLAIN 分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705160504018.png" alt="image-20220705160504018"></p>
<p>结论：type 有All</p>
<p>添加索引优化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book ADD INDEX Y ( card); #【被驱动表】，可以避免全表扫描</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705160935109.png" alt="image-20220705160935109"></p>
<p>可以看到第二行的 type 变为了 ref，rows 也变成了优化比较明显。这是由左连接特性决定的。LEFT JOIN 条件用于确定如何从右表搜索行，左边一定都有，所以 <code>右边是我们的关键点,一定需要建立索引</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `type` ADD INDEX X (card); #【驱动表】，无法避免全表扫描</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705161243838.png" alt="image-20220705161243838"></p>
<p>接着：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX Y ON book;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705161515545.png" alt="image-20220705161515545"></p>
<h3 id="3-3-采用内连接"><a href="#3-3-采用内连接" class="headerlink" title="3.3 采用内连接"></a>3.3 采用内连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop index X on type;</span><br><span class="line">drop index Y on book;（如果已经删除了可以不用再执行该操作）</span><br></pre></td></tr></table></figure>
<p>换成 inner join（MySQL自动选择驱动表）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705161602362.png" alt="image-20220705161602362"></p>
<p>添加索引优化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book ADD INDEX Y (card);</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705161746184.png" alt="image-20220705161746184"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE type ADD INDEX X (card);</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705161843558.png" alt="image-20220705161843558"></p>
<p>对于内连接来说，查询优化器可以决定谁作为驱动表，谁作为被驱动表出现的</p>
<p>接着：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX X ON `type`;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM TYPE INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705161929544.png" alt="image-20220705161929544"></p>
<p>接着：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `type` ADD INDEX X (card);</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` INNER JOIN book ON type.card=book.card;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705162009145.png" alt="image-20220705162009145"></p>
<p>接着：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#向图书表中添加20条记录</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line"></span><br><span class="line">ALTER TABLE book ADD INDEX Y (card);</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM `type` INNER JOIN book ON `type`.card = book.card;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705163833445.png" alt="image-20220705163833445"></p>
<p>图中发现，由于type表数据大于book表数据，MySQL选择将type作为被驱动表。</p>
<h3 id="3-4-join语句原理"><a href="#3-4-join语句原理" class="headerlink" title="3.4 join语句原理"></a>3.4 join语句原理</h3><p>join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是嵌套循环(Nested Loop Join)。如果关联表的数据量很大，则join关联的执行时间会很长。在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。</p>
<h4 id="1-驱动表和被驱动表"><a href="#1-驱动表和被驱动表" class="headerlink" title="1. 驱动表和被驱动表"></a>1. 驱动表和被驱动表</h4><p>驱动表就是主表，被驱动表就是从表、非驱动表。</p>
<ul>
<li>对于内连接来说：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM A JOIN B ON ...</span><br></pre></td></tr></table></figure>
<p>A一定是驱动表吗？不一定，优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过explain关键字可以查看。</p>
<ul>
<li>对于外连接来说：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM A LEFT JOIN B ON ...</span><br><span class="line"># 或</span><br><span class="line">SELECT * FROM B RIGHT JOIN A ON ... </span><br></pre></td></tr></table></figure>
<p>通常，大家会认为A就是驱动表，B就是被驱动表。但也未必。测试如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE a(f1 INT, f2 INT, INDEX(f1)) ENGINE=INNODB;</span><br><span class="line">CREATE TABLE b(f1 INT, f2 INT) ENGINE=INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO a VALUES(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);</span><br><span class="line">INSERT INTO b VALUES(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);</span><br><span class="line"></span><br><span class="line">SELECT * FROM b;</span><br><span class="line"></span><br><span class="line"># 测试1</span><br><span class="line">EXPLAIN SELECT * FROM a LEFT JOIN b ON(a.f1=b.f1) WHERE (a.f2=b.f2);</span><br><span class="line"></span><br><span class="line"># 测试2</span><br><span class="line">EXPLAIN SELECT * FROM a LEFT JOIN b ON(a.f1=b.f1) AND (a.f2=b.f2);</span><br></pre></td></tr></table></figure>
<h4 id="2-Simple-Nested-Loop-Join-简单嵌套循环连接"><a href="#2-Simple-Nested-Loop-Join-简单嵌套循环连接" class="headerlink" title="2. Simple Nested-Loop Join (简单嵌套循环连接)"></a>2. Simple Nested-Loop Join (简单嵌套循环连接)</h4><p>算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result.. 以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705165559127.png" alt="image-20220705165559127"></p>
<p>可以看到这种方式效率是非常低的，以上述表A数据100条，表B数据1000条计算，则A*B=10万次。开销统计如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
</tr>
</thead>
<tbody>
<tr>
<td>外表扫描次数:</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数:</td>
<td>A</td>
</tr>
<tr>
<td>读取记录数:</td>
<td>A+B*A</td>
</tr>
<tr>
<td>JOIN比较次数:</td>
<td>B*A</td>
</tr>
<tr>
<td>回表读取记录次数:</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>当然mysql肯定不会这么粗暴的去进行表的连接，所以就出现了后面的两种对Nested-Loop Join优化算法。</p>
<h4 id="3-Index-Nested-Loop-Join-（索引嵌套循环连接）"><a href="#3-Index-Nested-Loop-Join-（索引嵌套循环连接）" class="headerlink" title="3. Index Nested-Loop Join （索引嵌套循环连接）"></a>3. Index Nested-Loop Join （索引嵌套循环连接）</h4><p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内存表数据的匹配次数</code>，所以要求被驱动表上必须<code>有索引</code>才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内存表的每条记录去进行比较，这样极大的减少了对内存表的匹配次数。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705172315554.png" alt="image-20220705172315554"></p>
<p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
<th>INLJ</th>
</tr>
</thead>
<tbody>
<tr>
<td>外表扫描次数:</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数:</td>
<td>A</td>
<td>0</td>
</tr>
<tr>
<td>读取记录数:</td>
<td>A+B*A</td>
<td>A+B(match)</td>
</tr>
<tr>
<td>JOIN比较次数:</td>
<td>B*A</td>
<td>A*Index(Height)</td>
</tr>
<tr>
<td>回表读取记录次数:</td>
<td>0</td>
<td>B(match)(if possible)</td>
</tr>
</tbody>
</table>
</div>
<p>如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p>
<h4 id="4-Block-Nested-Loop-Join（块嵌套循环连接）"><a href="#4-Block-Nested-Loop-Join（块嵌套循环连接）" class="headerlink" title="4. Block Nested-Loop Join（块嵌套循环连接）"></a>4. Block Nested-Loop Join（块嵌套循环连接）</h4><p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，大大增加了10的次数。为了减少被驱动表的Io次数，就出现了Block Nested-Loop Join的方式。</p>
<p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了<code>join buffer</code>缓冲区，将驱动表join相关的部分数据列(大小受join buffer的限制)缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和joinbuffer中的所有驱动表记录进行匹配(内存中操作)，将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p>
<blockquote>
<p>注意：</p>
<p>这里缓存的不只是关联表的列，select后面的列也会缓存起来。</p>
<p>在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列。</p>
</blockquote>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705174005280.png" alt="image-20220705174005280"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
<th>INLJ</th>
<th>BNLJ</th>
</tr>
</thead>
<tbody>
<tr>
<td>外表扫描次数:</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数:</td>
<td>A</td>
<td>0</td>
<td>A * used_column_size / join_buffer_size+1</td>
</tr>
<tr>
<td>读取记录数:</td>
<td>A+B*A</td>
<td>A+B(match)</td>
<td>A+B <em> (A </em>  used_column_size / join_buffer_size)</td>
</tr>
<tr>
<td>JOIN比较次数:</td>
<td>B*A</td>
<td>A*Index(Height)</td>
<td>B*A</td>
</tr>
<tr>
<td>回表读取记录次数:</td>
<td>0</td>
<td>B(match)(if possible)</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>参数设置：</p>
<ul>
<li>block_nested_loop</li>
</ul>
<p>通过<code>show variables like &#39;%optimizer_switch%</code> 查看 <code>block_nested_loop</code>状态。默认是开启的。</p>
<ul>
<li>join_buffer_size</li>
</ul>
<p>驱动表能不能一次加载完，要看join buffer能不能存储所有的数据，默认情况下<code>join_buffer_size=256k</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%join_buffer%&#x27;;</span><br></pre></td></tr></table></figure>
<p>join_buffer_size的最大值在32位操作系统可以申请4G，而在64位操作系统下可以申请大于4G的Join Buffer空间（64位Windows除外，其大值会被截断为4GB并发出警告）。</p>
<h4 id="5-Join小结"><a href="#5-Join小结" class="headerlink" title="5. Join小结"></a>5. Join小结</h4><p>1、<strong>整体效率比较：INLJ &gt; BNLJ &gt; SNLJ</strong></p>
<p>2、永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）（小的度量单位指的是表行数 * 每行大小）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.b,t2.* from t1 straight_join t2 on (t1.b=t2.b) where t2.id&lt;=100; # 推荐</span><br><span class="line">select t1.b,t2.* from t2 straight_join t1 on (t1.b=t2.b) where t2.id&lt;=100; # 不推荐</span><br></pre></td></tr></table></figure>
<p>3、为被驱动表匹配的条件增加索引(减少内存表的循环匹配次数)</p>
<p>4、增大join buffer size的大小（一次索引的数据越多，那么内层包的扫描次数就越少）</p>
<p>5、减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多）</p>
<h4 id="6-Hash-Join"><a href="#6-Hash-Join" class="headerlink" title="6. Hash Join"></a>6. Hash Join</h4><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p>
<ul>
<li><p>Nested Loop:</p>
<p>对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。</p>
</li>
<li><p>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列表</code>，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p>
<ul>
<li>这种方式适合于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</li>
<li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</li>
<li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接（如WHERE A.COL1 = B.COL2），这是由Hash的特点决定的。</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>Nested Loop</th>
<th>Hash Join</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用条件</td>
<td>任何条件</td>
<td>等值连接(=)</td>
</tr>
<tr>
<td>相关资源</td>
<td>CPU、磁盘I/O</td>
<td>内存、临时空间</td>
</tr>
<tr>
<td>特点</td>
<td>当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果</td>
<td>当缺乏索引或者索引条件模糊时，Hash Join比Nested Loop有效。在数据仓库环境下，如果表的纪录数多，效率高</td>
</tr>
<tr>
<td>缺点</td>
<td>当索引丢失或者查询条件限制不够时，效率很低；当表的记录数多时，效率低</td>
<td>为建立哈希表，需要大量内存。第一次的结果返回较慢。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><ul>
<li>保证被驱动表的JOIN字段已经创建了索引 </li>
<li>需要JOIN 的字段，数据类型保持绝对一致。 </li>
<li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。 </li>
<li>INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。 </li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数) </li>
<li>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。 </li>
<li>衍生表建不了索引</li>
</ul>
<h2 id="4-子查询优化"><a href="#4-子查询优化" class="headerlink" title="4. 子查询优化"></a>4. 子查询优化</h2><p>MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结 果作为另一个SELECT语句的条件。 <code>子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作</code> 。</p>
<p><strong>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子 查询的执行效率不高。</strong>原因：</p>
<p>① 执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表 中查询记录。查询完毕后，再 撤销这些临时表 。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p>
<p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会 受到一定的影响。</p>
<p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
<p><strong>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</strong>连接查询 <code>不需要建立临时表</code> ，其 <code>速度比子查询</code> 要快 ，如果查询中使用索引的话，性能就会更好。</p>
<p>举例1：查询学生表中是班长的学生信息</p>
<ul>
<li>使用子查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建班级表中班长的索引</span><br><span class="line">CREATE INDEX idx_monitor ON class(monitor);</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM student stu1</span><br><span class="line">WHERE stu1.`stuno` IN (</span><br><span class="line">SELECT monitor</span><br><span class="line">FROM class c</span><br><span class="line">WHERE monitor IS NOT NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>推荐使用多表查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT stu1.* FROM student stu1 JOIN class c</span><br><span class="line">ON stu1.`stuno` = c.`monitor`</span><br><span class="line">WHERE c.`monitor` is NOT NULL;</span><br></pre></td></tr></table></figure>
<p>举例2：取所有不为班长的同学</p>
<ul>
<li>不推荐</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE a.*</span><br><span class="line">FROM student a</span><br><span class="line">WHERE a.stuno NOT IN (</span><br><span class="line">	SELECT monitor FROM class b</span><br><span class="line">    WHERE monitor IS NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705210708343.png" alt="image-20220705210708343"></p>
<ul>
<li>推荐：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE a.*</span><br><span class="line">FROM student a LEFT OUTER JOIN class b</span><br><span class="line">ON a.stuno = b.monitor</span><br><span class="line">WHERE b.monitor IS NULL;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705210839437.png" alt="image-20220705210839437"></p>
<blockquote>
<p>结论：尽量不要使用NOT IN或者NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p>
</blockquote>
<h2 id="5-排序优化"><a href="#5-排序优化" class="headerlink" title="5. 排序优化"></a>5. 排序优化</h2><h3 id="5-1-排序优化"><a href="#5-1-排序优化" class="headerlink" title="5.1 排序优化"></a>5.1 排序优化</h3><p><strong>问题</strong>：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？</p>
<p><strong>回答：</strong></p>
<p>在MySQL中，支持两种排序方式，分别是 <code>FileSort</code> 和 <code>Index</code> 排序。</p>
<ul>
<li>Index 排序中，索引可以保证数据的有序性，不需要再进行排序，<code>效率更高</code>。</li>
<li>FileSort 排序则一般在 <code>内存中</code> 进行排序，占用<code>CPU较多</code>。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率较低。</li>
</ul>
<p><strong>优化建议：</strong></p>
<ol>
<li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code> ，在 ORDER BY 子句 <code>避免使用 FileSort 排序</code> 。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。 </li>
<li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。 </li>
<li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li>
</ol>
<h3 id="5-2-测试"><a href="#5-2-测试" class="headerlink" title="5.2 测试"></a>5.2 测试</h3><p>删除student表和class表中已创建的索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 方式1</span><br><span class="line">DROP INDEX idx_monitor ON class;</span><br><span class="line">DROP INDEX idx_cid ON student;</span><br><span class="line">DROP INDEX idx_age ON student;</span><br><span class="line">DROP INDEX idx_name ON student;</span><br><span class="line">DROP INDEX idx_age_name_classId ON student;</span><br><span class="line">DROP INDEX idx_age_classId_name ON student;</span><br><span class="line"></span><br><span class="line"># 方式2</span><br><span class="line">call proc_drop_index(&#x27;atguigudb2&#x27;,&#x27;student&#x27;;)</span><br></pre></td></tr></table></figure>
<p>以下是否能使用到索引，<code>能否去掉using filesort</code></p>
<p><strong>过程一：</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705215436102.png" alt="image-20220705215436102"></p>
<p><strong>过程二： order by 时不limit,索引失效</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705215909350.png" alt="image-20220705215909350"></p>
<p><strong>过程三：order by 时顺序错误，索引失效</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705220033520.png" alt="image-20220705220033520" style="zoom:80%;float:left"></p>
<p><strong>过程四：order by 时规则不一致，索引失效（顺序错，不索引；方向反，不索引）</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705220404802.png" alt="image-20220705220404802" style="zoom:80%;float:left"></p>
<blockquote>
<p>结论：ORDER BY 子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</p>
</blockquote>
<p><strong>过程五：无过滤，不索引</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705221212879.png" alt="image-20220705221212879" style="zoom:80%;float:left"></p>
<p><strong>小结</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line">order by 能使用索引最左前缀</span><br><span class="line">- ORDER BY a</span><br><span class="line">- ORDER BY a,b</span><br><span class="line">- ORDER BY a,b,c</span><br><span class="line">- ORDER BY a DESC,b DESC,c DESC</span><br><span class="line">如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b = const ORDER BY c</span><br><span class="line">- WHERE a = const ORDER BY b,c</span><br><span class="line">- WHERE a = const AND b &gt; const ORDER BY b,c</span><br><span class="line">不能使用索引进行排序</span><br><span class="line">- ORDER BY a ASC,b DESC,c DESC /* 排序不一致 */</span><br><span class="line">- WHERE g = const ORDER BY b,c /*丢失a索引*/</span><br><span class="line">- WHERE a = const ORDER BY c /*丢失b索引*/</span><br><span class="line">- WHERE a = const ORDER BY a,d /*d不是索引的一部分*/</span><br><span class="line">- WHERE a in (...) ORDER BY b,c /*对于排序来说，多个相等条件也是范围查询*/</span><br></pre></td></tr></table></figure>
<h3 id="5-3-案例实战"><a href="#5-3-案例实战" class="headerlink" title="5.3 案例实战"></a>5.3 案例实战</h3><p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序。 </p>
<p>执行案例前先清除student上的索引，只留主键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX idx_age ON student;</span><br><span class="line">DROP INDEX idx_age_classid_stuno ON student;</span><br><span class="line">DROP INDEX idx_age_classid_name ON student;</span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line">call proc_drop_index(&#x27;atguigudb2&#x27;,&#x27;student&#x27;);</span><br></pre></td></tr></table></figure>
<p><strong>场景:查询年龄为30岁的，且学生编号小于101000的学生，按用户名称排序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME ;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705222027812.png" alt="image-20220705222027812"></p>
<p>查询结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME;</span><br><span class="line">+---------+--------+--------+------+---------+</span><br><span class="line">| id      | stuno  |  name  | age  | classId |</span><br><span class="line">+---------+--------+--------+------+---------+</span><br><span class="line">| 922     | 100923 | elTLXD | 30   | 249     |</span><br><span class="line">| 3723263 | 100412 | hKcjLb | 30   | 59      |</span><br><span class="line">| 3724152 | 100827 | iHLJmh | 30   | 387     |</span><br><span class="line">| 3724030 | 100776 | LgxWoD | 30   | 253     |</span><br><span class="line">| 30      | 100031 | LZMOIa | 30   | 97      |</span><br><span class="line">| 3722887 | 100237 | QzbJdx | 30   | 440     |</span><br><span class="line">| 609     | 100610 | vbRimN | 30   | 481     |</span><br><span class="line">| 139     | 100140 | ZqFbuR | 30   | 351     |</span><br><span class="line">+---------+--------+--------+------+---------+</span><br><span class="line">8 rows in set, 1 warning (3.16 sec)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论：type 是 ALL，即最坏的情况。Extra 里还出现了 Using filesort,也是最坏的情况。优化是必须的。</p>
</blockquote>
<p><strong>方案一: 为了去掉filesort我们可以把索引建成</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建新索引</span><br><span class="line">CREATE INDEX idx_age_name ON student(age,NAME);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705222912521.png" alt="image-20220705222912521"></p>
<p>这样我们优化掉了 using filesort</p>
<p>查询结果如下：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705222954971.png" alt="image-20220705222954971" style="float:left;"></p>
<p><strong>方案二：尽量让where的过滤条件和排序使用上索引</strong></p>
<p>建一个三个字段的组合索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX idx_age_name ON student;</span><br><span class="line">CREATE INDEX idx_age_stuno_name ON student (age,stuno,NAME);</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705223111883.png" alt="image-20220705223111883"></p>
<p>我们发现using filesort依然存在，所以name并没有用到索引，而且type还是range光看名字其实并不美好。原因是，因为<code>stuno是一个范围过滤</code>，所以索引后面的字段不会在使用索引了 。</p>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student</span><br><span class="line">-&gt; WHERE age = 30 AND stuno &lt;101000 ORDER BY NAME ;</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">| id | stuno | name | age | classId |</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">| 167 | 100168 | AClxEF | 30 | 319 |</span><br><span class="line">| 323 | 100324 | bwbTpQ | 30 | 654 |</span><br><span class="line">| 651 | 100652 | DRwIac | 30 | 997 |</span><br><span class="line">| 517 | 100518 | HNSYqJ | 30 | 256 |</span><br><span class="line">| 344 | 100345 | JuepiX | 30 | 329 |</span><br><span class="line">| 905 | 100906 | JuWALd | 30 | 892 |</span><br><span class="line">| 574 | 100575 | kbyqjX | 30 | 260 |</span><br><span class="line">| 703 | 100704 | KJbprS | 30 | 594 |</span><br><span class="line">| 723 | 100724 | OTdJkY | 30 | 236 |</span><br><span class="line">| 656 | 100657 | Pfgqmj | 30 | 600 |</span><br><span class="line">| 982 | 100983 | qywLqw | 30 | 837 |</span><br><span class="line">| 468 | 100469 | sLEKQW | 30 | 346 |</span><br><span class="line">| 988 | 100989 | UBYqJl | 30 | 457 |</span><br><span class="line">| 173 | 100174 | UltkTN | 30 | 830 |</span><br><span class="line">| 332 | 100333 | YjWiZw | 30 | 824 |</span><br><span class="line">+-----+--------+--------+------+---------+</span><br><span class="line">15 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>结果竟然有 filesort的 sql 运行速度， 超过了已经优化掉 filesort的 sql ，而且快了很多，几乎一瞬间就出现了结果。</p>
<p>原因：</p>
<p>所有的排序都是在条件过滤之后才执行的。所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。相对的stuno&lt;101000这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。</p>
<blockquote>
<p>结论：</p>
<ol>
<li>两个索引同时存在，mysql自动选择最优的方案。（对于这个例子，mysql选择 idx_age_stuno_name）。但是， <code>随着数据量的变化，选择的索引也会随之变化的</code>。 </li>
<li><strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过 滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</strong></li>
</ol>
</blockquote>
<p>思考：这里我们使用如下索引，是否可行？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX idx_age_stuno_name ON student;</span><br><span class="line"></span><br><span class="line">CREATE INDEX idx_age_stuno ON student(age,stuno);</span><br></pre></td></tr></table></figure>
<p>当然可以。</p>
<h3 id="5-4-filesort算法：双路排序和单路排序"><a href="#5-4-filesort算法：双路排序和单路排序" class="headerlink" title="5.4 filesort算法：双路排序和单路排序"></a>5.4 filesort算法：双路排序和单路排序</h3><p>排序的字段若不在索引列上，则filesort会有两种算法：双路排序和单路排序</p>
<p><strong>双路排序 （慢）</strong></p>
<ul>
<li>MySQL 4.1之前是使用双路排序 ，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 order by列 ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出 </li>
<li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段 。</li>
</ul>
<p>取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种 改进的算法，就是单路排序。</p>
<p><strong>单路排序 （快）</strong></p>
<p>从磁盘读取查询需要的 所有列 ，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p>
<p><strong>结论及引申出的问题</strong></p>
<ul>
<li>由于单路是后出的，总体而言好过双路 </li>
<li>但是用单路有问题<ul>
<li>在sort_buffer中，单路要比多路多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了<code>sort_buffer</code>的容量，导致每次只能取<code>sort_buffer</code>容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排…从而多次I/O。</li>
<li>单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</li>
</ul>
</li>
</ul>
<p><strong>优化策略</strong></p>
<p><strong>1. 尝试提高 sort_buffer_size</strong></p>
<ul>
<li>不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程(connection)的1M-8M之间调整。MySQL5.7，InnoDB存储引擎默认值是1048576字节，1MB。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%sort_buffer_size%&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705224410340.png" alt="image-20220705224410340" style="zoom:80%;float:center"></p>
<p><strong>2. 尝试提高 max_length_for_sort_data</strong></p>
<ul>
<li>提高这个参数，会增加用改进算法的概率。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%sort_buffer_size%&#x27;; #默认1024字节</span><br></pre></td></tr></table></figure>
<ul>
<li>但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。如果需要返回的列的总长度大于max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整</li>
</ul>
<p><strong>3. Order by 时select * 是一个大忌。最好只Query需要的字段。</strong></p>
<ul>
<li>当Query的字段大小总和小于<code>max_length_for_sort_data</code>，而且排序字段不是TEXTIBLOB类型时，会用改进后的算法――单路排序，否则用老算法―-多路排序。</li>
<li>两种算法的数据都有可能超出sort_buffer_size的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/o，但是用单路排序算法的风险会更大一些，所以要<code>提高sort_buffer_size</code>。</li>
</ul>
<h2 id="6-GROUP-BY优化"><a href="#6-GROUP-BY优化" class="headerlink" title="6. GROUP BY优化"></a>6. GROUP BY优化</h2><ul>
<li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。 </li>
<li>group by 先排序再分组，遵照索引建的最佳左前缀法则 </li>
<li>当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置 </li>
<li>where效率高于having，能写在where限定的条件就不要写在having中了 </li>
<li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。 </li>
<li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢。</li>
</ul>
<h2 id="7-优化分页查询"><a href="#7-优化分页查询" class="headerlink" title="7. 优化分页查询"></a>7. 优化分页查询</h2><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705225329130.png" alt="image-20220705225329130" style="float:left;"></p>
<p><strong>优化思路一</strong></p>
<p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a WHERE t.id = a.id;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705225625166.png" alt="image-20220705225625166"></p>
<p><strong>优化思路二</strong></p>
<p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220705225654124.png" alt="image-20220705225654124"></p>
<h2 id="8-优先考虑覆盖索引"><a href="#8-优先考虑覆盖索引" class="headerlink" title="8. 优先考虑覆盖索引"></a>8. 优先考虑覆盖索引</h2><h3 id="8-1-什么是覆盖索引？"><a href="#8-1-什么是覆盖索引？" class="headerlink" title="8.1 什么是覆盖索引？"></a>8.1 什么是覆盖索引？</h3><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引</strong>。</p>
<p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列 （即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p>
<p>简单说就是， <code>索引列+主键</code> 包含 <code>SELECT 到 FROM之间查询的列</code> 。</p>
<p><strong>举例一：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除之前的索引</span><br><span class="line">DROP INDEX idx_age_stuno ON student;</span><br><span class="line">CREATE INDEX idx_age_name ON student(age, NAME);</span><br><span class="line">EXPLAIN SELECT * FROM student WHERE age &lt;&gt; 20;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706124528680.png" alt="image-20220706124528680"></p>
<p><strong>举例二：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE NAME LIKE &#x27;%abc&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706124612180.png" alt="image-20220706124612180"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_age_name ON student(age, NAME);</span><br><span class="line">EXPLAIN SELECT id,age,NAME FROM student WHERE NAME LIKE &#x27;%abc&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706125113658.png" alt="image-20220706125113658"></p>
<p>上述都使用到了声明的索引，下面的情况则不然，查询列依然多了classId,结果是未使用到索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id,age,NAME,classId FROM student WHERE NAME LIKE &#x27;%abc&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706125351116.png" alt="image-20220706125351116"></p>
<h3 id="8-2-覆盖索引的利弊"><a href="#8-2-覆盖索引的利弊" class="headerlink" title="8.2 覆盖索引的利弊"></a>8.2 覆盖索引的利弊</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706125943936.png" alt="image-20220706125943936" style="zoom:80%;float:left"></p>
<h2 id="9-如何给字符串添加索引"><a href="#9-如何给字符串添加索引" class="headerlink" title="9. 如何给字符串添加索引"></a>9. 如何给字符串添加索引</h2><p>有一张教师表，表定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table teacher(</span><br><span class="line">ID bigint unsigned primary key,</span><br><span class="line">email varchar(64),</span><br><span class="line">...</span><br><span class="line">)engine=innodb;</span><br></pre></td></tr></table></figure>
<p>讲师要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select col1, col2 from teacher where email=&#x27;xxx&#x27;;</span><br></pre></td></tr></table></figure>
<p>如果email这个字段上没有索引，那么这个语句就只能做 <code>全表扫描</code> 。</p>
<h3 id="9-1-前缀索引"><a href="#9-1-前缀索引" class="headerlink" title="9.1 前缀索引"></a>9.1 前缀索引</h3><p>MySQL是支持前缀索引的。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字 符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table teacher add index index1(email);</span><br><span class="line">#或</span><br><span class="line">mysql&gt; alter table teacher add index index2(email(6));</span><br></pre></td></tr></table></figure>
<p>这两种不同的定义在数据结构和存储上有什么区别呢？下图就是这两个索引的示意图。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706130901307.png" alt="image-20220706130901307"></p>
<p>以及</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706130921934.png" alt="image-20220706130921934" style="zoom:70%;"></p>
<p><strong>如果使用的是index1</strong>（即email整个字符串的索引结构），执行顺序是这样的：</p>
<ol>
<li>从index1索引树找到满足索引值是’ zhangssxyz@xxx.com’的这条记录，取得ID2的值； </li>
<li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集； </li>
<li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=’ zhangssxyz@xxx.com ’的 条件了，循环结束。</li>
</ol>
<p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p>
<p><strong>如果使用的是index2</strong>（即email(6)索引结构），执行顺序是这样的：</p>
<ol>
<li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1； </li>
<li>到主键上查到主键值是ID1的行，判断出email的值不是’ zhangssxyz@xxx.com ’，这行记录丢弃； </li>
<li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然 后判断，这次值对了，将这行记录加入结果集； </li>
<li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li>
</ol>
<p>也就是说<strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong>前面 已经讲过区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p>
<h3 id="9-2-前缀索引对覆盖索引的影响"><a href="#9-2-前缀索引对覆盖索引的影响" class="headerlink" title="9.2 前缀索引对覆盖索引的影响"></a>9.2 前缀索引对覆盖索引的影响</h3><blockquote>
<p>结论： 使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p>
</blockquote>
<h2 id="10-索引下推"><a href="#10-索引下推" class="headerlink" title="10. 索引下推"></a>10. 索引下推</h2><h3 id="10-1-使用前后对比"><a href="#10-1-使用前后对比" class="headerlink" title="10.1 使用前后对比"></a>10.1 使用前后对比</h3><p>Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706131320477.png" alt="image-20220706131320477" style="zoom:80%;float:left"></p>
<h3 id="10-2-ICP的开启-关闭"><a href="#10-2-ICP的开启-关闭" class="headerlink" title="10.2 ICP的开启/关闭"></a>10.2 ICP的开启/关闭</h3><ul>
<li>默认情况下启动索引条件下推。可以通过设置系统变量<code>optimizer_switch</code>控制：<code>index_condition_pushdown</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打开索引下推</span><br><span class="line">SET optimizer_switch = &#x27;index_condition_pushdown=on&#x27;;</span><br><span class="line"></span><br><span class="line"># 关闭索引下推</span><br><span class="line">SET optimizer_switch = &#x27;index_condition_pushdown=off&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>当使用索引条件下推是，<code>EXPLAIN</code>语句输出结果中<code>Extra</code>列内容显示为<code>Using index condition</code>。</li>
</ul>
<h3 id="10-3-ICP使用案例"><a href="#10-3-ICP使用案例" class="headerlink" title="10.3 ICP使用案例"></a>10.3 ICP使用案例</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706135436316.png" alt="image-20220706135436316" style="zoom:80%;float:left"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706135506409.png" alt="image-20220706135506409" style="zoom:80%;float:left"></p>
<ul>
<li>主键索引 (简图)</li>
</ul>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706135633814.png" alt="image-20220706135633814"></p>
<p>二级索引zip_last_first (简图，这里省略了数据页等信息)</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706135701187.png" alt="image-20220706135701187"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706135723203.png" alt="image-20220706135723203" style="zoom:80%;float:left"></p>
<h3 id="10-4-开启和关闭ICP性能对比"><a href="#10-4-开启和关闭ICP性能对比" class="headerlink" title="10.4 开启和关闭ICP性能对比"></a>10.4 开启和关闭ICP性能对比</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706135904713.png" alt="image-20220706135904713" style="zoom:80%;float:left"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706140213382.png" alt="image-20220706140213382" style="zoom:80%;float:left"></p>
<h3 id="10-5-ICP的使用条件"><a href="#10-5-ICP的使用条件" class="headerlink" title="10.5 ICP的使用条件"></a>10.5 ICP的使用条件</h3><ol>
<li>如果表的访问类型为 range 、 ref 、 eq_ref 或者 ref_or_null 可以使用ICP。</li>
<li>ICP可以使用<code>InnDB</code>和<code>MyISAM</code>表，包括分区表<code>InnoDB</code>和<code>MyISAM</code>表</li>
<li>对于<code>InnoDB</code>表，ICP仅用于<code>二级索引</code>。ICP的目标是减少全行读取次数，从而减少I/O操作。</li>
<li>当SQL使用覆盖索引时，不支持ICP优化方法。因为这种情况下使用ICP不会减少I/O。</li>
<li>相关子查询的条件不能使用ICP</li>
</ol>
<h2 id="11-普通索引-vs-唯一索引"><a href="#11-普通索引-vs-唯一索引" class="headerlink" title="11. 普通索引 vs 唯一索引"></a>11. 普通索引 vs 唯一索引</h2><p>从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么呢？</p>
<p>假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引，假设字段 k 上的值都不重复。</p>
<p>这个表的建表语句是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table test(</span><br><span class="line">id int primary key,</span><br><span class="line">k int not null,</span><br><span class="line">name varchar(16),</span><br><span class="line">index (k)</span><br><span class="line">)engine=InnoDB;</span><br></pre></td></tr></table></figure>
<p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)。</p>
<h3 id="11-1-查询过程"><a href="#11-1-查询过程" class="headerlink" title="11.1 查询过程"></a>11.1 查询过程</h3><p>假设，执行查询的语句是 select id from test where k=5。</p>
<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一 个不满足k=5条件的记录。 </li>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检 索。</li>
</ul>
<p>那么，这个不同带来的性能差距会有多少呢？答案是， 微乎其微 。</p>
<h3 id="11-2-更新过程"><a href="#11-2-更新过程" class="headerlink" title="11.2 更新过程"></a>11.2 更新过程</h3><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，介绍一下change buffer。</p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下， <code>InooDB会将这些更新操作缓存在change buffer中</code> ，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge 。除了 <code>访问这个数据页</code> 会触 发merge外，系统有 <code>后台线程会定期</code> merge。在 <code>数据库正常关闭（shutdown）</code> 的过程中，也会执行merge 操作。</p>
<p>如果能够将更新操作先记录在change buffer， <code>减少读磁盘</code> ，语句的执行速度会得到明显的提升。而且， 数据读入内存是需要占用 buffer pool 的，所以这种方式还能够 <code>避免占用内存</code>，提高内存利用率。</p>
<p><code>唯一索引的更新就不能使用change buffer</code> ，实际上也只有普通索引可以使用。</p>
<p>如果要在这张表中插入一个新记录(4,400)的话，InnoDB的处理流程是怎样的？</p>
<h3 id="11-3-change-buffer的使用场景"><a href="#11-3-change-buffer的使用场景" class="headerlink" title="11.3 change buffer的使用场景"></a>11.3 change buffer的使用场景</h3><ol>
<li>普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是 对 更新性能 的影响。所以，建议你 尽量选择普通索引 。 </li>
<li>在实际使用中会发现， 普通索引 和 change buffer 的配合使用，对于 数据量大 的表的更新优化 还是很明显的。 </li>
<li>如果所有的更新后面，都马上 伴随着对这个记录的查询 ，那么你应该 关闭change buffer 。而在 其他情况下，change buffer都能提升更新性能。 </li>
<li>由于唯一索引用不上change buffer的优化机制，因此如果 业务可以接受 ，从性能角度出发建议优 先考虑非唯一索引。但是如果”业务可能无法确保”的情况下，怎么处理呢？ <ul>
<li>首先， 业务正确性优先 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能 问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。 这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一 个排查思路。 </li>
<li>然后，在一些“ 归档库 ”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年， 然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率， 可以考虑把表里面的唯一索引改成普通索引。</li>
</ul>
</li>
</ol>
<h2 id="12-其它查询优化策略"><a href="#12-其它查询优化策略" class="headerlink" title="12. 其它查询优化策略"></a>12. 其它查询优化策略</h2><h3 id="12-1-EXISTS-和-IN-的区分"><a href="#12-1-EXISTS-和-IN-的区分" class="headerlink" title="12.1 EXISTS 和 IN 的区分"></a>12.1 EXISTS 和 IN 的区分</h3><p><strong>问题：</strong></p>
<p>不太理解哪种情况下应该使用 EXISTS，哪种情况应该用 IN。选择的标准是看能否使用表的索引吗？</p>
<p><strong>回答：</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706141957185.png" alt="image-20220706141957185" style="zoom:80%;float:left"></p>
<h3 id="12-2-COUNT-与COUNT-具体字段-效率"><a href="#12-2-COUNT-与COUNT-具体字段-效率" class="headerlink" title="12.2 COUNT(*)与COUNT(具体字段)效率"></a>12.2 COUNT(*)与COUNT(具体字段)效率</h3><p>问：在 MySQL 中统计数据表的行数，可以使用三种方式： SELECT COUNT(*) 、 SELECT COUNT(1) 和 SELECT COUNT(具体字段) ，使用这三者之间的查询效率是怎样的？</p>
<p>答：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706142648452.png" alt="image-20220706142648452" style="zoom:80%;float:left"></p>
<h3 id="12-3-关于SELECT"><a href="#12-3-关于SELECT" class="headerlink" title="12.3 关于SELECT(*)"></a>12.3 关于SELECT(*)</h3><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因： </p>
<p>① MySQL 在解析的过程中，会通过查询数据字典 将”*”按序转换成所有列名，这会大大的耗费资源和时间。 </p>
<p>② 无法使用 覆盖索引</p>
<h3 id="12-4-LIMIT-1-对优化的影响"><a href="#12-4-LIMIT-1-对优化的影响" class="headerlink" title="12.4 LIMIT 1 对优化的影响"></a>12.4 LIMIT 1 对优化的影响</h3><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p>
<p> 如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。</p>
<h3 id="12-5-多使用COMMIT"><a href="#12-5-多使用COMMIT" class="headerlink" title="12.5 多使用COMMIT"></a>12.5 多使用COMMIT</h3><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放 的资源而减少。</p>
<p>COMMIT 所释放的资源： </p>
<ul>
<li>回滚段上用于恢复数据的信息 </li>
<li>被程序语句获得的锁 </li>
<li>redo / undo log buffer 中的空间 </li>
<li>管理上述 3 种资源中的内部花费</li>
</ul>
<h2 id="13-淘宝数据库，主键如何设计的？"><a href="#13-淘宝数据库，主键如何设计的？" class="headerlink" title="13. 淘宝数据库，主键如何设计的？"></a>13. 淘宝数据库，主键如何设计的？</h2><p>聊一个实际问题：淘宝的数据库，主键是如何设计的？</p>
<p>某些错的离谱的答案还在网上年复一年的流传着，甚至还成为了所谓的MySQL军规。其中，一个最明显的错误就是关于MySQL的主键设计。</p>
<p>大部分人的回答如此自信：用8字节的 BIGINT 做主键，而不要用INT。 <code>错</code>！</p>
<p>这样的回答，只站在了数据库这一层，而没有 <code>从业务的角度</code> 思考主键。主键就是一个自增ID吗？站在 2022年的新年档口，用自增做主键，架构设计上可能 <code>连及格都拿不到</code> 。</p>
<h3 id="13-1-自增ID的问题"><a href="#13-1-自增ID的问题" class="headerlink" title="13.1 自增ID的问题"></a>13.1 自增ID的问题</h3><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除 了简单，其他都是缺点，总体来看存在以下几方面的问题：</p>
<ol>
<li><p><strong>可靠性不高</strong></p>
<p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。 </p>
</li>
<li><p><strong>安全性不高 </strong></p>
<p>对外暴露的接口可以非常容易猜测对应的信息。比如：/User/1/这样的接口，可以非常容易猜测用户ID的 值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。 </p>
</li>
<li><p><strong>性能差</strong> </p>
<p>自增ID的性能较差，需要在数据库服务器端生成。 </p>
</li>
<li><p><strong>交互多</strong> </p>
<p>业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的 网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。 </p>
</li>
<li><p><strong>局部唯一性 </strong></p>
<p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都 是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p>
</li>
</ol>
<h3 id="13-2-业务字段做主键"><a href="#13-2-业务字段做主键" class="headerlink" title="13.2 业务字段做主键"></a>13.2 业务字段做主键</h3><p>为了能够唯一地标识一个会员的信息，需要为 会员信息表 设置一个主键。那么，怎么为这个表设置主 键，才能达到我们理想的目标呢？ 这里我们考虑业务字段做主键。</p>
<p>表数据如下：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706151506580.png" alt="image-20220706151506580"></p>
<p>在这个表里，哪个字段比较合适呢？</p>
<ul>
<li><strong>选择卡号（cardno）</strong></li>
</ul>
<p>会员卡号（cardno）看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来 标识一条会员 记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE demo.membermaster</span><br><span class="line">-&gt; (</span><br><span class="line">-&gt; cardno CHAR(8) PRIMARY KEY, -- 会员卡号为主键</span><br><span class="line">-&gt; membername TEXT,</span><br><span class="line">-&gt; memberphone TEXT,</span><br><span class="line">-&gt; memberpid TEXT,</span><br><span class="line">-&gt; memberaddress TEXT,</span><br><span class="line">-&gt; sex TEXT,</span><br><span class="line">-&gt; birthday DATETIME</span><br><span class="line">-&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br></pre></td></tr></table></figure>
<p>不同的会员卡号对应不同的会员，字段“cardno”唯一地标识某一个会员。如果都是这样，会员卡号与会 员一一对应，系统是可以正常运行的。</p>
<p>但实际情况是， 会员卡号可能存在重复使用 的情况。比如，张三因为工作变动搬离了原来的地址，不再 到商家的门店消费了 （退还了会员卡），于是张三就不再是这个商家门店的会员了。但是，商家不想让 这个会 员卡空着，就把卡号是“10000001”的会员卡发给了王五。</p>
<p>从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是“10000001”这个会员 信息，并不会影 响到数据一致性。也就是说，修改会员卡号是“10000001”的会员信息， 系统的各个模块，都会获取到修 改后的会员信息，不会出现“有的模块获取到修改之前的会员信息，有的模块获取到修改后的会员信息， 而导致系统内部数据不一致”的情况。因此，从 信息系统层面 上看是没问题的。</p>
<p>但是从使用 系统的业务层面 来看，就有很大的问题 了，会对商家造成影响。</p>
<p>比如，我们有一个销售流水表（trans），记录了所有的销售流水明细。2020 年 12 月 01 日，张三在门店 购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706151715106.png" alt="image-20220706151715106"></p>
<p>接着，我们查询一下 2020 年 12 月 01 日的会员销售记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line">-&gt; FROM demo.trans AS a</span><br><span class="line">-&gt; JOIN demo.membermaster AS b</span><br><span class="line">-&gt; JOIN demo.goodsmaster AS c</span><br><span class="line">-&gt; ON (a.cardno = b.cardno AND a.itemnumber=c.itemnumber);</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">| membername | goodsname | quantity | salesvalue | transdate |</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">|     张三   | 书         | 1.000    | 89.00      | 2020-12-01 00:00:00 |</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>如果会员卡“10000001”又发给了王五，我们会更改会员信息表。导致查询时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line">-&gt; FROM demo.trans AS a</span><br><span class="line">-&gt; JOIN demo.membermaster AS b</span><br><span class="line">-&gt; JOIN demo.goodsmaster AS c</span><br><span class="line">-&gt; ON (a.cardno = b.cardno AND a.itemnumber=c.itemnumber);</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">| membername | goodsname | quantity | salesvalue | transdate |</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">| 王五        | 书        | 1.000    | 89.00      | 2020-12-01 00:00:00 |</span><br><span class="line">+------------+-----------+----------+------------+---------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>这次得到的结果是：王五在 2020 年 12 月 01 日，买了一本书，消费 89 元。显然是错误的！结论：千万 不能把会员卡号当做主键。</p>
<ul>
<li><strong>选择会员电话 或 身份证号</strong></li>
</ul>
<p>会员电话可以做主键吗？不行的。在实际操作中，手机号也存在 被运营商收回 ，重新发给别人用的情况。</p>
<p>那身份证号行不行呢？好像可以。因为身份证决不会重复，身份证号与一个人存在一一对 应的关系。可 问题是，身份证号属于 个人隐私 ，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很 多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和 电话都为空的原因。</p>
<p><strong>所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测 在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。</strong></p>
<blockquote>
<p>经验： 刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业 务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p>
</blockquote>
<h3 id="13-3-淘宝的主键设计"><a href="#13-3-淘宝的主键设计" class="headerlink" title="13.3 淘宝的主键设计"></a>13.3 淘宝的主键设计</h3><p>在淘宝的电商业务中，订单服务是一个核心业务。请问， 订单表的主键 淘宝是如何设计的呢？是自增ID 吗？</p>
<p>打开淘宝，看一下订单信息：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706161436920.png" alt="image-20220706161436920"></p>
<p>从上图可以发现，订单号不是自增ID！我们详细看下上述4个订单号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1550672064762308113</span><br><span class="line">1481195847180308113</span><br><span class="line">1431156171142308113</span><br><span class="line">1431146631521308113</span><br></pre></td></tr></table></figure>
<p>订单号是19位的长度，且订单的最后5位都是一样的，都是08113。且订单号的前面14位部分是单调递增的。</p>
<p>大胆猜测，淘宝的订单ID设计应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">订单ID = 时间 + 去重字段 + 用户ID后6位尾号</span><br></pre></td></tr></table></figure>
<p>这样的设计能做到全局唯一，且对分布式系统查询及其友好。</p>
<h3 id="13-4-推荐的主键设计"><a href="#13-4-推荐的主键设计" class="headerlink" title="13.4 推荐的主键设计"></a>13.4 推荐的主键设计</h3><p><strong>非核心业务</strong> ：对应表的主键自增ID，如告警、日志、监控等信息。</p>
<p><strong>核心业务</strong> ：<code>主键设计至少应该是全局唯一且是单调递增</code>。全局唯一保证在各系统之间都是唯一的，单调 递增是希望插入时不影响数据库性能。</p>
<p>这里推荐最简单的一种主键设计：UUID。</p>
<p><strong>UUID的特点：</strong></p>
<p>全局唯一，占用36字节，数据无序，插入性能差。</p>
<p><strong>认识UUID：</strong></p>
<ul>
<li>为什么UUID是全局唯一的？ </li>
<li>为什么UUID占用36个字节？ </li>
<li>为什么UUID是无序的？</li>
</ul>
<p>MySQL数据库的UUID组成如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）</span><br></pre></td></tr></table></figure>
<p>我们以UUID值e0ea12d4-6473-11eb-943c-00155dbaa39d举例：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706162131362.png" alt="image-20220706162131362"></p>
<p><code>为什么UUID是全局唯一的？</code></p>
<p>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00 到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降 低到1/100ns。</p>
<p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。</p>
<p><code>为什么UUID占用36个字节？</code></p>
<p>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。</p>
<p><code>为什么UUID是随机无序的呢？</code></p>
<p>因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p>
<p><strong>改造UUID</strong></p>
<p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p>
<p>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p>
<p>可以通过MySQL8.0提供的uuid_to_bin函数实现上述功能，同样的，MySQL也提供了bin_to_uuid函数进行转化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @uuid = UUID();</span><br><span class="line">SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706162657448.png" alt="image-20220706162657448"></p>
<p><strong>通过函数uuid_to_bin(@uuid,true)将UUID转化为有序UUID了</strong>。全局唯一 + 单调递增，这不就是我们想要的主键！</p>
<p><strong>有序UUID性能测试</strong></p>
<p>16字节的有序UUID，相比之前8字节的自增ID，性能和存储空间对比究竟如何呢？</p>
<p>我们来做一个测试，插入1亿条数据，每条数据占用500字节，含有3个二级索引，最终的结果如下所示：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706162947613.png" alt="image-20220706162947613" style="zoom:67%;"></p>
<p>从上图可以看到插入1亿条数据有序UUID是最快的，而且在实际业务使用中有序UUID在 <code>业务端就可以生成</code> 。还可以进一步减少SQL的交互次数。</p>
<p>另外，虽然有序UUID相比自增ID多了8个字节，但实际只增大了3G的存储空间，还可以接受。</p>
<blockquote>
<p>在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局 唯一的实现。 </p>
<p>另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样 的主键设计就更为考验架构师的水平了。</p>
</blockquote>
<p><strong>如果不是MySQL8.0 肿么办？</strong></p>
<p>手动赋值字段做主键！</p>
<p>比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</p>
<p>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</p>
<p>门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加 1，然后用这个值 作为新会员的“id”，同时，更新总部 MySQL 数据库管理信息表中的当前会员编号的最大值。</p>
<p>这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进行操作，就解 决了各门店添加会员时会员编号冲突的问题。</p>
<h1 id="第11章-数据库的设计规范"><a href="#第11章-数据库的设计规范" class="headerlink" title="第11章_数据库的设计规范"></a>第11章_数据库的设计规范</h1><h2 id="1-为什么需要数据库设计"><a href="#1-为什么需要数据库设计" class="headerlink" title="1. 为什么需要数据库设计"></a>1. 为什么需要数据库设计</h2><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706164201695.png" alt="image-20220706164201695" style="zoom:80%;float:left"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706164359539.png" alt="image-20220706164359539" style="zoom:80%;float:left"></p>
<h2 id="2-范-式"><a href="#2-范-式" class="headerlink" title="2. 范 式"></a>2. 范 式</h2><h3 id="2-1-范式简介"><a href="#2-1-范式简介" class="headerlink" title="2.1 范式简介"></a>2.1 范式简介</h3><p>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。可以理解为，一张数据表的设计结 构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<h3 id="2-2-范式都包括哪些"><a href="#2-2-范式都包括哪些" class="headerlink" title="2.2 范式都包括哪些"></a>2.2 范式都包括哪些</h3><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式 （2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p>
<p>数据库的范式设计越高阶，夯余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范的要求称为第二范式（2NF），其余范式以此类推。</p>
<p>一般来说，在关系型数据库设计中，最高也就遵循到<code>BCNF</code>, 普遍还是<code>3NF</code>。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是<code>反规范化</code>。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706165020939.png" alt="image-20220706165020939"></p>
<h3 id="2-3-键和相关属性的概念"><a href="#2-3-键和相关属性的概念" class="headerlink" title="2.3 键和相关属性的概念"></a>2.3 键和相关属性的概念</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706165231022.png" alt="image-20220706165231022" style="float:left;"></p>
<p><strong>举例:</strong></p>
<p>这里有两个表：</p>
<p><code>球员表(player)</code> ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号 </p>
<p><code>球队表(team)</code>：球队编号 | 主教练 | 球队所在地</p>
<ul>
<li>超键 ：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号） （球员编号，姓名）（身份证号，年龄）等。 </li>
<li>候选键 ：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。 </li>
<li>主键 ：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。 </li>
<li>外键 ：球员表中的球队编号。 </li>
<li>主属性 、 非主属性 ：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名） （年龄）（球队编号）都是非主属性。</li>
</ul>
<h3 id="2-4-第一范式-1st-NF"><a href="#2-4-第一范式-1st-NF" class="headerlink" title="2.4 第一范式(1st NF)"></a>2.4 第一范式(1st NF)</h3><p>第一范式主要确保数据库中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单元。</p>
<p>我们在设计某个字段的时候，对于字段X来说，不能把字段X拆分成字段X-1和字段X-2。事实上，任何的DBMS都会满足第一范式的要求，不会将字段进行拆分。</p>
<p><strong>举例1：</strong></p>
<p>假设一家公司要存储员工的姓名和联系方式。它创建一个如下表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706171057270.png" alt="image-20220706171057270"></p>
<p>该表不符合 1NF ，因为规则说“表的每个属性必须具有原子（单个）值”，lisi和zhaoliu员工的 emp_mobile 值违反了该规则。为了使表符合 1NF ，我们应该有如下表数据：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706171130851.png" alt="image-20220706171130851"></p>
<p><strong>举例2：</strong></p>
<p>user 表的设计不符合第一范式</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706171225292.png" alt="image-20220706171225292"></p>
<p>其中，user_info字段为用户信息，可以进一步拆分成更小粒度的字段，不符合数据库设计对第一范式的 要求。将user_info拆分后如下：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706171242455.png" alt="image-20220706171242455"></p>
<p><strong>举例3：</strong></p>
<p>属性的原子性是 主观的 。例如，Employees关系中雇员姓名应当使用1个（fullname）、2个（firstname 和lastname）还是3个（firstname、middlename和lastname）属性表示呢？答案取决于应用程序。如果应 用程序需要分别处理雇员的姓名部分（如：用于搜索目的），则有必要把它们分开。否则，不需要。</p>
<p>表1：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706171442919.png" alt="image-20220706171442919"></p>
<p>表2：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220706171456873.png" alt="image-20220706171456873"></p>
<h3 id="2-5-第二范式-2nd-NF"><a href="#2-5-第二范式-2nd-NF" class="headerlink" title="2.5 第二范式(2nd NF)"></a>2.5 第二范式(2nd NF)</h3><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据库里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分</strong>。如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。（要求中的主键，其实可以扩展替换为候选键）。</p>
<p><strong>举例1：</strong></p>
<p><code>成绩表</code> （学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课 程号也不能决定成绩，所以“（学号，课程号）→成绩”就是 <code>完全依赖关系</code> 。</p>
<p><strong>举例2：</strong></p>
<p><code>比赛表 player_game</code> ，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这 里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)</span><br></pre></td></tr></table></figure>
<p>但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(球员编号) → (姓名，年龄)</span><br><span class="line"></span><br><span class="line">(比赛编号) → (比赛时间, 比赛场地)</span><br></pre></td></tr></table></figure>
<p>对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？</p>
<ol>
<li><code>数据冗余</code> ：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛 也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。 </li>
<li><code>插入异常</code> ：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。 </li>
<li><code>删除异常</code> ：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删 除掉。 </li>
<li><code>更新异常</code> ：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调 整，否则就会出现一场比赛时间不同的情况。</li>
</ol>
<p>为了避免出现上述的情况，我们可以把球员比赛表设计为下面的三张表。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707122639894.png" alt="image-20220707122639894"></p>
<p>这样的话，每张数据表都符合第二范式，也就避免了异常情况的发生。</p>
<blockquote>
<p>1NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，一张表只表达一个意思。</p>
</blockquote>
<p><strong>举例3：</strong></p>
<p>定义了一个名为 Orders 的关系，表示订单和订单行的信息：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707123038469.png" alt="image-20220707123038469"></p>
<p>违反了第二范式，因为有非主键属性仅依赖于候选键（或主键）的一部分。例如，可以仅通过orderid找 到订单的 orderdate，以及 customerid 和 companyname，而没有必要再去使用productid。</p>
<p>修改：</p>
<p>Orders表和OrderDetails表如下，此时符合第二范式。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707123104009.png" alt="image-20220707123104009"></p>
<blockquote>
<p>小结：第二范式（2NF）要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与元实体之间是一对多的关系。</p>
</blockquote>
<h3 id="2-6-第三范式-3rd-NF"><a href="#2-6-第三范式-3rd-NF" class="headerlink" title="2.6 第三范式(3rd NF)"></a>2.6 第三范式(3rd NF)</h3><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段</strong>。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在“A-&gt;B-&gt;C”的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能由依赖关系，必须<code>相互独立</code>。</p>
<p>这里的主键可以扩展为候选键。</p>
<p><strong>举例1：</strong></p>
<p><code>部门信息表</code> ：每个部门有部门编号（dept_id）、部门名称、部门简介等信息。</p>
<p><code>员工信息表</code>：每个员工有员工编号、姓名、部门编号。列出部门编号后就不能再将部门名称、部门简介 等与部门有关的信息再加入员工信息表中。</p>
<p>如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</p>
<p><strong>举例2：</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707124011654.png" alt="image-20220707124011654"></p>
<p>商品类别名称依赖于商品类别编号，不符合第三范式。</p>
<p>修改：</p>
<p>表1：符合第三范式的 <code>商品类别表</code> 的设计</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707124040899.png" alt="image-20220707124040899"></p>
<p>表2：符合第三范式的 <code>商品表</code> 的设计</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707124058174.png" alt="image-20220707124058174"></p>
<p>商品表goods通过商品类别id字段（category_id）与商品类别表goods_category进行关联。</p>
<p><strong>举例3：</strong></p>
<p><code>球员player表</code> ：球员编号、姓名、球队名称和球队主教练。现在，我们把属性之间的依赖关系画出来，如下图所示:</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707124136228.png" alt="image-20220707124136228"></p>
<p>你能看到球员编号决定了球队名称，同时球队名称决定了球队主教练，非主属性球队主教练就会传递依 赖于球员编号，因此不符合 3NF 的要求。</p>
<p>如果要达到 3NF 的要求，需要把数据表拆成下面这样：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707124152312.png" alt="image-20220707124152312"></p>
<p><strong>举例4：</strong></p>
<p>修改第二范式中的举例3。</p>
<p>此时的Orders关系包含 orderid、orderdate、customerid 和 companyname 属性，主键定义为 orderid。 customerid 和companyname均依赖于主键——orderid。例如，你需要通过orderid主键来查找代表订单中 客户的customerid，同样，你需要通过 orderid 主键查找订单中客户的公司名称（companyname）。然 而， customerid和companyname也是互相依靠的。为满足第三范式，可以改写如下：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707124212114.png" alt="image-20220707124212114"></p>
<blockquote>
<p>符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括：“每个非键属性依赖于键，依赖于 整个键，并且除了键别无他物”。</p>
</blockquote>
<h3 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707124343085.png" alt="image-20220707124343085" style="zoom:80%;float:left"></p>
<h2 id="3-反范式化"><a href="#3-反范式化" class="headerlink" title="3. 反范式化"></a>3. 反范式化</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707124741675.png" alt="image-20220707124741675" style="zoom:80%;float:left"></p>
<p><strong>规范化 vs 性能</strong></p>
<blockquote>
<ol>
<li>为满足某种商业目标 , 数据库性能比规范化数据库更重要 </li>
<li>在数据规范化的同时 , 要综合考虑数据库的性能 </li>
<li>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间 </li>
<li>通过在给定的表中插入计算列，以方便查询</li>
</ol>
</blockquote>
<h3 id="3-2-应用举例"><a href="#3-2-应用举例" class="headerlink" title="3.2 应用举例"></a>3.2 应用举例</h3><p><strong>举例1：</strong></p>
<p>员工的信息存储在 <code>employees 表</code> 中，部门信息存储在 <code>departments 表</code> 中。通过 employees 表中的 department_id字段与 departments 表建立关联关系。如果要查询一个员工所在部门的名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select employee_id,department_name</span><br><span class="line">from employees e join departments d</span><br><span class="line">on e.department_id = d.department_id;</span><br></pre></td></tr></table></figure>
<p>如果经常需要进行这个操作，连接查询就会浪费很多时间。可以在 employees 表中增加一个冗余字段 department_name，这样就不用每次都进行连接操作了。</p>
<p><strong>举例2：</strong></p>
<p>反范式化的 <code>goods商品信息表</code> 设计如下：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707125118808.png" alt="image-20220707125118808"></p>
<p><strong>举例3：</strong></p>
<p>我们有 2 个表，分别是 <code>商品流水表（atguigu.trans ）</code>和 <code>商品信息表 （atguigu.goodsinfo）</code> 。商品流水表里有 400 万条流水记录，商品信息表里有 2000 条商品记录。</p>
<p>商品流水表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707125401029.png" alt="image-20220707125401029"></p>
<p>商品信息表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707125447317.png" alt="image-20220707125447317"></p>
<p>新的商品流水表如下所示：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707125500378.png" alt="image-20220707125500378"></p>
<p><strong>举例4：</strong></p>
<p><code>课程评论表 class_comment</code> ，对应的字段名称及含义如下：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707125531172.png" alt="image-20220707125531172"></p>
<p><code>学生表 student</code> ，对应的字段名称及含义如下：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707125545891.png" alt="image-20220707125545891" style="zoom:80%;"></p>
<p>在实际应用中，我们在显示课程评论的时候，通常会显示这个学生的昵称，而不是学生 ID，因此当我们 想要查询某个课程的前 1000 条评论时，需要关联 class_comment 和 student这两张表来进行查询。</p>
<p><strong>实验数据：模拟两张百万量级的数据表</strong></p>
<p>为了更好地进行 SQL 优化实验，我们需要给学生表和课程评论表随机模拟出百万量级的数据。我们可以 通过存储过程来实现模拟数据。</p>
<p><strong>反范式优化实验对比</strong></p>
<p>如果我们想要查询课程 ID 为 10001 的前 1000 条评论，需要写成下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT p.comment_text, p.comment_time, stu.stu_name</span><br><span class="line">FROM class_comment AS p LEFT JOIN student AS stu</span><br><span class="line">ON p.stu_id = stu.stu_id</span><br><span class="line">WHERE p.class_id = 10001</span><br><span class="line">ORDER BY p.comment_id DESC</span><br><span class="line">LIMIT 1000;</span><br></pre></td></tr></table></figure>
<p>运行结果（1000 条数据行）：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707125642908.png" alt="image-20220707125642908" style="zoom:80%;"></p>
<p>运行时长为 0.395 秒，对于网站的响应来说，这已经很慢了，用户体验会非常差。</p>
<p>如果我们想要提升查询的效率，可以允许适当的数据冗余，也就是在商品评论表中增加用户昵称字段， 在 class_comment 数据表的基础上增加 stu_name 字段，就得到了 class_comment2 数据表。</p>
<p>这样一来，只需单表查询就可以得到数据集结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT comment_text, comment_time, stu_name</span><br><span class="line">FROM class_comment2</span><br><span class="line">WHERE class_id = 10001</span><br><span class="line">ORDER BY class_id DESC LIMIT 1000;</span><br></pre></td></tr></table></figure>
<p>运行结果（1000 条数据）：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707125718469.png" alt="image-20220707125718469" style="zoom:80%;"></p>
<p>优化之后只需要扫描一次聚集索引即可，运行时间为 0.039 秒，查询时间是之前的 1/10。 你能看到， 在数据量大的情况下，查询效率会有显著的提升。</p>
<h3 id="3-3-反范式的新问题"><a href="#3-3-反范式的新问题" class="headerlink" title="3.3 反范式的新问题"></a>3.3 反范式的新问题</h3><ul>
<li>存储 空间变大了 </li>
<li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致 </li>
<li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 消耗系统资源 </li>
<li>在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂</li>
</ul>
<h3 id="3-4-反范式的适用场景"><a href="#3-4-反范式的适用场景" class="headerlink" title="3.4 反范式的适用场景"></a>3.4 反范式的适用场景</h3><p>当冗余信息有价值或者能 <code>大幅度提高查询效率</code> 的时候，我们才会采取反范式的优化。</p>
<h4 id="1-增加冗余字段的建议"><a href="#1-增加冗余字段的建议" class="headerlink" title="1. 增加冗余字段的建议"></a>1. 增加冗余字段的建议</h4><p>增加冗余字段一定要符合如下两个条件。只要满足这两个条件，才可以考虑增加夯余字段。</p>
<p>1）这个冗余字段<code>不需要经常进行修改</code>。</p>
<p>2）这个冗余字段<code>查询的时候不可或缺</code>。</p>
<h4 id="2-历史快照、历史数据的需要"><a href="#2-历史快照、历史数据的需要" class="headerlink" title="2. 历史快照、历史数据的需要"></a>2. 历史快照、历史数据的需要</h4><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每 次发生的 <code>订单收货信息</code> 都属于 <code>历史快照</code> ，需要进行保存，但用户可以随时修改自己的信息，这时保存这 些冗余信息是非常有必要的。</p>
<p>反范式优化也常用在 <code>数据仓库</code> 的设计中，因为数据仓库通常<code>存储历史数据</code> ，对增删改的实时性要求不 强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p>
<p>我简单总结下数据仓库和数据库在使用上的区别：</p>
<ol>
<li>数据库设计的目的在于<code>捕捉数据</code>，而数据仓库设计的目的在于<code>分析数据</code>。</li>
<li>数据库对数据的<code>增删改实时性</code>要求强，需要存储在线的用户数据，而数据仓库存储的一般是<code>历史数据</code>。</li>
<li>数据库设计需要<code>尽量避免冗余</code>，但为了提高查询效率也允许一定的<code>冗余度</code>，而数据仓库在设计上更偏向采用反范式设计，</li>
</ol>
<h2 id="4-BCNF-巴斯范式"><a href="#4-BCNF-巴斯范式" class="headerlink" title="4. BCNF(巴斯范式)"></a>4. BCNF(巴斯范式)</h2><p>人们在3NF的基础上进行了改进，提出了巴斯范式（BCNF），页脚巴斯 - 科德范式（Boyce - Codd Normal Form）。BCNF被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是<code>修正的第三范式</code>，或<code>扩充的第三范式</code>，BCNF不被称为第四范式。</p>
<p>若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BC范式。</p>
<p>一般来说，一个数据库设符合3NF或者BCNF就可以了。</p>
<p><strong>1. 案例</strong></p>
<p>我们分析如下表的范式情况：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707131428597.png" alt="image-20220707131428597" style="zoom:80%;"></p>
<p>在这个表中，一个仓库只有一个管理员，同时一个管理员也只管理一个仓库。我们先来梳理下这些属性之间的依赖关系。</p>
<p>仓库名决定了管理员，管理员也决定了仓库名，同时（仓库名，物品名）的属性集合可以决定数量这个 属性。这样，我们就可以找到数据表的候选键。</p>
<p><code>候选键</code>：是（管理员，物品名）和（仓库名，物品名），然后我们从候选键中选择一个作为主键 ，比 如（仓库名，物品名）。</p>
<p><code>主属性</code> ：包含在任一候选键中的属性，也就是仓库名，管理员和物品名。</p>
<p><code>非主属性</code> ：数量这个属性。</p>
<p><strong>2. 是否符合三范式</strong></p>
<p>如何判断一张表的范式呢？我们需要根据范式的等级，从低到高来进行判断。</p>
<p>首先，数据表每个属性都是原子性的，符合 1NF 的要求；</p>
<p>其次，数据表中非主属性”数量“都与候选键全部依赖，（仓库名，物品名）决定数量，（管理员，物品 名）决定数量。因此，数据表符合 2NF 的要求；</p>
<p>最后，数据表中的非主属性，不传递依赖于候选键。因此符合 3NF 的要求。</p>
<p><strong>3. 存在的问题</strong></p>
<p>既然数据表已经符合了 3NF 的要求，是不是就不存在问题了呢？我们来看下面的情况：</p>
<ol>
<li>增加一个仓库，但是还没有存放任何物品。根据数据表实体完整性的要求，主键不能有空值，因 此会出现 插入异常 ；</li>
<li>如果仓库更换了管理员，我们就可能会修改数据表中的多条记录 ；</li>
<li>如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除。</li>
</ol>
<p>你能看到，即便数据表符合 3NF 的要求，同样可能存在插入，更新和删除数据的异常情况。</p>
<p><strong>4. 问题解决</strong></p>
<p>首先我们需要确认造成异常的原因：主属性仓库名对于候选键（管理员，物品名）是部分依赖的关系， 这样就有可能导致上面的异常情况。因此引入BCNF，<strong>它在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系</strong>。</p>
<ul>
<li>如果在关系R中，U为主键，A属性是主键的一个属性，若存在A-&gt;Y，Y为主属性，则该关系不属于 BCNF。</li>
</ul>
<p>根据 BCNF 的要求，我们需要把仓库管理关系 warehouse_keeper 表拆分成下面这样：</p>
<p><code>仓库表</code> ：（仓库名，管理员）</p>
<p><code>库存表</code>：（仓库名，物品名，数量）</p>
<p>这样就不存在主属性对于候选键的部分依赖或传递依赖，上面数据表的设计就符合 BCNF。</p>
<p>再举例：</p>
<p>有一个 <code>学生导师表</code> ，其中包含字段：学生ID，专业，导师，专业GPA，这其中学生ID和专业是联合主键。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707132038425.png" alt="image-20220707132038425"></p>
<p>这个表的设计满足三范式，但是这里存在另一个依赖关系，“专业”依赖于“导师”，也就是说每个导师只做一个专业方面的导师，只要知道了是哪个导师，我们自然就知道是哪个专业的了。</p>
<p>所以这个表的部分主键Major依赖于非主键属性Advisor，那么我们可以进行以下的调整，拆分成2个表：</p>
<p>学生导师表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707132344634.png" alt="image-20220707132344634"></p>
<p>导师表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707132355841.png" alt="image-20220707132355841"></p>
<h2 id="5-第四范式"><a href="#5-第四范式" class="headerlink" title="5. 第四范式"></a>5. 第四范式</h2><p>多值依赖的概念：</p>
<ul>
<li><code>多值依赖</code>即属性之间的一对多关系，记为K—&gt;—&gt;A。</li>
<li><code>函数依赖</code>事实上是单值依赖，所以不能表达属性值之间的一对多关系。</li>
<li><code>平凡的多值依赖</code>：全集U=K+A，一个K可以对应于多个A，即K—&gt;—&gt;A。此时整个表就是一组一对多关系。</li>
<li><code>非平凡的多值依赖</code>：全集U=K+A+B，一个K可以对应于多个A，也可以对应于多个B，A与B相互独立，即K—&gt;—&gt;A，K—&gt;—&gt;B。整个表有多组一对多关系，且有：”一”部分是相同的属性集合，“多”部分是相互独立的属性集合。</li>
</ul>
<p>第四范式即在满足巴斯 - 科德范式（BCNF）的基础上，消除非平凡且非函数依赖的多值依赖（即把同一表的多对多关系删除）。</p>
<p><strong>举例1：</strong>职工表(职工编号，职工孩子姓名，职工选修课程)。</p>
<p>在这个表中，同一个职工可能会有多个职工孩子姓名。同样，同一个职工也可能会有多个职工选修课程，即这里存在着多值事实，不符合第四范式。</p>
<p>如果要符合第四范式，只需要将上表分为两个表，使它们只有一个多值事实，例如： <code>职工表一</code> (职工编 号，职工孩子姓名)， <code>职工表二</code>(职工编号，职工选修课程)，两个表都只有一个多值事实，所以符合第四范式。</p>
<p><strong>举例2：</strong></p>
<p>比如我们建立课程、教师、教材的模型。我们规定，每门课程有对应的一组教师，每门课程也有对应的一组教材，一门课程使用的教材和教师没有关系。我们建立的关系表如下：</p>
<p>课程ID，教师ID，教材ID；这三列作为联合主键。</p>
<p>为了表述方便，我们用Name代替ID，这样更容易看懂：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707133830721.png" alt="image-20220707133830721"></p>
<p>这个表除了主键，就没有其他字段了，所以肯定满足BC范式，但是却存在 <code>多值依赖</code> 导致的异常。</p>
<p>假如我们下学期想采用一本新的英版高数教材，但是还没确定具体哪个老师来教，那么我们就无法在这 个表中维护Course高数和Book英版高数教材的的关系。</p>
<p>解决办法是我们把这个多值依赖的表拆解成2个表，分别建立关系。这是我们拆分后的表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707134028730.png" alt="image-20220707134028730"></p>
<p>以及</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707134220820.png" alt="image-20220707134220820"></p>
<h2 id="6-第五范式、域键范式"><a href="#6-第五范式、域键范式" class="headerlink" title="6. 第五范式、域键范式"></a>6. 第五范式、域键范式</h2><p>除了第四范式外，我们还有更高级的第五范式（又称完美范式）和域键范式（DKNF）。</p>
<p>在满足第四范式（4NF）的基础上，消除不是由候选键所蕴含的连接依赖。<strong>如果关系模式R中的每一个连 接依赖均由R的候选键所隐含</strong>，则称此关系模式符合第五范式。</p>
<p>函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不 像函数依赖和多值依赖可以由 <code>语义直接导出</code> ，而是在 <code>关系连接运算</code> 时才反映出来。存在连接依赖的关系 模式仍可能遇到数据冗余及插入、修改、删除异常等问题。</p>
<p>第五范式处理的是 <code>无损连接问题</code> ，这个范式基本 <code>没有实际意义</code> ，因为无损连接很少出现，而且难以察觉。而域键范式试图定义一个 <code>终极范式</code> ，该范式考虑所有的依赖和约束类型，但是实用价值也是最小的，只存在理论研究中。</p>
<h2 id="7-实战案例"><a href="#7-实战案例" class="headerlink" title="7. 实战案例"></a>7. 实战案例</h2><p>商超进货系统中的<code>进货单表</code>进行剖析：</p>
<p>进货单表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707134636225.png" alt="image-20220707134636225"></p>
<p>这个表中的字段很多，表里的数据量也很惊人。大量重复导致表变得庞大，效率极低。如何改造？</p>
<blockquote>
<p>在实际工作场景中，这种由于数据表结构设计不合理，而导致的数据重复的现象并不少见。往往是系统虽然能够运行，承载能力却很差，稍微有点流量，就会出现内存不足、CPU使用率飙升的情况，甚至会导致整个项目失败。</p>
</blockquote>
<h3 id="7-1-迭代1次：考虑1NF"><a href="#7-1-迭代1次：考虑1NF" class="headerlink" title="7.1 迭代1次：考虑1NF"></a>7.1 迭代1次：考虑1NF</h3><p>第一范式要求：<strong>所有的字段都是基本数据类型，不可进行拆分</strong>。这里需要确认，所有的列中，每个字段只包含一种数据。</p>
<p>这张表里，我们把“property”这一字段，拆分成”specification (规格)” 和 “unit (单位)”，这两个字段如下：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707154400580.png" alt="image-20220707154400580"></p>
<h3 id="7-2-迭代2次：考虑2NF"><a href="#7-2-迭代2次：考虑2NF" class="headerlink" title="7.2 迭代2次：考虑2NF"></a>7.2 迭代2次：考虑2NF</h3><p>第二范式要求，在满足第一范式的基础上，<strong>还要满足数据表里的每一条数据记录，都是可唯一标识的。而且所有字段，都必须完全依赖主键，不能只依赖主键的一部分</strong>。</p>
<p>第1步，就是要确定这个表的主键。通过观察发现，字段“listnumber（单号）”+”barcode（条码）”可以唯一标识每一条记录，可以作为主键。</p>
<p>第2步，确定好了主键以后，判断哪些字段完全依赖主键，哪些字段只依赖于主键的一部分。把只依赖于主键一部分的字段拆出去，形成新的数据表。</p>
<p>首先，进货单明细表里面的”goodsname(名称)””specification(规格)””unit(单位)”这些信息是商品的属性，只依赖于”batcode(条码)”，不完全依赖主键，可以拆分出去。我们把这3个字段加上它们所依赖的字段”barcode(条码)”，拆分形成新的数据表”商品信息表”。</p>
<p>这样一来，原来的数据表就被拆分成了两个表。</p>
<p>商品信息表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707163807205.png" alt="image-20220707163807205" style="float:left;"></p>
<p>进货单表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707163828614.png" alt="image-20220707163828614" style="float:left;"></p>
<p>此外，字段”supplierid(供应商编号)””suppliername(供应商名称)””stock(仓库)“只依赖于”listnumber(单号)”，不完全依赖于主键，所以，我们可以把”supplierid””suppliername””stock”这3个字段拆出去，再加上它们依赖的字段”listnumber(单号)”，就形成了一个新的表”进货单头表”。剩下的字段，会组成新的表，我们叫它”进货单明细表”。</p>
<p>原来的数据表就拆分成了3个表。</p>
<p>进货单头表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707164128704.png" alt="image-20220707164128704"></p>
<p>进货单明细表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707164146216.png" alt="image-20220707164146216"></p>
<p>商品信息表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707164227845.png" alt="image-20220707164227845"></p>
<p>现在，我们再来分析一下拆分后的3个表，保证这3个表都满足第二范式的要求。</p>
<p>第3步，在“商品信息表”中，字段“barcode”是有<code>可能存在重复</code>的，比如，用户门店可能有散装称重商品和自产商品，会存在条码共用的情况。所以，所有的字段都不能唯一标识表里的记录。这个时候，我们必须给这个表加上一个主键，比如说是<code>自增字段&quot;itemnumber&quot;</code>。</p>
<h3 id="7-3-迭代3次：考虑3NF"><a href="#7-3-迭代3次：考虑3NF" class="headerlink" title="7.3 迭代3次：考虑3NF"></a>7.3 迭代3次：考虑3NF</h3><p>我们的进货单头表，还有数据冗余的可能。因为”suppliername”依赖”supplierid”，那么就可以按照第三范式的原则进行拆分了。我们就进一步拆分进货单头表，把它拆解陈供货商表和进货单头表。</p>
<p>供货商表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707165011050.png" alt="image-20220707165011050" style="float:left;"></p>
<p>进货单头表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707165038108.png" alt="image-20220707165038108" style="float:left;"></p>
<p>这2个表都满足第三范式的要求了。</p>
<h3 id="7-4-反范式化：业务优先的原则"><a href="#7-4-反范式化：业务优先的原则" class="headerlink" title="7.4 反范式化：业务优先的原则"></a>7.4 反范式化：业务优先的原则</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707165459547.png" alt="image-20220707165459547" style="zoom:80%;float:left"></p>
<p>因此，最后我们可以把进货单表拆分成下面的4个表：</p>
<p>供货商表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707165011050.png" alt="image-20220707165011050" style="float:left;"></p>
<p>进货单头表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707165038108.png" alt="image-20220707165038108" style="float:left;"></p>
<p>进货单明细表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707164146216.png" alt="image-20220707164146216" style="zoom:80%;float:left"></p>
<p>商品信息表：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707164227845.png" alt="image-20220707164227845" style="zoom:80%;float:left"></p>
<p>这样一来，我们就避免了冗余数据，而且还能够满足业务的需求，这样的数据库设计，才是合格的设计。</p>
<h2 id="8-ER模型"><a href="#8-ER模型" class="headerlink" title="8. ER模型"></a>8. ER模型</h2><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707170027637.png" alt="image-20220707170027637" style="zoom:80%;float:left"></p>
<h3 id="8-1-ER模型包括哪些要素？"><a href="#8-1-ER模型包括哪些要素？" class="headerlink" title="8.1 ER模型包括哪些要素？"></a>8.1 ER模型包括哪些要素？</h3><p><strong>ER 模型中有三个要素，分别是实体、属性和关系。</strong></p>
<p><code>实体</code> ，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用 矩形 来表 示。实体分为两类，分别是 强实体 和 弱实体 。强实体是指不依赖于其他实体的实体；弱实体是指对另 一个实体有很强的依赖关系的实体。</p>
<p><code>属性</code> ，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 椭圆形 来表示。</p>
<p><code>关系</code> ，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模 型中用 菱形 来表示。</p>
<p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p>
<h3 id="8-2-关系的类型"><a href="#8-2-关系的类型" class="headerlink" title="8.2 关系的类型"></a>8.2 关系的类型</h3><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p>
<p><code>一对一</code> ：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</p>
<p><code>一对多</code> ：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学 生则对应一个班级，班级对学生就是一对多的关系。</p>
<p><code>多对多</code> ：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之 间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购 商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这 就是多对多的关系。</p>
<h3 id="8-3-建模分析"><a href="#8-3-建模分析" class="headerlink" title="8.3 建模分析"></a>8.3 建模分析</h3><p>ER 模型看起来比较麻烦，但是对我们把控项目整体非常重要。如果你只是开发一个小应用，或许简单设 计几个表够用了，一旦要设计有一定规模的应用，在项目的初始阶段，建立完整的 ER 模型就非常关键 了。开发应用项目的实质，其实就是 建模 。</p>
<p>我们设计的案例是 电商业务 ，由于电商业务太过庞大且复杂，所以我们做了业务简化，比如针对 SKU（StockKeepingUnit，库存量单位）和SPU（Standard Product Unit，标准化产品单元）的含义上，我 们直接使用了SKU，并没有提及SPU的概念。本次电商业务设计总共有8个实体，如下所示。</p>
<ul>
<li>地址实体 </li>
<li>用户实体 </li>
<li>购物车实体 </li>
<li>评论实体 </li>
<li>商品实体 </li>
<li>商品分类实体 </li>
<li>订单实体 </li>
<li>订单详情实体</li>
</ul>
<p>其中， 用户 和 商品分类 是强实体，因为它们不需要依赖其他任何实体。而其他属于弱实体，因为它们 虽然都可以独立存在，但是它们都依赖用户这个实体，因此都是弱实体。知道了这些要素，我们就可以 给电商业务创建 ER 模型了，如图：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707170608782.png" alt="image-20220707170608782"></p>
<p>在这个图中，地址和用户之间的添加关系，是一对多的关系，而商品和商品详情示一对1的关系，商品和 订单是多对多的关系。 这个 ER 模型，包括了 8个实体之间的 8种关系。</p>
<p>（1）用户可以在电商平台添加多个地址； </p>
<p>（2）用户只能拥有一个购物车； </p>
<p>（3）用户可以生成多个订单； </p>
<p>（4）用户可以发表多条评论； </p>
<p>（5）一件商品可以有多条评论； </p>
<p>（6）每一个商品分类包含多种商品；</p>
<p>（7）一个订单可以包含多个商品，一个商品可以在多个订单里。 </p>
<p>（8）订单中又包含多个订单详情，因为一个订单中可能包含不同种类的商品</p>
<h3 id="8-4-ER-模型的细化"><a href="#8-4-ER-模型的细化" class="headerlink" title="8.4 ER 模型的细化"></a>8.4 ER 模型的细化</h3><p>有了这个 ER 模型，我们就可以从整体上 理解 电商的业务了。刚刚的 ER 模型展示了电商业务的框架， 但是只包括了订单，地址，用户，购物车，评论，商品，商品分类和订单详情这八个实体，以及它们之 间的关系，还不能对应到具体的表，以及表与表之间的关联。我们需要把 属性加上 ，用 椭圆 来表示， 这样我们得到的 ER 模型就更加完整了。</p>
<p>因此，我们需要进一步去设计一下这个 ER 模型的各个局部，也就是细化下电商的具体业务流程，然后把 它们综合到一起，形成一个完整的 ER 模型。这样可以帮助我们理清数据库的设计思路。</p>
<p>接下来，我们再分析一下各个实体都有哪些属性，如下所示。</p>
<p>（1） <code>地址实体</code> 包括用户编号、省、市、地区、收件人、联系电话、是否是默认地址。 </p>
<p>（2） <code>用户实体</code> 包括用户编号、用户名称、昵称、用户密码、手机号、邮箱、头像、用户级别。</p>
<p>（3） <code>购物车实体</code> 包括购物车编号、用户编号、商品编号、商品数量、图片文件url。</p>
<p>（4） <code>订单实体</code> 包括订单编号、收货人、收件人电话、总金额、用户编号、付款方式、送货地址、下单 时间。 </p>
<p>（5） <code>订单详情实体</code> 包括订单详情编号、订单编号、商品名称、商品编号、商品数量。 </p>
<p>（6） <code>商品实体</code> 包括商品编号、价格、商品名称、分类编号、是否销售，规格、颜色。 </p>
<p>（7） <code>评论实体</code> 包括评论id、评论内容、评论时间、用户编号、商品编号 </p>
<p>（8） <code>商品分类实体</code> 包括类别编号、类别名称、父类别编号</p>
<p>这样细分之后，我们就可以重新设计电商业务了，ER 模型如图：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707171022246.png" alt="image-20220707171022246"></p>
<h3 id="8-5-ER-模型图转换成数据表"><a href="#8-5-ER-模型图转换成数据表" class="headerlink" title="8.5 ER 模型图转换成数据表"></a>8.5 ER 模型图转换成数据表</h3><p>通过绘制 ER 模型，我们已经理清了业务逻辑，现在，我们就要进行非常重要的一步了：把绘制好的 ER 模型，转换成具体的数据表，下面介绍下转换的原则：</p>
<p>（1）一个 实体 通常转换成一个 数据表 ； </p>
<p>（2）一个 多对多的关系 ，通常也转换成一个 数据表 ； </p>
<p>（3）一个 1 对 1 ，或者 1 对多 的关系，往往通过表的 外键 来表达，而不是设计一个新的数据表； </p>
<p>（4） 属性 转换成表的 字段 。</p>
<p>下面结合前面的ER模型，具体讲解一下怎么运用这些转换的原则，把 ER 模型转换成具体的数据表，从 而把抽象出来的数据模型，落实到具体的数据库设计当中。</p>
<h4 id="1-一个实体转换成一个数据库"><a href="#1-一个实体转换成一个数据库" class="headerlink" title="1. 一个实体转换成一个数据库"></a>1. 一个实体转换成一个数据库</h4><p><strong>先来看一下强实体转换成数据表:</strong></p>
<p><code>用户实体</code>转换成用户表(user_info)的代码如下所示。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707171335255.png" alt="image-20220707171335255" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707171412363.png" alt="image-20220707171412363" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707171915637.png" alt="image-20220707171915637" style="float:left;"></p>
<p><strong>下面我们再把弱实体转换成数据表：</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707172033399.png" alt="image-20220707172033399" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707172052236.png" alt="image-20220707172052236" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707172143793.png" alt="image-20220707172143793" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707172217772.png" alt="image-20220707172217772" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707172236606.png" alt="image-20220707172236606" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707172259143.png" alt="image-20220707172259143" style="float:left;"></p>
<h4 id="2-一个多对多的关系转换成一个数据表"><a href="#2-一个多对多的关系转换成一个数据表" class="headerlink" title="2. 一个多对多的关系转换成一个数据表"></a>2. 一个多对多的关系转换成一个数据表</h4><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707172350226.png" alt="image-20220707172350226" style="float:left;"></p>
<h4 id="3-通过外键来表达1对多的关系"><a href="#3-通过外键来表达1对多的关系" class="headerlink" title="3. 通过外键来表达1对多的关系"></a>3. 通过外键来表达1对多的关系</h4><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707172609833.png" alt="image-20220707172609833" style="float:left;"></p>
<h4 id="4-把属性转换成表的字段"><a href="#4-把属性转换成表的字段" class="headerlink" title="4. 把属性转换成表的字段"></a>4. 把属性转换成表的字段</h4><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707172819174.png" alt="image-20220707172819174" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707172918017.png" alt="image-20220707172918017"></p>
<h2 id="9-数据表的设计原则"><a href="#9-数据表的设计原则" class="headerlink" title="9. 数据表的设计原则"></a>9. 数据表的设计原则</h2><p>综合以上内容，总结出数据表设计的一般原则：”三少一多”</p>
<p><strong>1. 数据表的个数越少越好</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707173028203.png" alt="image-20220707173028203" style="float:left;"></p>
<p><strong>2. 数据表中的字段个数越少越好</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707173402491.png" alt="image-20220707173402491" style="float:left;"></p>
<p><strong>3. 数据表中联合主键的字段个数越少越好</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707173522971.png" alt="image-20220707173522971" style="float:left;"></p>
<p><strong>4. 使用主键和外键越多越好</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707173557568.png" alt="image-20220707173557568" style="float:left;"></p>
<h2 id="10-数据库对象编写建议"><a href="#10-数据库对象编写建议" class="headerlink" title="10. 数据库对象编写建议"></a>10. 数据库对象编写建议</h2><h3 id="10-1-关于库"><a href="#10-1-关于库" class="headerlink" title="10.1 关于库"></a>10.1 关于库</h3><ol>
<li>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字 母开头。 </li>
<li>【强制】库名中英文 一律小写 ，不同单词采用 下划线 分割。须见名知意。 </li>
<li>【强制】库的名称格式：业务系统名称_子系统名。</li>
<li>【强制】库名禁止使用关键字（如type,order等）。</li>
<li>【强制】创建数据库时必须 显式指定字符集 ，并且字符集只能是utf8或者utf8mb4。 创建数据库SQL举例：CREATE DATABASE crm_fund DEFAULT CHARACTER SET ‘utf8’ ; </li>
<li>【建议】对于程序连接数据库账号，遵循 权限最小原则 使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号 原则上不准有drop权限 。 </li>
<li>【建议】临时库以 tmp<em> 为前缀，并以日期为后缀； 备份库以 bak</em> 为前缀，并以日期为后缀。</li>
</ol>
<h3 id="10-2-关于表、列"><a href="#10-2-关于表、列" class="headerlink" title="10.2 关于表、列"></a>10.2 关于表、列</h3><ol>
<li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议 以 英文字母开头 。 </p>
</li>
<li><p>【强制】 表名、列名一律小写 ，不同单词采用下划线分割。须见名知意。 </p>
</li>
<li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀 。比如：crm_fund_item </p>
</li>
<li><p>【强制】创建表时必须 显式指定字符集 为utf8或utf8mb4。 </p>
</li>
<li><p>【强制】表名、列名禁止使用关键字（如type,order等）。 </p>
</li>
<li><p>【强制】创建表时必须 显式指定表存储引擎 类型。如无特殊需求，一律为InnoDB。 </p>
</li>
<li><p>【强制】建表必须有comment。 </p>
</li>
<li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或 缩写 。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。 </p>
</li>
<li><p>【强制】布尔值类型的字段命名为 is_描述 。如member表上表示是否为enabled的会员的字段命 名为 is_enabled。 </p>
</li>
<li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据 通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随 机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。 </p>
</li>
<li><p>【建议】建表时关于主键： 表必须有主键</p>
<p> (1)强制要求主键为id，类型为int或bigint，且为 auto_increment 建议使用unsigned无符号型。</p>
<p> (2)标识表里每一行主体的字段不要设为主键，建议 设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机 插入，则会导致innodb内部页分裂和大量随机I/O，性能下降。 </p>
</li>
<li><p>【建议】核心表（如用户表）必须有行数据的 创建时间字段 （create_time）和 最后更新时间字段 （update_time），便于查问题。 </p>
</li>
<li><p>【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT值 。 因为使用 NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问 题。 </p>
</li>
<li><p>【建议】所有存储相同数据的 列名和列类型必须一致 （一般作为关联列，如果查询时关联列类型 不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。 </p>
</li>
<li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以 tmp<em> 开头。 备份表用于备份或抓取源表快照，名称以 bak</em> 开头。中间表和备份表定期清理。 1</p>
</li>
<li><p>【示范】一个较为规范的建表语句：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user_info (</span><br><span class="line">`id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">`user_id` bigint(11) NOT NULL COMMENT &#x27;用户id&#x27;,</span><br><span class="line">`username` varchar(45) NOT NULL COMMENT &#x27;真实姓名&#x27;,</span><br><span class="line">`email` varchar(30) NOT NULL COMMENT &#x27;用户邮箱&#x27;,</span><br><span class="line">`nickname` varchar(45) NOT NULL COMMENT &#x27;昵称&#x27;,</span><br><span class="line">`birthday` date NOT NULL COMMENT &#x27;生日&#x27;,</span><br><span class="line">`sex` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;性别&#x27;,</span><br><span class="line">`short_introduce` varchar(150) DEFAULT NULL COMMENT &#x27;一句话介绍自己，最多50个汉字&#x27;,</span><br><span class="line">`user_resume` varchar(300) NOT NULL COMMENT &#x27;用户提交的简历存放地址&#x27;,</span><br><span class="line">`user_register_ip` int NOT NULL COMMENT &#x27;用户注册时的源ip&#x27;,</span><br><span class="line">`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE</span><br><span class="line">CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">`user_review_status` tinyint NOT NULL COMMENT &#x27;用户资料审核状态，1为通过，2为审核中，3为未</span><br><span class="line">通过，4为还未提交审核&#x27;,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">UNIQUE KEY `uniq_user_id` (`user_id`),</span><br><span class="line">KEY `idx_username`(`username`),</span><br><span class="line">KEY `idx_create_time_status`(`create_time`,`user_review_status`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;网站用户基本信息</span><br></pre></td></tr></table></figure>
<ol>
<li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。</li>
</ol>
<p>实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。</p>
<p>可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</p>
<h3 id="10-3-关于索引"><a href="#10-3-关于索引" class="headerlink" title="10.3 关于索引"></a>10.3 关于索引</h3><ol>
<li>【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值 禁止被更新 。 </li>
<li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE 。 </li>
<li>【建议】主键的名称以 pk<em> 开头，唯一键以 uni</em> 或 uk<em> 开头，普通索引以 idx</em> 开头，一律使用小写格式，以字段的名称或缩写作为后缀。 </li>
<li>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。 </li>
<li>【建议】单个表上的索引个数 不能超过6个 。 </li>
<li>【建议】在建立索引时，多考虑建立 联合索引 ，并把区分度最高的字段放在最前面。 </li>
<li>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。 </li>
<li>【建议】建表或加索引时，保证表里互相不存在 冗余索引 。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</li>
</ol>
<h3 id="10-4-SQL编写"><a href="#10-4-SQL编写" class="headerlink" title="10.4 SQL编写"></a>10.4 SQL编写</h3><ol>
<li>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。 </li>
<li>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。 </li>
<li>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。 </li>
<li>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很 快，但会引起主从同步延迟。 </li>
<li>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以 内。 </li>
<li>【建议】线上环境，多表 JOIN 不要超过5个表。 </li>
<li>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。 </li>
<li>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果 集请保持在1000行以内，否则SQL会很慢。 </li>
<li>【建议】对单表的多次alter操作必须合并为一次 对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整 合在一起。 因为alter table会产生 表锁 ，期间阻塞对于该表的所有写入，对于业务可能会产生极 大影响。 </li>
<li>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。 </li>
<li>【建议】事务里包含SQL不超过5个。 因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。 </li>
<li>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id=XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li>
</ol>
<h2 id="11-PowerDesigner的使用"><a href="#11-PowerDesigner的使用" class="headerlink" title="11. PowerDesigner的使用"></a>11. PowerDesigner的使用</h2><p>PowerDesigner是一款开发人员常用的数据库建模工具，用户利用该软件可以方便地制作 <code>数据流程图</code> 、 <code>概念数据模型</code> 、 <code>物理数据模型</code> ，它几乎包括了数据库模型设计的全过程，是Sybase公司为企业建模和设 计提供的一套完整的集成化企业级建模解决方案。</p>
<h3 id="11-1-开始界面"><a href="#11-1-开始界面" class="headerlink" title="11.1 开始界面"></a>11.1 开始界面</h3><p>当前使用的PowerDesigner版本是16.5的。打开软件即是此页面，可选择Create Model,也可以选择Do Not Show page Again,自行在打开软件后创建也可以！完全看个人的喜好，在此我在后面的学习中不在显示此页面。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707175250944.png" alt="image-20220707175250944" style="zoom:80%;float:left"></p>
<p>“Create Model”的作用类似于普通的一个文件，该文件可以单独存放也可以归类存放。</p>
<p> “Create Project”的作用类似于文件夹，负责把有关联关系的文件集中归类存放。</p>
<h3 id="11-2-概念数据模型"><a href="#11-2-概念数据模型" class="headerlink" title="11.2 概念数据模型"></a>11.2 概念数据模型</h3><p>常用的模型有4种，分别是 <code>概念模型(CDM Conceptual Data Model)</code> ， <code>物理模型（PDM,Physical Data Model）</code> ， <code>面向对象的模型（OOM Objcet Oriented Model）</code> 和 <code>业务模型（BPM Business Process Model）</code> ，我们先创建概念数据模型。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707175350250.png" alt="image-20220707175350250" style="float:left;"></p>
<p>点击上面的ok，即可出现下图左边的概念模型1，可以自定义概念模型的名字，在概念模型中使用最多的 就是如图所示的Entity(实体),Relationship(关系)</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707175604026.png" alt="image-20220707175604026" style="float:left;"></p>
<p><strong>Entity实体</strong></p>
<p>选中右边框中Entity这个功能，即可出现下面这个方框，需要注意的是书写name的时候，code自行补全，name可以是英文的也可以是中文的，但是code必须是英文的。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707175653689.png" alt="image-20220707175653689" style="float:left;"></p>
<p><strong>填充实体字段</strong></p>
<p>General中的name和code填好后，就可以点击Attributes（属性）来设置name（名字），code(在数据库中 的字段名)，Data Type(数据类型) ，length(数据类型的长度)</p>
<ul>
<li>Name: 实体名字一般为中文，如论坛用户 </li>
<li>Code: 实体代号，一般用英文，如XXXUser </li>
<li>Comment:注释，对此实体详细说明 </li>
<li>Code属性：代号，一般用英文UID DataType </li>
<li>Domain域，表示属性取值范围如可以创建10个字符的地址域 </li>
<li>M:Mandatory强制属性，表示该属性必填。不能为空 </li>
<li>P:Primary Identifer是否是主标识符，表示实体唯一标识符 </li>
<li>D:Displayed显示出来，默认全部勾选</li>
</ul>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707175805226.png" alt="image-20220707175805226" style="float:left;"></p>
<p>在此上图说明name和code的起名方法</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707175827417.png" alt="image-20220707175827417" style="float:left;"></p>
<p><strong>设置主标识符</strong></p>
<p>如果不希望系统自动生成标识符而是手动设置的话，那么切换到Identifiers选项卡，添加一行Identifier， 然后单击左上角的“属性”按钮，然后弹出的标识属性设置对话框中单击“添加行”按钮，选择该标识中使用的属性。例如将学号设置为学生实体的标识。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707175858031.png" alt="image-20220707175858031" style="float:left;"></p>
<p><strong>放大模型</strong></p>
<p>创建好概念数据模型如图所示，但是创建好的字体很小，读者可以按着ctrl键同时滑动鼠标的可滑动按钮 即可放大缩写字体，同时也可以看到主标识符有一个*号的标志，同时也显示出来了，name,Data type和 length这些可见的属性</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707175925155.png" alt="image-20220707175925155" style="float:left;"></p>
<p><strong>实体关系</strong></p>
<p>同理创建一个班级的实体（需要特别注意的是，点击完右边功能的按钮后需要点击鼠标指针状态的按钮 或者右击鼠标即可，不然很容易乱操作，这点注意一下就可以了），然后使用Relationship（关系）这个 按钮可以连接学生和班级之间的关系，发生一对多（班级对学生）或者多对一（学生对班级）的关系。 </p>
<p>如图所示</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707175954634.png" alt="image-20220707175954634" style="float:left;"></p>
<p>需要注意的是点击Relationship这个按钮，就把班级和学生联系起来了，就是一条线，然后双击这条线进 行编辑，在General这块起name和code</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180021612.png" alt="image-20220707180021612" style="float:left;"></p>
<p>上面的name和code起好后就可以在Cardinalities这块查看班级和学生的关系，可以看到班级的一端是一 条线，学生的一端是三条，代表班级对学生是一对多的关系即one对many的关系，点击应用，然后确定 即可</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180044291.png" alt="image-20220707180044291" style="float:left;"></p>
<p>一对多和多对一练习完还有多对多的练习，如下图操作所示，老师实体和上面介绍的一样，自己将 name，data type等等修改成自己需要的即可，满足项目开发需求即可。（comment是解释说明，自己可以写相关的介绍和说明）</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180113532.png" alt="image-20220707180113532" style="float:left;"></p>
<p>多对多需要注意的是自己可以手动点击按钮将关系调整称为多对多的关系many对many的关系，然后点击应用和确定即可</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180159184.png" alt="image-20220707180159184" style="float:left;"></p>
<p>综上即可完成最简单的学生，班级，教师这种概念数据模型的设计，需要考虑数据的类型和主标识码， 是否为空。关系是一对一还是一对多还是多对多的关系，自己需要先规划好再设计，然后就ok了。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180254510.png" alt="image-20220707180254510"></p>
<h3 id="11-3-物理数据模型"><a href="#11-3-物理数据模型" class="headerlink" title="11.3 物理数据模型"></a>11.3 物理数据模型</h3><p>上面是概念数据模型，下面介绍一下物理数据模型，以后 经常使用 的就是物理数据模型。打开 PowerDesigner，然后点击File—&gt;New Model然后选择如下图所示的物理数据模型，物理数据模型的名字自己起，然后选择自己所使用的数据库即可。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180327712.png" alt="image-20220707180327712" style="float:left;"></p>
<p>创建好主页面如图所示，但是右边的按钮和概念模型略有差别，物理模型最常用的三个是 <code>table(表)</code> ， <code>view(视图)</code>， <code>reference(关系)</code>；</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180418090.png" alt="image-20220707180418090" style="float:left;"></p>
<p>鼠标先点击右边table这个按钮然后在新建的物理模型点一下，即可新建一个表，然后双击新建如下图所示，在General的name和code填上自己需要的，点击应用即可），如下图：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180449212.png" alt="image-20220707180449212" style="float:left;"></p>
<p>然后点击Columns,如下图设置，非常简单，需要注意的就是P（primary主键） , F （foreign key外键） , M（mandatory强制性的，代表不可为空） 这三个。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180537251.png" alt="image-20220707180537251" style="float:left;"></p>
<p>在此设置学号的自增（MYSQL里面的自增是这个AUTO_INCREMENT），班级编号同理，不多赘述！</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180556645.png" alt="image-20220707180556645" style="float:left;"></p>
<p>在下面的这个点上对号即可，就设置好了自增</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180619440.png" alt="image-20220707180619440" style="float:left;"></p>
<p>全部完成后如下图所示。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180643107.png" alt="image-20220707180643107" style="float:left;"></p>
<p>班级物理模型同理如下图所示创建即可</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180723698.png" alt="image-20220707180723698" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180744600.png" alt="image-20220707180744600" style="float:left;"></p>
<p>完成后如下图所示</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180806150.png" alt="image-20220707180806150" style="float:left;"></p>
<p>上面的设置好如上图所示，然后下面是关键的地方，点击右边按钮Reference这个按钮，因为是班级对学 生是一对多的，所以鼠标从学生拉到班级如下图所示，学生表将发生变化，学生表里面增加了一行，这 行是班级表的主键作为学生表的外键，将班级表和学生表联系起来。（仔细观察即可看到区别。）</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707180828164.png" alt="image-20220707180828164" style="float:left;"></p>
<p>做完上面的操作，就可以双击中间的一条线，显示如下图，修改name和code即可</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707183743297.png" alt="image-20220707183743297" style="float:left;"></p>
<p>但是需要注意的是，修改完毕后显示的结果却如下图所示，并没有办法直接像概念模型那样，修改过后 显示在中间的那条线上面，自己明白即可。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707193816176.png" alt="image-20220707193816176" style="float:left;"></p>
<p>学习了多对一或者一对多的关系，接下来学习多对对的关系，同理自己建好老师表，这里不在叙述，记得老师编号自增，建好如下图所示</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707193932694.png" alt="image-20220707193932694" style="float:left;"></p>
<p>下面是多对多关系的关键，由于物理模型多对多的关系需要一个中间表来连接，如下图，只设置一个字 段，主键，自增</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707193957629.png" alt="image-20220707193957629" style="float:left;"></p>
<p>点击应用，然后设置Columns，只添加一个字段</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194048843.png" alt="image-20220707194048843" style="float:left;"></p>
<p>这是设置字段递增，前面已经叙述过好几次</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194111885.png" alt="image-20220707194111885" style="float:left;"></p>
<p>设置好后如下图所示，需要注意的是有箭头的一方是一，无箭头的一方是多，即一对多的多对一的关系 需要搞清楚，学生也可以有很多老师，老师也可以有很多学生，所以学生和老师都可以是主体；</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194138137.png" alt="image-20220707194138137" style="float:left;"></p>
<p>可以看到添加关系以后学生和教师的关系表前后发生的变化</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194158936.png" alt="image-20220707194158936" style="float:left;"></p>
<h3 id="11-4-概念模型转为物理模型"><a href="#11-4-概念模型转为物理模型" class="headerlink" title="11.4 概念模型转为物理模型"></a>11.4 概念模型转为物理模型</h3><p>1：如下图所示先打开概念模型图，然后点击Tool,如下图所示</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194228064.png" alt="image-20220707194228064"></p>
<p>点开的页面如下所示，name和code已经从概念模型1改成物理模型1了</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194248236.png" alt="image-20220707194248236"></p>
<p>完成后如下图所示，将自行打开修改的物理模型，需要注意的是这些表的数据类型已经自行改变了，而 且中间表出现两个主键，即双主键</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194308595.png" alt="image-20220707194308595"></p>
<h3 id="11-5-物理模型转为概念模型"><a href="#11-5-物理模型转为概念模型" class="headerlink" title="11.5 物理模型转为概念模型"></a>11.5 物理模型转为概念模型</h3><p>上面介绍了概念模型转物理模型，下面介绍一下物理模型转概念模型（如下图点击操作即可）</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194405358.png" alt="image-20220707194405358"></p>
<p>然后出现如下图所示界面，然后将物理修改为概念 ，点击应用确认即可</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194419360.png" alt="image-20220707194419360"></p>
<p>点击确认后将自行打开如下图所示的页面，自己观察有何变化，如果转换为oracle的，数据类型会发生变 化，比如Varchar2等等）；</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194433407.png" alt="image-20220707194433407"></p>
<h3 id="11-6-物理模型导出SQL语句"><a href="#11-6-物理模型导出SQL语句" class="headerlink" title="11.6 物理模型导出SQL语句"></a>11.6 物理模型导出SQL语句</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194544714.png" alt="image-20220707194544714"></p>
<p>打开之后如图所示，修改好存在sql语句的位置和生成文件的名称即可</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194557554.png" alt="image-20220707194557554"></p>
<p>在Selection中选择需要导出的表，然后点击应用和确认即可</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194637242.png" alt="image-20220707194637242"></p>
<p>完成以后出现如下图所示，可以点击Edit或者close按钮</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707194727849.png" alt="image-20220707194727849"></p>
<p>自此，就完成了导出sql语句，就可以到自己指定的位置查看导出的sql语句了；PowerDesigner在以后在 项目开发过程中用来做需求分析和数据库的设计非常的方便和快捷。</p>
<h1 id="第12章-数据库其它调优策略"><a href="#第12章-数据库其它调优策略" class="headerlink" title="第12章_数据库其它调优策略"></a>第12章_数据库其它调优策略</h1><h2 id="1-数据库调优的措施"><a href="#1-数据库调优的措施" class="headerlink" title="1. 数据库调优的措施"></a>1. 数据库调优的措施</h2><h3 id="1-1-调优的目标"><a href="#1-1-调优的目标" class="headerlink" title="1.1 调优的目标"></a>1.1 调优的目标</h3><ul>
<li>尽可能节省系统资源 ，以便系统可以提供更大负荷的服务。（吞吐量更大） </li>
<li>合理的结构设计和参数调整，以提高用户操作响应的速度 。（响应速度更快） </li>
<li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li>
</ul>
<h3 id="1-2-如何定位调优问题"><a href="#1-2-如何定位调优问题" class="headerlink" title="1.2 如何定位调优问题"></a>1.2 如何定位调优问题</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707200915836.png" alt="image-20220707200915836" style="float:left;"></p>
<p>如何确定呢？一般情况下，有如下几种方式：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707201133424.png" alt="image-20220707201133424" style="float:left;"></p>
<h3 id="1-3-调优的维度和步骤"><a href="#1-3-调优的维度和步骤" class="headerlink" title="1.3 调优的维度和步骤"></a>1.3 调优的维度和步骤</h3><p>我们需要调优的对象是整个数据库管理系统，它不仅包括 SQL 查询，还包括数据库的部署配置、架构 等。从这个角度来说，我们思考的维度就不仅仅局限在 SQL 优化上了。通过如下的步骤我们进行梳理：</p>
<h4 id="第1步：选择适合的-DBMS"><a href="#第1步：选择适合的-DBMS" class="headerlink" title="第1步：选择适合的 DBMS"></a>第1步：选择适合的 DBMS</h4><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707201443229.png" alt="image-20220707201443229" style="float:left;"></p>
<h4 id="第2步：优化表设计"><a href="#第2步：优化表设计" class="headerlink" title="第2步：优化表设计"></a>第2步：优化表设计</h4><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707201617799.png" alt="image-20220707201617799" style="float:left;"></p>
<h4 id="第3步：优化逻辑查询"><a href="#第3步：优化逻辑查询" class="headerlink" title="第3步：优化逻辑查询"></a>第3步：优化逻辑查询</h4><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707202059972.png" alt="image-20220707202059972" style="float:left;"></p>
<h4 id="第4步：优化物理查询"><a href="#第4步：优化物理查询" class="headerlink" title="第4步：优化物理查询"></a>第4步：优化物理查询</h4><p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对 各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。<strong>在这个部分中，我们需要掌握的重点是对索引的创建和使用。</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707202156660.png" alt="image-20220707202156660" style="float:left;"></p>
<h4 id="第5步：使用-Redis-或-Memcached-作为缓存"><a href="#第5步：使用-Redis-或-Memcached-作为缓存" class="headerlink" title="第5步：使用 Redis 或 Memcached 作为缓存"></a>第5步：使用 Redis 或 Memcached 作为缓存</h4><p>除了可以对 SQL 本身进行优化以外，我们还可以请外援提升查询的效率。</p>
<p>因为数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作，当用 户量增大的时候，如果频繁地进行数据查询，会消耗数据库的很多资源。如果我们将常用的数据直接放 到内存中，就会大幅提升查询的效率。</p>
<p>键值存储数据库可以帮我们解决这个问题。</p>
<p>常用的键值存储数据库有 Redis 和 Memcached，它们都可以将数据存放到内存中。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707202436467.png" alt="image-20220707202436467" style="float:left;"></p>
<h4 id="第6步：库级优化"><a href="#第6步：库级优化" class="headerlink" title="第6步：库级优化"></a>第6步：库级优化</h4><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707202555506.png" alt="image-20220707202555506" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707202732911.png" alt="image-20220707202732911" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707203538155.png" alt="image-20220707203538155" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707203607993.png" alt="image-20220707203607993" style="float:left;"></p>
<blockquote>
<p>但需要注意的是，分拆在提升数据库性能的同时，也会增加维护和使用成本。</p>
</blockquote>
<h2 id="2-优化MySQL服务器"><a href="#2-优化MySQL服务器" class="headerlink" title="2. 优化MySQL服务器"></a>2. 优化MySQL服务器</h2><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707203818987.png" alt="image-20220707203818987" style="float:left;"></p>
<h3 id="2-1-优化服务器硬件"><a href="#2-1-优化服务器硬件" class="headerlink" title="2.1 优化服务器硬件"></a>2.1 优化服务器硬件</h3><p>服务器的硬件性能直接决定着MySQL数据库的性能。硬件的性能瓶颈直接决定MySQL数据库的运行速度 和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。 </p>
<p>（1） <code>配置较大的内存</code> 。足够大的显存是提高MySQL数据库性能的方法之一。内存的速度比磁盘I/O快得多，可以通过增加系统的<code>缓冲区容量</code>使数据在内存中停留的时间更长，以<code>减少磁盘I/O</code>。</p>
<p>（2） <code>配置高速磁盘系统</code>，以减少读盘的等待时间，提高响应速度。磁盘的I/O能力，也就是它的寻道能力，目前的SCSI高速旋转的是7200转/分钟，这样的速度，一旦访问的用户量上去，磁盘的压力就会过大，如果是每天的网站pv (page view) 在150w，这样的一般的配置就无法满足这样的需求了。现在SSD盛行，在SSD上随机访问和顺序访问性能差不多，使用SSD可以减少随机IO带来的性能损耗。</p>
<p>（3） <code>合理分布磁盘I/O</code>，把磁盘I/O分散在多个设备，以减少资源竞争，提高冰箱操作能力。</p>
<p>（4） <code>配置多处理器</code>, MySQL是多线程的数据库，多处理器可同时执行多个线程。</p>
<h3 id="2-2-优化MySQL的参数"><a href="#2-2-优化MySQL的参数" class="headerlink" title="2.2 优化MySQL的参数"></a>2.2 优化MySQL的参数</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707204403406.png" alt="image-20220707204403406" style="float:left;"></p>
<ul>
<li><p>innodb_buffer_pool_size ：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的 表 和索引的最大缓存 。它不仅仅缓存 索引数据 ，还会缓存 表的数据 。这个值越大，查询的速度就会越 快。但是这个值太大会影响操作系统的性能。</p>
</li>
<li><p>key_buffer_size ：表示 索引缓冲区的大小 。索引缓冲区是所有的 线程共享 。增加索引缓冲区可 以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存 的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在 4GB 左右 的服务器该参数可设置为 256M 或 384M 。</p>
</li>
<li><p>table_cache ：表示 同时打开的表的个数 。这个值越大，能够同时打开的表的个数越多。物理内 存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表 太多会影响操作系统的性能。</p>
</li>
<li><p>query_cache_size ：表示 查询缓冲区的大小 。可以通过在MySQL控制台观察，如果 Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size 的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效 率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很 多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。</p>
</li>
<li><p>query_cache_type 的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type=0并不 会导致MySQL释放query_cache_size所配置的缓存区内存。</p>
<ul>
<li>当query_cache_type=1时，所有的查询都将使用查询缓存区，除非在查询语句中指定 SQL_NO_CACHE ，如SELECT SQL_NO_CACHE * FROM tbl_name。</li>
<li>当query_cache_type=2时，只有在查询语句中使用 SQL_CACHE 关键字，查询才会使用查询缓 存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的 查询操作的情况。</li>
</ul>
</li>
<li><p>sort_buffer_size ：表示每个 需要进行排序的线程分配的缓冲区的大小 。增加这个参数的值可以 提高 ORDER BY 或 GROUP BY 操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB 左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。</p>
</li>
<li><p>join_buffer_size = 8M ：表示 联合查询操作所能使用的缓冲区大小 ，和sort_buffer_size一样， 该参数对应的分配内存也是每个连接独享。</p>
</li>
<li><p>read_buffer_size ：表示 每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节） 。当线 程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size=n可以临时设置该参 数的值。默认为64K，可以设置为4M。</p>
</li>
<li><p>innodb_flush_log_at_trx_commit ：表示 何时将缓冲区的数据写入日志文件 ，并且将日志文件 写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值 为1。</p>
<ul>
<li>值为 0 时，表示 每秒1次 的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的 commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导 致上一秒钟所有事务数据的丢失。</li>
<li>值为 1 时，表示 每次提交事务时 将数据写入日志文件并将日志文件写入磁盘进行同步。该模 式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入 （flush）硬盘。</li>
<li>值为 2 时，表示 每次提交事务时 将数据写入日志文件， 每隔1秒 将日志文件写入磁盘。该模 式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数 据才可能丢失。</li>
</ul>
</li>
<li><p>innodb_log_buffer_size ：这是 InnoDB 存储引擎的 事务日志所使用的缓冲区 。为了提高性能， 也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条 件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</p>
</li>
<li><p>max_connections ：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接 数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的 服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</p>
</li>
<li><p>back_log ：用于 控制MySQL监听TCP端口时设置的积压请求栈大小 。如果MySql的连接数达到 max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默 认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 对于Linux系统推荐设置为小于512 的整数，但最大不超过900。</p>
<p>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p>
</li>
<li><p>thread_cache_size ： 线程池缓存线程数量的大小 ，当客户端断开连接后将当前线程缓存起来， 当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可 以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为 120。</p>
<p>可以通过如下几个MySQL状态值来适当调整线程池的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;Thread%&#x27;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Threads_cached | 2 |</span><br><span class="line">| Threads_connected | 1 |</span><br><span class="line">| Threads_created | 3 |</span><br><span class="line">| Threads_running | 2 |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>当 Threads_cached 越来越少，但 Threads_connected 始终不降，且 Threads_created 持续升高，可 适当增加 thread_cache_size 的大小。</p>
</li>
<li><p>wait_timeout ：指定 一个请求的最大连接时间 ，对于4GB左右内存的服务器可以设置为5-10。</p>
</li>
<li><p>interactive_timeout ：表示服务器在关闭连接前等待行动的秒数。</p>
</li>
</ul>
<p>这里给出一份my.cnf的参考配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld]</span><br><span class="line">port = 3306 </span><br><span class="line">serverid = 1 </span><br><span class="line">socket = /tmp/mysql.sock </span><br><span class="line">skip-locking #避免MySQL的外部锁定，减少出错几率增强稳定性。 </span><br><span class="line">skip-name-resolve #禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！ </span><br><span class="line">back_log = 384</span><br><span class="line">key_buffer_size = 256M </span><br><span class="line">max_allowed_packet = 4M </span><br><span class="line">thread_stack = 256K</span><br><span class="line">table_cache = 128K </span><br><span class="line">sort_buffer_size = 6M </span><br><span class="line">read_buffer_size = 4M</span><br><span class="line">read_rnd_buffer_size=16M </span><br><span class="line">join_buffer_size = 8M </span><br><span class="line">myisam_sort_buffer_size =64M </span><br><span class="line">table_cache = 512 </span><br><span class="line">thread_cache_size = 64 </span><br><span class="line">query_cache_size = 64M</span><br><span class="line">tmp_table_size = 256M </span><br><span class="line">max_connections = 768 </span><br><span class="line">max_connect_errors = 10000000</span><br><span class="line">wait_timeout = 10 </span><br><span class="line">thread_concurrency = 8 #该参数取值为服务器逻辑CPU数量*2，在本例中，服务器有2颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为4*2=8</span><br><span class="line">skip-networking #开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项！否则将无法正常连接！ </span><br><span class="line">table_cache=1024</span><br><span class="line">innodb_additional_mem_pool_size=4M #默认为2M </span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">innodb_log_buffer_size=2M #默认为1M </span><br><span class="line">innodb_thread_concurrency=8 #你的服务器CPU有几个就设置为几。建议用默认一般为8 </span><br><span class="line">tmp_table_size=64M #默认为16M，调到64-256最挂</span><br><span class="line">thread_cache_size=120 </span><br><span class="line">query_cache_size=32M</span><br></pre></td></tr></table></figure>
<p>很多情况还需要具体情况具体分析！</p>
<p><strong>举例：</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707210351452.png" alt="image-20220707210351452" style="float:left;"></p>
<p><strong>(1) 调整系统参数 InnoDB_flush_log_at_trx_commit</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707210447501.png" alt="image-20220707210447501" style="float:left;"></p>
<p><strong>(2)  调整系统参数 InnoDB_buffer_pool_size</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707210555848.png" alt="image-20220707210555848" style="float:left;"></p>
<p><strong>(3) 调整系统参数 InnoDB_buffer_pool_instances</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707210720394.png" alt="image-20220707210720394" style="float:left;"></p>
<h2 id="3-优化数据库结构"><a href="#3-优化数据库结构" class="headerlink" title="3. 优化数据库结构"></a>3. 优化数据库结构</h2><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707211709553.png" alt="image-20220707211709553" style="float:left;"></p>
<h3 id="3-1-拆分表：冷热数据分离"><a href="#3-1-拆分表：冷热数据分离" class="headerlink" title="3.1 拆分表：冷热数据分离"></a>3.1 拆分表：冷热数据分离</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707211802756.png" alt="image-20220707211802756" style="float:left;"></p>
<p><strong>举例1：</strong> <code>会员members表</code> 存储会员登录认证信息，该表中有很多字段，如id、姓名、密码、地址、电 话、个人描述字段。其中地址、电话、个人描述等字段并不常用，可以将这些不常用的字段分解出另一 个表。将这个表取名叫members_detail，表中有member_id、address、telephone、description等字段。 这样就把会员表分成了两个表，分别为 <code>members表</code> 和 <code>members_detail表</code> 。</p>
<p>创建这两个表的SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE members (</span><br><span class="line">    id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    username varchar(50) DEFAULT NULL,</span><br><span class="line">    password varchar(50) DEFAULT NULL,</span><br><span class="line">    last_login_time datetime DEFAULT NULL,</span><br><span class="line">    last_login_ip varchar(100) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY(Id)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE members_detail (</span><br><span class="line">    Member_id int(11) NOT NULL DEFAULT 0,</span><br><span class="line">    address varchar(255) DEFAULT NULL,</span><br><span class="line">    telephone varchar(255) DEFAULT NULL,</span><br><span class="line">    description text</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果需要查询会员的基本信息或详细信息，那么可以用会员的id来查询。如果需要将会员的基本信息和 详细信息同时显示，那么可以将members表和members_detail表进行联合查询，查询语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM members LEFT JOIN members_detail on members.id =</span><br><span class="line">members_detail.member_id;</span><br></pre></td></tr></table></figure>
<p>通过这种分解可以提高表的查询效率。对于字段很多且有些字段使用不频繁的表，可以通过这种分解的方式来优化数据库的性能。</p>
<h3 id="3-2-增加中间表"><a href="#3-2-增加中间表" class="headerlink" title="3.2 增加中间表"></a>3.2 增加中间表</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707212800544.png" alt="image-20220707212800544" style="float:left;"></p>
<p>举例1： 学生信息表 和 班级表 的SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `class` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`className` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">`address` VARCHAR(40) DEFAULT NULL,</span><br><span class="line">`monitor` INT NULL ,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`stuno` INT NOT NULL ,</span><br><span class="line">`name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">`age` INT(3) DEFAULT NULL,</span><br><span class="line">`classId` INT(11) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p>现在有一个模块需要经常查询带有学生名称（name）、学生所在班级名称（className）、学生班级班 长（monitor）的学生信息。根据这种情况可以创建一个 temp_student 表。temp_student表中存储学生名称（stu_name）、学生所在班级名称（className）和学生班级班长（monitor）信息。创建表的语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `temp_student` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`stu_name` INT NOT NULL ,</span><br><span class="line">`className` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">`monitor` INT(3) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p>接下来，从学生信息表和班级表中查询相关信息存储到临时表中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into temp_student(stu_name,className,monitor)</span><br><span class="line">            select s.name,c.className,c.monitor</span><br><span class="line">            from student as s,class as c</span><br><span class="line">            where s.classId = c.id</span><br></pre></td></tr></table></figure>
<p>以后，可以直接从temp_student表中查询学生名称、班级名称和班级班长，而不用每次都进行联合查 询。这样可以提高数据库的查询速度。</p>
<h3 id="3-3-增加冗余字段"><a href="#3-3-增加冗余字段" class="headerlink" title="3.3 增加冗余字段"></a>3.3 增加冗余字段</h3><p>设计数据库表时应尽量遵循范式理论的规约，尽可能减少冗余字段，让数据库设计看起来精致、优雅。 但是，合理地加入冗余字段可以提高查询速度。</p>
<p>表的规范化程度越高，表与表之间的关系就越多，需要连接查询的情况也就越多。尤其在数据量大，而 且需要频繁进行连接的时候，为了提升效率，我们也可以考虑增加冗余字段来减少连接。</p>
<p>这部分内容在《第11章_数据库的设计规范》章节中 反范式化小节 中具体展开讲解了。这里省略。</p>
<h3 id="3-4-优化数据类型"><a href="#3-4-优化数据类型" class="headerlink" title="3.4 优化数据类型"></a>3.4 优化数据类型</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707213524137.png" alt="image-20220707213524137" style="float:left;"></p>
<p><strong>情况1：对整数类型数据进行优化。</strong></p>
<p>遇到整数类型的字段可以用 INT 型 。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数 据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以 的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p>
<p>对于 非负型 的数据（如自增ID、整型IP）来说，要优先使用无符号整型 UNSIGNED 来存储。因为无符号 相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128-127，无符号为0-255，多 出一倍的存储空间。</p>
<p><strong>情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型。</strong></p>
<p>跟文本类型数据相比，大整数往往占用更少的存储空间 ，因此，在存取和比对的时候，可以占用更少的 内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地 址转换成整型数据。</p>
<p><strong>情况3：避免使用TEXT、BLOB数据类型</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707214640374.png" alt="image-20220707214640374" style="float:left;"></p>
<p><strong>情况4：避免使用ENUM类型</strong></p>
<p>修改ENUM值需要使用ALTER语句。</p>
<p>ENUM类型的ORDER BY 操作效率低，需要额外操作。使用TINYINT来代替ENUM类型。</p>
<p><strong>情况5：使用TIMESTAMP存储时间</strong></p>
<p>TIMESTAMP存储的时间范围1970-01-01 00:00:01 ~ 2038-01_19-03:14:07。TIMESTAMP使用4字节，DATETIME使用8个字节，同时TIMESTAMP具有自动赋值以及自动更新的特性。</p>
<p><strong>情况6：用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</strong></p>
<p>1) 非精准浮点： float, double<br>2) 精准浮点：decimal</p>
<p>Decimal类型为精准浮点数，在计算时不会丢失精度，尤其是财务相关的金融类数据。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。</p>
<p><strong>总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充 分发挥资源的效率，使系统达到最优。</strong></p>
<h3 id="3-5-优化插入记录的速度"><a href="#3-5-优化插入记录的速度" class="headerlink" title="3.5 优化插入记录的速度"></a>3.5 优化插入记录的速度</h3><p>插入记录时，影响插入速度的主要是索引、唯一性校验、一次插入记录条数等。根据这些情况可以分别进行优化。这里我们分为MyISAM引擎和InnoDB引擎来讲。</p>
<p><strong>1. MyISAM引擎的表：</strong></p>
<p><strong>① 禁用索引</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707215305640.png" alt="image-20220707215305640" style="float:left;"></p>
<p><strong>② 禁用唯一性检查</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707215356893.png" alt="image-20220707215356893" style="float:left;"></p>
<p><strong>③ 使用批量插入</strong></p>
<p>插入多条记录时，可以使用一条INSERT语句插入一条数据，也可以使用一条INSERT语句插入多条数据。插入一条记录的INSERT语句情形如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(1,&#x27;zhangsan&#x27;,18,1);</span><br><span class="line">insert into student values(2,&#x27;lisi&#x27;,17,1);</span><br><span class="line">insert into student values(3,&#x27;wangwu&#x27;,17,1);</span><br><span class="line">insert into student values(4,&#x27;zhaoliu&#x27;,19,1);</span><br></pre></td></tr></table></figure>
<p>使用一条INSERT语句插入多条记录的情形如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values</span><br><span class="line">(1,&#x27;zhangsan&#x27;,18,1),</span><br><span class="line">(2,&#x27;lisi&#x27;,17,1),</span><br><span class="line">(3,&#x27;wangwu&#x27;,17,1),</span><br><span class="line">(4,&#x27;zhaoliu&#x27;,19,1);</span><br></pre></td></tr></table></figure>
<p>第2种情形的插入速度要比第1种情形快。</p>
<p><strong>④ 使用LOAD DATA INFILE 批量导入</strong></p>
<p>当需要批量导入数据时，如果能用LOAD DATA INFILE语句，就尽量使用。因为LOAD DATA INFILE语句导入数据的速度比INSERT语句块。</p>
<p><strong>2. InnoDB引擎的表：</strong></p>
<p><strong>① 禁用唯一性检查</strong></p>
<p>插入数据之前执行<code>set unique_checks=0</code>来禁止对唯一索引的检查，数据导入完成之后再运行<code>set unique_check=1</code>。这个和MyISAM引擎的使用方法一样。</p>
<p><strong>② 禁用外键检查</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707220034534.png" alt="image-20220707220034534" style="float:left;"></p>
<p><strong>③ 禁止自动提交</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707220131891.png" alt="image-20220707220131891" style="float:left;"></p>
<h3 id="3-6-使用非空约束"><a href="#3-6-使用非空约束" class="headerlink" title="3.6 使用非空约束"></a>3.6 使用非空约束</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707220157606.png" alt="image-20220707220157606" style="float:left;"></p>
<h3 id="3-7-分析表、检查表与优化表"><a href="#3-7-分析表、检查表与优化表" class="headerlink" title="3.7 分析表、检查表与优化表"></a>3.7 分析表、检查表与优化表</h3><p>MySQL提供了分析表、检查表和优化表的语句。<code>分析表</code>主要是分析关键字的分布，<code>检查表</code>主要是检查表是否存在错误，<code>优化表</code>主要是消除删除或者更新造成的空间浪费。</p>
<h4 id="1-分析表"><a href="#1-分析表" class="headerlink" title="1. 分析表"></a>1. 分析表</h4><p>MySQL中提供了ANALYZE TABLE语句分析表，ANALYZE TABLE语句的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name[,tbl_name]…</span><br></pre></td></tr></table></figure>
<p>默认的，MySQL服务会将 ANALYZE TABLE语句写到binlog中，以便在主从架构中，从服务能够同步数据。 可以添加参数LOCAL 或者 NO_WRITE_TO_BINLOG取消将语句写到binlog中。</p>
<p>使用 <code>ANALYZE TABLE</code> 分析表的过程中，数据库系统会自动对表加一个 <code>只读锁</code> 。在分析期间，只能读取 表中的记录，不能更新和插入记录。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p>
<p>ANALYZE TABLE分析后的统计结果会反应到 <code>cardinality</code> 的值，该值统计了表中某一键所在的列不重复 的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用</strong>。也就是索引列的cardinality的值与表中数据的总条数差距越大，即使查询的时候使用了该索引作为查 询条件，存储引擎实际查询的时候使用的概率就越小。下面通过例子来验证下。cardinality可以通过 SHOW INDEX FROM 表名查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ANALYZE TABLE user;</span><br><span class="line">+--------------+---------+----------+---------+</span><br><span class="line">| Table        | Op      | Msg_type |Msg_text |</span><br><span class="line">+--------------+---------+----------+---------+</span><br><span class="line">| atguigu.user | analyze | status   | Ok      |</span><br><span class="line">+--------------+----------+---------+---------+</span><br></pre></td></tr></table></figure>
<p>上面结果显示的信息说明如下：</p>
<ul>
<li>Table: 表示分析的表的名称。</li>
<li>Op: 表示执行的操作。analyze表示进行分析操作。</li>
<li>Msg_type: 表示信息类型，其值通常是状态 (status) 、信息 (info) 、注意 (note) 、警告 (warning) 和 错误 (error) 之一。</li>
<li>Msg_text: 显示信息。</li>
</ul>
<h4 id="2-检查表"><a href="#2-检查表" class="headerlink" title="2. 检查表"></a>2. 检查表</h4><p>MySQL中可以使用 <code>CHECK TABLE</code> 语句来检查表。CHECK TABLE语句能够检查InnoDB和MyISAM类型的表 是否存在错误。CHECK TABLE语句在执行过程中也会给表加上 <code>只读锁</code> 。</p>
<p>对于MyISAM类型的表，CHECK TABLE语句还会更新关键字统计数据。而且，CHECK TABLE也可以检查视 图是否有错误，比如在视图定义中被引用的表已不存在。该语句的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br></pre></td></tr></table></figure>
<p>其中，tbl_name是表名；option参数有5个取值，分别是QUICK、FAST、MEDIUM、EXTENDED和 CHANGED。各个选项的意义分别是：</p>
<ul>
<li>QUICK ：不扫描行，不检查错误的连接。 </li>
<li>FAST ：只检查没有被正确关闭的表。 </li>
<li>CHANGED ：只检查上次检查后被更改的表和没有被正确关闭的表。 </li>
<li>MEDIUM ：扫描行，以验证被删除的连接是有效的。也可以计算各行的关键字校验和，并使用计算出的校验和验证这一点。 </li>
<li>EXTENDED ：对每行的所有关键字进行一个全面的关键字查找。这可以确保表是100%一致的，但 是花的时间较长。</li>
</ul>
<p>option只对MyISAM类型的表有效，对InnoDB类型的表无效。比如：</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707221707254.png" alt="image-20220707221707254"></p>
<p>该语句对于检查的表可能会产生多行信息。最后一行有一个状态的 Msg_type 值，Msg_text 通常为 OK。 如果得到的不是 OK，通常要对其进行修复；是 OK 说明表已经是最新的了。表已经是最新的，意味着存 储引擎对这张表不必进行检查。</p>
<h4 id="3-优化表"><a href="#3-优化表" class="headerlink" title="3. 优化表"></a>3. 优化表</h4><p><strong>方式1：OPTIMIZE TABLE</strong></p>
<p>MySQL中使用 <code>OPTIMIZE TABLE</code> 语句来优化表。但是，OPTILMIZE TABLE语句只能优化表中的 <code>VARCHAR</code> 、 <code>BLOB</code> 或 <code>TEXT</code> 类型的字段。一个表使用了这些字段的数据类型，若已经 <code>删除</code> 了表的一大部 分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多 <code>更新</code> ，则 应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的 <code>碎片</code> 。</p>
<p>OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效。该语句在执行过程中也会给表加上 <code>只读锁</code> 。</p>
<p>OPTILMIZE TABLE语句的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>
<p>LOCAL | NO_WRITE_TO_BINLOG关键字的意义和分析表相同，都是指定不写入二进制日志。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707221901664.png" alt="image-20220707221901664"></p>
<p>执行完毕，Msg_text显示</p>
<blockquote>
<p>‘numysql.SYS_APP_USER’, ‘optimize’, ‘note’, ‘Table does not support optimize, doing recreate + analyze instead’</p>
</blockquote>
<p>原因是我服务器上的MySQL是InnoDB存储引擎。</p>
<p>到底优化了没有呢？看官网！</p>
<p><a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html">MySQL :: MySQL 8.0 Reference Manual :: 13.7.3.4 OPTIMIZE TABLE Statement</a></a></p>
<p>在MyISAM中，是先分析这张表，然后会整理相关的MySQL datafile，之后回收未使用的空间；在InnoDB 中，回收空间是简单通过Alter table进行整理空间。在优化期间，MySQL会创建一个临时表，优化完成之 后会删除原始表，然后会将临时表rename成为原始表。</p>
<blockquote>
<p>说明： 在多数的设置中，根本不需要运行OPTIMIZE TABLE。即使对可变长度的行进行了大量的更 新，也不需要经常运行，<code>每周一次</code> 或 <code>每月一次</code> 即可，并且只需要对 <code>特定的表</code> 运行。</p>
</blockquote>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707222156765.png" alt="image-20220707222156765" style="float:left;"></p>
<p><strong>方式二：使用mysqlcheck命令</strong></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707222305302.png" alt="image-20220707222305302" style="float:left;"></p>
<h4 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8 小结"></a>3.8 小结</h4><p>上述这些方法都是有利有弊的。比如：</p>
<ul>
<li>修改数据类型，节省存储空间的同时，你要考虑到数据不能超过取值范围； </li>
<li>增加冗余字段的时候，不要忘了确保数据一致性； </li>
<li>把大表拆分，也意味着你的查询会增加新的连接，从而增加额外的开销和运维的成本。</li>
</ul>
<p>因此，你一定要结合实际的业务需求进行权衡。</p>
<h2 id="4-大表优化"><a href="#4-大表优化" class="headerlink" title="4. 大表优化"></a>4. 大表优化</h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<h3 id="4-1-限定查询的范围"><a href="#4-1-限定查询的范围" class="headerlink" title="4.1 限定查询的范围"></a>4.1 限定查询的范围</h3><p>禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制 在一个月的范围内；</p>
<h3 id="4-2-读-写分离"><a href="#4-2-读-写分离" class="headerlink" title="4.2 读/写分离"></a>4.2 读/写分离</h3><p>经典的数据库拆分方案，主库负责写，从库负责读。</p>
<ul>
<li>一主一从模式：</li>
</ul>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707222606097.png" alt="image-20220707222606097"></p>
<ul>
<li>双主双从模式：</li>
</ul>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707222623485.png" alt="image-20220707222623485"></p>
<h3 id="4-3-垂直拆分"><a href="#4-3-垂直拆分" class="headerlink" title="4.3 垂直拆分"></a>4.3 垂直拆分</h3><p>当数据量级达到 <code>千万级</code> 以上时，有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上， 减少对单一数据库服务器的访问压力。</p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707222648112.png" alt="image-20220707222648112"></p>
<ul>
<li>如果数据库的数据表过多，可以采用<code>垂直分库</code>的方式，将关联的数据库部署在同一个数据库上。</li>
<li>如果数据库中的列过多，可以采用<code>垂直分表</code>的方式，将一张数据表分拆成多张数据表，把经常一起使用的列放在同一张表里。</li>
</ul>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707222910740.png" alt="image-20220707222910740"></p>
<p><code>垂直拆分的优点</code>： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。 </p>
<p><code>垂直拆分的缺点</code>： 主键会出现冗余，需要管理冗余列，并会引起 JOIN 操作。此外，垂直拆分会让事务变得更加复杂。</p>
<h3 id="4-4-水平拆分"><a href="#4-4-水平拆分" class="headerlink" title="4.4 水平拆分"></a>4.4 水平拆分</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707222954304.png" alt="image-20220707222954304" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707222739120.png" alt="image-20220707222739120"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707223024163.png" alt="image-20220707223024163" style="float:left;"></p>
<p>下面补充一下数据库分片的两种常见方案：</p>
<ul>
<li><strong>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。 </li>
<li><strong>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong>我们现在 谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<h2 id="5-其它调优策略"><a href="#5-其它调优策略" class="headerlink" title="5. 其它调优策略"></a>5. 其它调优策略</h2><h3 id="5-1-服务器语句超时处理"><a href="#5-1-服务器语句超时处理" class="headerlink" title="5.1 服务器语句超时处理"></a>5.1 服务器语句超时处理</h3><p>在MySQL 8.0中可以设置 服务器语句超时的限制 ，单位可以达到 毫秒级别 。当中断的执行语句超过设置的 毫秒数后，服务器将终止查询影响不大的事务或连接，然后将错误报给客户端。</p>
<p>设置服务器语句超时的限制，可以通过设置系统变量 MAX_EXECUTION_TIME 来实现。默认情况下， MAX_EXECUTION_TIME的值为0，代表没有时间限制。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL MAX_EXECUTION_TIME=2000;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET SESSION MAX_EXECUTION_TIME=2000; #指定该会话中SELECT语句的超时时间</span><br></pre></td></tr></table></figure>
<h3 id="5-2-创建全局通用表空间"><a href="#5-2-创建全局通用表空间" class="headerlink" title="5.2 创建全局通用表空间"></a>5.2 创建全局通用表空间</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707223246684.png" alt="image-20220707223246684" style="float:left;"></p>
<p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707223349879.png" alt="image-20220707223349879" style="float:left;"></p>
<h3 id="5-3-MySQL-8-0新特性：隐藏索引对调优的帮助"><a href="#5-3-MySQL-8-0新特性：隐藏索引对调优的帮助" class="headerlink" title="5.3 MySQL 8.0新特性：隐藏索引对调优的帮助"></a>5.3 MySQL 8.0新特性：隐藏索引对调优的帮助</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/image-20220707223420496.png" alt="image-20220707223420496" style="float:left;"></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post-share"><div class="social-share" data-image="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E4%BA%8B%E7%89%A9%E7%AF%87/" title="事务篇"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">事务篇</div></div><div class="info-2"><div class="info-item-1">第13章_事务基础知识1. 数据库事务概述1.1 存储引擎支持情况SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。  能看出在 MySQL 中，只有InnoDB 是支持事务的。 1.2 基本概念事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态。 事务处理的原则：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方 式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保 存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。 # 案例：AA用户给BB用户转账100update account set money = money - 100 where name = &#x27;AA&#x27;;# 服务器宕机update account set money = money + 100 where name = &#x27;BB&#x27;; 1.3...</div></div></div></a><a class="pagination-related" href="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" title="第01章_Java语言概述"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第01章_Java语言概述</div></div><div class="info-2"><div class="info-item-1">第01章_Java语言概述讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com  1. Java知识脉络图1.1 Java基础全程脉络图 1.2 本章专题与脉络 2. 抽丝剥茧话Java2.1 当前大学生就业形势 麦可思研究院发布了《2022年中国大学生就业报告》，针对2021届毕业生收入较高的本科专业排行榜：    麦可思研究院发布过《2021年中国大学生就业报告》，应届本科毕业生就业数量较大的前十位行业类的就业质量：   报告还对毕业三年后的2017届毕业生所在十大行业进行了统计：     从国家统计局发布的2021年全国平均工资来看，不管在城镇非私营单位还是私营单位，IT业均为最高。  2.2 IT互联网是否依旧靠谱过去不能代表未来！互联网是否依旧靠谱？！   2014 年至 2018 年间，我国网民规模从 6.49 亿增长为 8.29 亿，增幅为 27.5%。同一时间段，全国移动互联网接入的流量却从 20.6EB 增长到了 711.1EB，增幅达 3352%（获取和处理的信息量大幅增加）。  随着 5G...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E6%9E%B6%E6%9E%84%E7%AF%87/" title="架构篇"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-28</div><div class="info-item-2">架构篇</div></div><div class="info-2"><div class="info-item-1">第04章_逻辑架构1. 逻辑架构剖析1.1 服务器处理客户端请求首先MySQL是典型的C/S架构，即Clinet/Server 架构，服务端程序使用的mysqld。 不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果是：客户端进程向服务器进程发送一段文本（SQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。 那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为 例展示：  下面具体展开如下：  1.2 ConnectorsConnectors, 指的是不同语言中与SQL的交互。MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL，我们可以编写代码，跟MySQL Server 建立TCP连接，之后按照其定义好的协议进行交互。或者比较方便的方法是调用SDK，比如Native C API、JDBC、PHP等各语言MySQL Connecotr,或者通过ODBC。但通过SDK来访问MySQL，本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互 接下来的MySQL...</div></div></div></a><a class="pagination-related" href="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC00%E7%AB%A0_%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/" title="第00章_写在前面"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-17</div><div class="info-item-2">第00章_写在前面</div></div><div class="info-2"><div class="info-item-1">第00章_写在前面讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.comhttp://www.atguigu.com/)  一、MySQL数据库基础篇大纲MySQL数据库基础篇分为5个篇章： 1. 数据库概述与MySQL安装篇 第01章：数据库概述 第02章：MySQL环境搭建  2. SQL之SELECT使用篇 第03章：基本的SELECT语句 第04章：运算符 第05章：排序与分页 第06章：多表查询 第07章：单行函数 第08章：聚合函数 第09章：子查询  3. SQL之DDL、DML、DCL使用篇 第10章：创建和管理表 第11章：数据处理之增删改 第12章：MySQL数据类型精讲 第13章：约束  4. 其它数据库对象篇 第14章：视图 第15章：存储过程与函数 第16章：变量、流程控制与游标 第17章：触发器  5. MySQL8 新特性篇 第18章：MySQL8其它新特性  二、MySQL高级特性篇大纲MySQL高级特性分为4个篇章： 1....</div></div></div></a><a class="pagination-related" href="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E6%97%A5%E5%BF%97%E4%B8%8E%E5%A4%87%E4%BB%BD%E7%AF%87/" title="日志与备份篇"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-28</div><div class="info-item-2">日志与备份篇</div></div><div class="info-2"><div class="info-item-1">第17章_其他数据库日志 千万不要小看日志。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才 能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数 据库应用开发能力至关重要。 MySQL8.0 官网日志地址：“ https://dev.mysql.com/doc/refman/8.0/en/server-logs.html ” 1. MySQL支持的日志1.1 日志类型MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 二进制日志 、 错误日志 、 通用查询日志 和 慢查询日志 ，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志 和 数据定义语句日志 。使 用这些日志文件，可以查看MySQL内部发生的事情。 这6类日志分别为：  慢查询日志：记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。  通用查询日志：记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令， 对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。...</div></div></div></a><a class="pagination-related" href="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC00%E7%AB%A0_%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E/" title="第00章_写在最后"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-17</div><div class="info-item-2">第00章_写在最后</div></div><div class="info-2"><div class="info-item-1">第19章_写在最后分享1 分享2如何看待生活上、工作上的冗余、反冗余？ 又如何看待社会的脆弱性？反脆弱性？ 个人如何应对？ </div></div></div></a><a class="pagination-related" href="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/" title="第01章_数据库概述"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-17</div><div class="info-item-2">第01章_数据库概述</div></div><div class="info-2"><div class="info-item-1">第01章_数据库概述讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com  为什么要使用数据库 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。   生活中的例子：  数据库与数据库管理系统数据库的相关概念    DB：数据库（Database）     即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。   DBMS：数据库管理系统（Database Management System）   是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。   SQL：结构化查询语言（Structured Query...</div></div></div></a><a class="pagination-related" href="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/MySQL%E4%BA%8B%E7%89%A9%E7%AF%87/" title="事务篇"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-28</div><div class="info-item-2">事务篇</div></div><div class="info-2"><div class="info-item-1">第13章_事务基础知识1. 数据库事务概述1.1 存储引擎支持情况SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。  能看出在 MySQL 中，只有InnoDB 是支持事务的。 1.2 基本概念事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态。 事务处理的原则：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方 式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保 存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。 # 案例：AA用户给BB用户转账100update account set money = money - 100 where name = &#x27;AA&#x27;;# 服务器宕机update account set money = money + 100 where name = &#x27;BB&#x27;; 1.3...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">YZ</div><div class="author-info-description">YZ的博客,欢迎访问</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yangzhengyz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yangzhengyz" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2863057582yz@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/2863057582yz@gmail.com" target="_blank" title="twitter"><i class="fa-brands fa-twitter"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to  my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">1. 为什么使用索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2. 索引及其优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 索引概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BC%98%E7%82%B9"><span class="toc-text">2.2 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BC%BA%E7%82%B9"><span class="toc-text">2.3 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94"><span class="toc-text">3. InnoDB中索引的推演</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%B4%A2%E5%BC%95%E4%B9%8B%E5%89%8D%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-text">3.1 索引之前的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%A1%B5%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-text">1. 在一个页中的查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8%E5%BE%88%E5%A4%9A%E9%A1%B5%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-text">2. 在很多页中查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95"><span class="toc-text">3.2 设计索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-text">1. 一个简单的索引设计方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-InnoDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-text">2. InnoDB中的索引方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E8%BF%AD%E4%BB%A31%E6%AC%A1%EF%BC%9A%E7%9B%AE%E5%BD%95%E9%A1%B9%E7%BA%AA%E5%BD%95%E7%9A%84%E9%A1%B5"><span class="toc-text">① 迭代1次：目录项纪录的页</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E8%BF%AD%E4%BB%A32%E6%AC%A1%EF%BC%9A%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95%E9%A1%B9%E7%BA%AA%E5%BD%95%E7%9A%84%E9%A1%B5"><span class="toc-text">② 迭代2次：多个目录项纪录的页</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E8%BF%AD%E4%BB%A33%E6%AC%A1%EF%BC%9A%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95%E9%A1%B5%E7%9A%84%E7%9B%AE%E5%BD%95%E9%A1%B5"><span class="toc-text">③ 迭代3次：目录项记录页的目录页</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-B-Tree"><span class="toc-text">④ B+Tree</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5"><span class="toc-text">3.3 常见索引概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">1. 聚簇索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%88%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E3%80%81%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-text">2. 二级索引（辅助索引、非聚簇索引）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">3.联合索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-InnoDB%E7%9A%84B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">3.4 InnoDB的B+树索引的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B9%E9%A1%B5%E9%9D%A2%E4%BD%8D%E7%BD%AE%E4%B8%87%E5%B9%B4%E4%B8%8D%E5%8A%A8"><span class="toc-text">1. 根页面位置万年不动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E8%8A%82%E7%82%B9%E4%B8%AD%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-text">2. 内节点中目录项记录的唯一性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9C%80%E5%B0%91%E5%AD%98%E5%82%A8-2-%E6%9D%A1%E8%AE%B0%E5%BD%95"><span class="toc-text">3. 一个页面最少存储 2 条记录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MyISAM%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-text">4. MyISAM中的索引方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-MyISAM%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">4.1 MyISAM索引的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-MyISAM-%E4%B8%8E-InnoDB%E5%AF%B9%E6%AF%94"><span class="toc-text">4.2 MyISAM 与 InnoDB对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-text">5. 索引的代价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-MySQL%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9%E7%9A%84%E5%90%88%E7%90%86%E6%80%A7"><span class="toc-text">6. MySQL数据结构选择的合理性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%85%A8%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="toc-text">6.1 全表遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Hash%E7%BB%93%E6%9E%84"><span class="toc-text">6.2 Hash结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">6.3 二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-AVL%E6%A0%91"><span class="toc-text">6.4 AVL树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-B-Tree"><span class="toc-text">6.5 B-Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-B-Tree"><span class="toc-text">6.6 B+Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-R%E6%A0%91"><span class="toc-text">6.7 R树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E5%B0%8F%E7%BB%93"><span class="toc-text">6.8 小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">附录：算法的时间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">第7章_InnoDB数据存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A%E9%A1%B5"><span class="toc-text">1. 数据库的存储结构：页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%A3%81%E7%9B%98%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D%EF%BC%9A%E9%A1%B5"><span class="toc-text">1.1 磁盘与内存交互基本单位：页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%A1%B5%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-text">1.2 页结构概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">1.3 页的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E9%A1%B5%E7%9A%84%E4%B8%8A%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text">1.4 页的上层结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%A1%B5%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">2. 页的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9AFile-Header-%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8-%E5%92%8C-File-Trailer-%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8"><span class="toc-text">第一部分：File Header (文件头部) 和 File Trailer (文件尾部)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9AUser-Records-%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BD%95-%E3%80%81%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E3%80%81Free-Space-%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4"><span class="toc-text">第二部分：User Records (用户记录)、最大最小记录、Free Space (空闲空间)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9APage-Directory-%E9%A1%B5%E7%9B%AE%E5%BD%95-%E5%92%8C-Page-Header-%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8"><span class="toc-text">第三部分：Page Directory (页目录) 和 Page Header (页面头部)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A1%B5%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BB-%E6%A0%91%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.3 从数据库页的角度看B+树如何查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-InnoDB%E8%A1%8C%E6%A0%BC%E5%BC%8F-%E6%88%96%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="toc-text">3. InnoDB行格式 (或记录格式)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8C%BA%E3%80%81%E6%AE%B5%E4%B8%8E%E7%A2%8E%E7%89%87%E5%8C%BA"><span class="toc-text">4. 区、段与碎片区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8C%BA%EF%BC%9F"><span class="toc-text">4.1 为什么要有区？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%AE%B5%EF%BC%9F"><span class="toc-text">4.2 为什么要有段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%A2%8E%E7%89%87%E5%8C%BA%EF%BC%9F"><span class="toc-text">4.3 为什么要有碎片区？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%8C%BA%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">4.4 区的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">5. 表空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">5.1 独立表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">5.2 系统表空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">附录：数据页加载的三种方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">第8章_索引的创建与设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">1. 索引的声明与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">1.1 索引的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">1.2 创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">1. 创建表的时候创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E8%A1%A8%E4%B8%8A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">2. 在已经存在的表上创建索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-text">1.3 删除索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MySQL8-0%E7%B4%A2%E5%BC%95%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">2. MySQL8.0索引新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95"><span class="toc-text">2.1 支持降序索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95"><span class="toc-text">2.2 隐藏索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">3. 索引的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="toc-text">3.1 数据准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">3.2 哪些情况适合创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%97%E6%AE%B5%E7%9A%84%E6%95%B0%E5%80%BC%E6%9C%89%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">1. 字段的数值有唯一性的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A2%91%E7%B9%81%E4%BD%9C%E4%B8%BA-WHERE-%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-text">2. 频繁作为 WHERE 查询条件的字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%8F%E5%B8%B8-GROUP-BY-%E5%92%8C-ORDER-BY-%E7%9A%84%E5%88%97"><span class="toc-text">3. 经常 GROUP BY 和 ORDER BY 的列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-UPDATE%E3%80%81DELETE-%E7%9A%84-WHERE-%E6%9D%A1%E4%BB%B6%E5%88%97"><span class="toc-text">4. UPDATE、DELETE 的 WHERE 条件列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-DISTINCT-%E5%AD%97%E6%AE%B5%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">5.DISTINCT 字段需要创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A4%9A%E8%A1%A8-JOIN-%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">6. 多表 JOIN 连接操作时，创建索引注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BD%BF%E7%94%A8%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%B0%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">7. 使用列的类型小的创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">8. 使用字符串前缀创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%8C%BA%E5%88%86%E5%BA%A6%E9%AB%98-%E6%95%A3%E5%88%97%E6%80%A7%E9%AB%98-%E7%9A%84%E5%88%97%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">9. 区分度高(散列性高)的列适合作为索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E4%BD%BF%E7%94%A8%E6%9C%80%E9%A2%91%E7%B9%81%E7%9A%84%E5%88%97%E6%94%BE%E5%88%B0%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A6%E4%BE%A7"><span class="toc-text">10. 使用最频繁的列放到联合索引的左侧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E9%83%BD%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BC%98%E4%BA%8E%E5%8D%95%E5%80%BC%E7%B4%A2%E5%BC%95"><span class="toc-text">11. 在多个字段都要创建索引的情况下，联合索引优于单值索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%99%90%E5%88%B6%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-text">3.3 限制索引的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">3.4 哪些情况不适合创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%A8where%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%88%B0%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%AE%BE%E7%BD%AE%E7%B4%A2%E5%BC%95"><span class="toc-text">1. 在where中使用不到的字段，不要设置索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B0%8F%E7%9A%84%E8%A1%A8%E6%9C%80%E5%A5%BD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">2. 数据量小的表最好不要使用索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%89%E5%A4%A7%E9%87%8F%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%97%E4%B8%8A%E4%B8%8D%E8%A6%81%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-text">3. 有大量重复数据的列上不要建立索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%81%BF%E5%85%8D%E5%AF%B9%E7%BB%8F%E5%B8%B8%E6%9B%B4%E6%96%B0%E7%9A%84%E8%A1%A8%E5%88%9B%E5%BB%BA%E8%BF%87%E5%A4%9A%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-text">4.  避免对经常更新的表创建过多的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8%E6%97%A0%E5%BA%8F%E7%9A%84%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">5. 不建议用无序的值作为索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%88%A0%E9%99%A4%E4%B8%8D%E5%86%8D%E4%BD%BF%E7%94%A8%E6%88%96%E8%80%85%E5%BE%88%E5%B0%91%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-text">6. 删除不再使用或者很少使用的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%B8%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E5%A4%AF%E4%BD%99%E6%88%96%E9%87%8D%E5%A4%8D%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-text">7. 不要定义夯余或重复的索引</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC09%E7%AB%A0-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">第09章_性能分析工具的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-text">1. 数据库服务器的优化步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="toc-text">2. 查看系统性能参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BB%9F%E8%AE%A1SQL%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%88%90%E6%9C%AC-last-query-cost"><span class="toc-text">3. 统计SQL的查询成本: last_query_cost</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%9A%E4%BD%8D%E6%89%A7%E8%A1%8C%E6%85%A2%E7%9A%84-SQL%EF%BC%9A%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-text">4. 定位执行慢的 SQL：慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%BC%80%E5%90%AF%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0"><span class="toc-text">4.1 开启慢查询日志参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%9F%A5%E7%9C%8B%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%95%B0%E7%9B%AE"><span class="toc-text">4.2 查看慢查询数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-text">4.3 案例演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%88%86%E6%9E%90"><span class="toc-text">4.4 测试及分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9Amysqldumpslow"><span class="toc-text">4.5 慢查询日志分析工具：mysqldumpslow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%85%B3%E9%97%AD%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-text">4.6 关闭慢查询日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E5%88%A0%E9%99%A4%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-text">4.7 删除慢查询日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9F%A5%E7%9C%8B-SQL-%E6%89%A7%E8%A1%8C%E6%88%90%E6%9C%AC%EF%BC%9ASHOW-PROFILE"><span class="toc-text">5. 查看 SQL 执行成本：SHOW PROFILE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%88%86%E6%9E%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%EF%BC%9AEXPLAIN"><span class="toc-text">6. 分析查询语句：EXPLAIN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">6.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">6.2 基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="toc-text">6.3 数据准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-EXPLAIN%E5%90%84%E5%88%97%E4%BD%9C%E7%94%A8"><span class="toc-text">6.4 EXPLAIN各列作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-table"><span class="toc-text">1. table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-id"><span class="toc-text">2. id</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-select-type"><span class="toc-text">3. select_type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-partitions-%E5%8F%AF%E7%95%A5"><span class="toc-text">4. partitions (可略)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-type-%E2%98%86"><span class="toc-text">5. type ☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-possible-keys%E5%92%8Ckey"><span class="toc-text">6. possible_keys和key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-key-len-%E2%98%86"><span class="toc-text">7. key_len ☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-ref"><span class="toc-text">8. ref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-rows-%E2%98%86"><span class="toc-text">9. rows ☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-filtered"><span class="toc-text">10. filtered</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-Extra-%E2%98%86"><span class="toc-text">11. Extra ☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%B0%8F%E7%BB%93"><span class="toc-text">12. 小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-EXPLAIN%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BD%BF%E7%94%A8"><span class="toc-text">7. EXPLAIN的进一步使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-EXPLAIN%E5%9B%9B%E7%A7%8D%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-text">7.1 EXPLAIN四种输出格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%A0%E7%BB%9F%E6%A0%BC%E5%BC%8F"><span class="toc-text">1. 传统格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JSON%E6%A0%BC%E5%BC%8F"><span class="toc-text">2. JSON格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-TREE%E6%A0%BC%E5%BC%8F"><span class="toc-text">3. TREE格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%AF%E8%A7%86%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">4. 可视化输出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-SHOW-WARNINGS%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.2 SHOW WARNINGS的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E5%99%A8%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%9Atrace"><span class="toc-text">8. 分析优化器执行计划：trace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-MySQL%E7%9B%91%E6%8E%A7%E5%88%86%E6%9E%90%E8%A7%86%E5%9B%BE-sys-schema"><span class="toc-text">9. MySQL监控分析视图-sys schema</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-Sys-schema%E8%A7%86%E5%9B%BE%E6%91%98%E8%A6%81"><span class="toc-text">9.1 Sys schema视图摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-Sys-schema%E8%A7%86%E5%9B%BE%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">9.2 Sys schema视图使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%B0%8F%E7%BB%93"><span class="toc-text">10. 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">第10章_索引优化与查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="toc-text">1. 数据准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%A1%88%E4%BE%8B"><span class="toc-text">2. 索引失效案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D%E6%88%91%E6%9C%80%E7%88%B1"><span class="toc-text">2.1 全值匹配我最爱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-text">2.2 最佳左前缀法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%B8%BB%E9%94%AE%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F"><span class="toc-text">2.3 主键插入顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%AE%A1%E7%AE%97%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%87%AA%E5%8A%A8%E6%88%96%E6%89%8B%E5%8A%A8-%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">2.4 计算、函数、类型转换(自动或手动)导致索引失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">2.5 类型转换导致索引失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%88%97%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">2.6 范围条件右边的列索引失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E4%B8%8D%E7%AD%89%E4%BA%8E-%E6%88%96%E8%80%85-lt-gt-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">2.7 不等于(!&#x3D; 或者&lt;&gt;)索引失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-is-null%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8Cis-not-null%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">2.8 is null可以使用索引，is not null无法使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-like%E4%BB%A5%E9%80%9A%E9%85%8D%E7%AC%A6-%E5%BC%80%E5%A4%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">2.9 like以通配符%开头索引失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-OR-%E5%89%8D%E5%90%8E%E5%AD%98%E5%9C%A8%E9%9D%9E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97%EF%BC%8C%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">2.10 OR 前后存在非索引的列，索引失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BB%9F%E4%B8%80%E4%BD%BF%E7%94%A8utf8mb4"><span class="toc-text">2.11 数据库和表的字符集统一使用utf8mb4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-%E7%BB%83%E4%B9%A0%E5%8F%8A%E4%B8%80%E8%88%AC%E6%80%A7%E5%BB%BA%E8%AE%AE"><span class="toc-text">2.12 练习及一般性建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">3. 关联查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-1"><span class="toc-text">3.1 数据准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%87%87%E7%94%A8%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-text">3.2 采用左外连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%87%87%E7%94%A8%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-text">3.3 采用内连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-join%E8%AF%AD%E5%8F%A5%E5%8E%9F%E7%90%86"><span class="toc-text">3.4 join语句原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A9%B1%E5%8A%A8%E8%A1%A8%E5%92%8C%E8%A2%AB%E9%A9%B1%E5%8A%A8%E8%A1%A8"><span class="toc-text">1. 驱动表和被驱动表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Simple-Nested-Loop-Join-%E7%AE%80%E5%8D%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5"><span class="toc-text">2. Simple Nested-Loop Join (简单嵌套循环连接)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Index-Nested-Loop-Join-%EF%BC%88%E7%B4%A2%E5%BC%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="toc-text">3. Index Nested-Loop Join （索引嵌套循环连接）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Block-Nested-Loop-Join%EF%BC%88%E5%9D%97%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="toc-text">4. Block Nested-Loop Join（块嵌套循环连接）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Join%E5%B0%8F%E7%BB%93"><span class="toc-text">5. Join小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Hash-Join"><span class="toc-text">6. Hash Join</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%B0%8F%E7%BB%93"><span class="toc-text">3.5 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">4. 子查询优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-text">5. 排序优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-text">5.1 排序优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%B5%8B%E8%AF%95"><span class="toc-text">5.2 测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98"><span class="toc-text">5.3 案例实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-filesort%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E8%B7%AF%E6%8E%92%E5%BA%8F%E5%92%8C%E5%8D%95%E8%B7%AF%E6%8E%92%E5%BA%8F"><span class="toc-text">5.4 filesort算法：双路排序和单路排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-GROUP-BY%E4%BC%98%E5%8C%96"><span class="toc-text">6. GROUP BY优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BC%98%E5%8C%96%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-text">7. 优化分页查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-text">8. 优先考虑覆盖索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">8.1 什么是覆盖索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%A9%E5%BC%8A"><span class="toc-text">8.2 覆盖索引的利弊</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-text">9. 如何给字符串添加索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-text">9.1 前缀索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">9.2 前缀索引对覆盖索引的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-text">10. 索引下推</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E4%BD%BF%E7%94%A8%E5%89%8D%E5%90%8E%E5%AF%B9%E6%AF%94"><span class="toc-text">10.1 使用前后对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-ICP%E7%9A%84%E5%BC%80%E5%90%AF-%E5%85%B3%E9%97%AD"><span class="toc-text">10.2 ICP的开启&#x2F;关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-ICP%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">10.3 ICP使用案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%ADICP%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-text">10.4 开启和关闭ICP性能对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-ICP%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-text">10.5 ICP的使用条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95-vs-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-text">11. 普通索引 vs 唯一索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">11.1 查询过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B"><span class="toc-text">11.2 更新过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-change-buffer%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">11.3 change buffer的使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%85%B6%E5%AE%83%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-text">12. 其它查询优化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-EXISTS-%E5%92%8C-IN-%E7%9A%84%E5%8C%BA%E5%88%86"><span class="toc-text">12.1 EXISTS 和 IN 的区分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-COUNT-%E4%B8%8ECOUNT-%E5%85%B7%E4%BD%93%E5%AD%97%E6%AE%B5-%E6%95%88%E7%8E%87"><span class="toc-text">12.2 COUNT(*)与COUNT(具体字段)效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E5%85%B3%E4%BA%8ESELECT"><span class="toc-text">12.3 关于SELECT(*)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-LIMIT-1-%E5%AF%B9%E4%BC%98%E5%8C%96%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">12.4 LIMIT 1 对优化的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E5%A4%9A%E4%BD%BF%E7%94%A8COMMIT"><span class="toc-text">12.5 多使用COMMIT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%B7%98%E5%AE%9D%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">13. 淘宝数据库，主键如何设计的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E8%87%AA%E5%A2%9EID%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">13.1 自增ID的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E4%B8%9A%E5%8A%A1%E5%AD%97%E6%AE%B5%E5%81%9A%E4%B8%BB%E9%94%AE"><span class="toc-text">13.2 业务字段做主键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E6%B7%98%E5%AE%9D%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-text">13.3 淘宝的主键设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-%E6%8E%A8%E8%8D%90%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-text">13.4 推荐的主键设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-text">第11章_数据库的设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-text">1. 为什么需要数据库设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%8C%83-%E5%BC%8F"><span class="toc-text">2. 范 式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%8C%83%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-text">2.1 范式简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%8C%83%E5%BC%8F%E9%83%BD%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B"><span class="toc-text">2.2 范式都包括哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%94%AE%E5%92%8C%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2.3 键和相关属性的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F-1st-NF"><span class="toc-text">2.4 第一范式(1st NF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F-2nd-NF"><span class="toc-text">2.5 第二范式(2nd NF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F-3rd-NF"><span class="toc-text">2.6 第三范式(3rd NF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%B0%8F%E7%BB%93"><span class="toc-text">2.7 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%8D%E8%8C%83%E5%BC%8F%E5%8C%96"><span class="toc-text">3. 反范式化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-text">3.2 应用举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%8F%8D%E8%8C%83%E5%BC%8F%E7%9A%84%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-text">3.3 反范式的新问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%8F%8D%E8%8C%83%E5%BC%8F%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3.4 反范式的适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A2%9E%E5%8A%A0%E5%86%97%E4%BD%99%E5%AD%97%E6%AE%B5%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="toc-text">1. 增加冗余字段的建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8E%86%E5%8F%B2%E5%BF%AB%E7%85%A7%E3%80%81%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E7%9A%84%E9%9C%80%E8%A6%81"><span class="toc-text">2. 历史快照、历史数据的需要</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-BCNF-%E5%B7%B4%E6%96%AF%E8%8C%83%E5%BC%8F"><span class="toc-text">4. BCNF(巴斯范式)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F"><span class="toc-text">5. 第四范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F%E3%80%81%E5%9F%9F%E9%94%AE%E8%8C%83%E5%BC%8F"><span class="toc-text">6. 第五范式、域键范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B"><span class="toc-text">7. 实战案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E8%BF%AD%E4%BB%A31%E6%AC%A1%EF%BC%9A%E8%80%83%E8%99%911NF"><span class="toc-text">7.1 迭代1次：考虑1NF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E8%BF%AD%E4%BB%A32%E6%AC%A1%EF%BC%9A%E8%80%83%E8%99%912NF"><span class="toc-text">7.2 迭代2次：考虑2NF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E8%BF%AD%E4%BB%A33%E6%AC%A1%EF%BC%9A%E8%80%83%E8%99%913NF"><span class="toc-text">7.3 迭代3次：考虑3NF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%8F%8D%E8%8C%83%E5%BC%8F%E5%8C%96%EF%BC%9A%E4%B8%9A%E5%8A%A1%E4%BC%98%E5%85%88%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">7.4 反范式化：业务优先的原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-ER%E6%A8%A1%E5%9E%8B"><span class="toc-text">8. ER模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-ER%E6%A8%A1%E5%9E%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E8%A6%81%E7%B4%A0%EF%BC%9F"><span class="toc-text">8.1 ER模型包括哪些要素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%85%B3%E7%B3%BB%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">8.2 关系的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%BB%BA%E6%A8%A1%E5%88%86%E6%9E%90"><span class="toc-text">8.3 建模分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-ER-%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%86%E5%8C%96"><span class="toc-text">8.4 ER 模型的细化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-ER-%E6%A8%A1%E5%9E%8B%E5%9B%BE%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-text">8.5 ER 模型图转换成数据表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">1. 一个实体转换成一个数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%80%E4%B8%AA%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-text">2. 一个多对多的关系转换成一个数据表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%9A%E8%BF%87%E5%A4%96%E9%94%AE%E6%9D%A5%E8%A1%A8%E8%BE%BE1%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">3. 通过外键来表达1对多的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8A%8A%E5%B1%9E%E6%80%A7%E8%BD%AC%E6%8D%A2%E6%88%90%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-text">4. 把属性转换成表的字段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">9. 数据表的设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AE"><span class="toc-text">10. 数据库对象编写建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%85%B3%E4%BA%8E%E5%BA%93"><span class="toc-text">10.1 关于库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%85%B3%E4%BA%8E%E8%A1%A8%E3%80%81%E5%88%97"><span class="toc-text">10.2 关于表、列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95"><span class="toc-text">10.3 关于索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-SQL%E7%BC%96%E5%86%99"><span class="toc-text">10.4 SQL编写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-PowerDesigner%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">11. PowerDesigner的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%BC%80%E5%A7%8B%E7%95%8C%E9%9D%A2"><span class="toc-text">11.1 开始界面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E6%A6%82%E5%BF%B5%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-text">11.2 概念数据模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E7%89%A9%E7%90%86%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-text">11.3 物理数据模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B%E8%BD%AC%E4%B8%BA%E7%89%A9%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="toc-text">11.4 概念模型转为物理模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E7%89%A9%E7%90%86%E6%A8%A1%E5%9E%8B%E8%BD%AC%E4%B8%BA%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B"><span class="toc-text">11.5 物理模型转为概念模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-%E7%89%A9%E7%90%86%E6%A8%A1%E5%9E%8B%E5%AF%BC%E5%87%BASQL%E8%AF%AD%E5%8F%A5"><span class="toc-text">11.6 物理模型导出SQL语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5"><span class="toc-text">第12章_数据库其它调优策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98%E7%9A%84%E6%8E%AA%E6%96%BD"><span class="toc-text">1. 数据库调优的措施</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%B0%83%E4%BC%98%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-text">1.1 调优的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E8%B0%83%E4%BC%98%E9%97%AE%E9%A2%98"><span class="toc-text">1.2 如何定位调优问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%B0%83%E4%BC%98%E7%9A%84%E7%BB%B4%E5%BA%A6%E5%92%8C%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.3 调优的维度和步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC1%E6%AD%A5%EF%BC%9A%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E7%9A%84-DBMS"><span class="toc-text">第1步：选择适合的 DBMS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC2%E6%AD%A5%EF%BC%9A%E4%BC%98%E5%8C%96%E8%A1%A8%E8%AE%BE%E8%AE%A1"><span class="toc-text">第2步：优化表设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC3%E6%AD%A5%EF%BC%9A%E4%BC%98%E5%8C%96%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2"><span class="toc-text">第3步：优化逻辑查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC4%E6%AD%A5%EF%BC%9A%E4%BC%98%E5%8C%96%E7%89%A9%E7%90%86%E6%9F%A5%E8%AF%A2"><span class="toc-text">第4步：优化物理查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC5%E6%AD%A5%EF%BC%9A%E4%BD%BF%E7%94%A8-Redis-%E6%88%96-Memcached-%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98"><span class="toc-text">第5步：使用 Redis 或 Memcached 作为缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC6%E6%AD%A5%EF%BC%9A%E5%BA%93%E7%BA%A7%E4%BC%98%E5%8C%96"><span class="toc-text">第6步：库级优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BC%98%E5%8C%96MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">2. 优化MySQL服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6"><span class="toc-text">2.1 优化服务器硬件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BC%98%E5%8C%96MySQL%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">2.2 优化MySQL的参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84"><span class="toc-text">3. 优化数据库结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%8B%86%E5%88%86%E8%A1%A8%EF%BC%9A%E5%86%B7%E7%83%AD%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB"><span class="toc-text">3.1 拆分表：冷热数据分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%A2%9E%E5%8A%A0%E4%B8%AD%E9%97%B4%E8%A1%A8"><span class="toc-text">3.2 增加中间表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%A2%9E%E5%8A%A0%E5%86%97%E4%BD%99%E5%AD%97%E6%AE%B5"><span class="toc-text">3.3 增加冗余字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.4 优化数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E4%BC%98%E5%8C%96%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95%E7%9A%84%E9%80%9F%E5%BA%A6"><span class="toc-text">3.5 优化插入记录的速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E4%BD%BF%E7%94%A8%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F"><span class="toc-text">3.6 使用非空约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%88%86%E6%9E%90%E8%A1%A8%E3%80%81%E6%A3%80%E6%9F%A5%E8%A1%A8%E4%B8%8E%E4%BC%98%E5%8C%96%E8%A1%A8"><span class="toc-text">3.7 分析表、检查表与优化表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-text">1. 分析表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A3%80%E6%9F%A5%E8%A1%A8"><span class="toc-text">2. 检查表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E5%8C%96%E8%A1%A8"><span class="toc-text">3. 优化表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-%E5%B0%8F%E7%BB%93"><span class="toc-text">3.8 小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="toc-text">4. 大表优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%99%90%E5%AE%9A%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-text">4.1 限定查询的范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%AF%BB-%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-text">4.2 读&#x2F;写分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="toc-text">4.3 垂直拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86"><span class="toc-text">4.4 水平拆分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5"><span class="toc-text">5. 其它调优策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%AD%E5%8F%A5%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86"><span class="toc-text">5.1 服务器语句超时处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%88%9B%E5%BB%BA%E5%85%A8%E5%B1%80%E9%80%9A%E7%94%A8%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">5.2 创建全局通用表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-MySQL-8-0%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%B0%83%E4%BC%98%E7%9A%84%E5%B8%AE%E5%8A%A9"><span class="toc-text">5.3 MySQL 8.0新特性：隐藏索引对调优的帮助</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/JUC/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java并发编程学习笔记"><img src="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发编程学习笔记"/></a><div class="content"><a class="title" href="/2025/03/01/JUC/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java并发编程学习笔记">Java并发编程学习笔记</a><time datetime="2025-03-01T08:44:39.000Z" title="发表于 2025-03-01 16:44:39">2025-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/16/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/" title="代码演示"><img src="https://img1.baidu.com/it/u=3486908499,2121835088&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码演示"/></a><div class="content"><a class="title" href="/2024/05/16/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/" title="代码演示">代码演示</a><time datetime="2024-05-16T13:02:53.090Z" title="发表于 2024-05-16 21:02:53">2024-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/16/hello-world/" title="Hello World"><img src="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2024/05/16/hello-world/" title="Hello World">Hello World</a><time datetime="2024-05-16T13:02:41.430Z" title="发表于 2024-05-16 21:02:41">2024-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/08/Java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6/" title="泛型和通配符"><img src="https://img1.baidu.com/it/u=3486908499,2121835088&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="泛型和通配符"/></a><div class="content"><a class="title" href="/2023/08/08/Java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6/" title="泛型和通配符">泛型和通配符</a><time datetime="2023-08-08T02:17:47.000Z" title="发表于 2023-08-08 10:17:47">2023-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/01/Java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EThreadLocal/" title="关于ThreadLocal"><img src="https://img1:baidu:com/it/u=1777496104,822946362&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于ThreadLocal"/></a><div class="content"><a class="title" href="/2023/08/01/Java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EThreadLocal/" title="关于ThreadLocal">关于ThreadLocal</a><time datetime="2023-08-01T03:11:23.000Z" title="发表于 2023-08-01 11:11:23">2023-08-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By YZ</div><div class="footer_custom_text">很高兴认识你</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="7193364325" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true 
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>