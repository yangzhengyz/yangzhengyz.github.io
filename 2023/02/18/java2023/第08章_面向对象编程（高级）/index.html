<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第08章_面向对象编程(高级) | YZ</title><meta name="author" content="YZ"><meta name="copyright" content="YZ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第08章_面向对象编程(高级)讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com  本章专题与脉络 1. 关键字：static回顾类中的实例变量（即非static的成员变量） class Circle&amp;#123;	private double..."><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "第08章_面向对象编程(高级)",
  "url": "http://example.com/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/",
  "image": "https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360",
  "datePublished": "2023-02-18T12:37:01.000Z",
  "dateModified": "2023-03-14T06:16:10.942Z",
  "author": [
    {
      "@type": "Person",
      "name": "YZ",
      "url": "https://github.com/yangzhengyz"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第08章_面向对象编程(高级)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="YZ" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic2.zhimg.com%2F50%2Fv2-64c5dbd1e6a174f1371a13b018df0a8d_r.jpg&amp;refer=http%3A%2F%2Fpic2.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1654421720&amp;t=cf6b4b204d29dc42447fb634cdc8bd33));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">YZ</span></a><a class="nav-page-title" href="/"><span class="site-name">第08章_面向对象编程(高级)</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">第08章_面向对象编程(高级)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-18T12:37:01.000Z" title="发表于 2023-02-18 20:37:01">2023-02-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-14T06:16:10.942Z" title="更新于 2023-03-14 14:16:10">2023-03-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java2023/">Java2023</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">22.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>86分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="第08章-面向对象编程-高级"><a href="#第08章-面向对象编程-高级" class="headerlink" title="第08章_面向对象编程(高级)"></a>第08章_面向对象编程(高级)</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p>
<p>官网：<a target="_blank" rel="noopener" href="http://www.atguigu.com/">http://www.atguigu.com</a></p>
<hr>
<h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/第2阶段：Java面向对象编程-第08章.png" alt="第2阶段：Java面向对象编程-第08章" style="zoom: 40%;"></p>
<h2 id="1-关键字：static"><a href="#1-关键字：static" class="headerlink" title="1. 关键字：static"></a>1. 关键字：static</h2><p><strong>回顾类中的实例变量（即非static的成员变量）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.radius=radius;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI*radius*radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建两个Circle对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Circle c1=<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2.0</span>);	<span class="comment">//c1.radius=2.0</span></span><br><span class="line">Circle c2=<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">3.0</span>);	<span class="comment">//c2.radius=3.0</span></span><br></pre></td></tr></table></figure>
<p>Circle类中的变量radius是一个实例变量(instance variable)，它属于类的每一个对象，c1中的radius变化不会影响c2的radius，反之亦然。</p>
<p><strong>如果想让一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（或类属性）！</strong></p>
<h3 id="1-1-类属性、类方法的设计思想"><a href="#1-1-类属性、类方法的设计思想" class="headerlink" title="1.1 类属性、类方法的设计思想"></a>1.1 类属性、类方法的设计思想</h3><p>当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，<code>某些特定的数据在内存空间里只有一份</code>。例如，所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325213629311.png" alt="image-20220325213629311"></p>
<p>此外，在类中声明的实例方法，在类的外面必须要先创建对象，才能调用。但是有些方法的调用者和当前类的对象无关，这样的方法通常被声明为<code>类方法</code>，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。</p>
<p>这里的类变量、类方法，只需要使用<code>static</code>修饰即可。所以也称为静态变量、静态方法。</p>
<h3 id="1-2-static关键字"><a href="#1-2-static关键字" class="headerlink" title="1.2 static关键字"></a>1.2 static关键字</h3><ul>
<li><p>使用范围：</p>
<ul>
<li>在Java类中，可用static修饰属性、方法、代码块、内部类</li>
</ul>
</li>
<li><p>被修饰后的成员具备以下特点：</p>
<ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰的成员，被所有对象所共享</li>
<li>访问权限允许时，可不创建对象，直接被类调用</li>
</ul>
</li>
</ul>
<h3 id="1-3-静态变量"><a href="#1-3-静态变量" class="headerlink" title="1.3 静态变量"></a>1.3 静态变量</h3><h4 id="1-3-1-语法格式"><a href="#1-3-1-语法格式" class="headerlink" title="1.3.1 语法格式"></a>1.3.1 语法格式</h4><p>使用static修饰的成员变量就是静态变量（或类变量、类属性）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类&#123;</span><br><span class="line">	[其他修饰符] <span class="keyword">static</span> 数据类型 变量名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-静态变量的特点"><a href="#1-3-2-静态变量的特点" class="headerlink" title="1.3.2 静态变量的特点"></a>1.3.2 静态变量的特点</h4><ul>
<li>静态变量的默认值规则和实例变量一样。</li>
<li><p>静态变量值是所有对象共享。</p>
</li>
<li><p>静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。</p>
</li>
<li>如果权限修饰符允许，在其他类中可以通过“<code>类名.静态变量</code>”直接访问，也可以通过“<code>对象.静态变量</code>”的方式访问（但是更推荐使用类名.静态变量的方式）。</li>
<li>静态变量的get/set方法也静态的，当局部变量与静态变量<code>重名时</code>，使用“<code>类名.静态变量</code>”进行区分。</li>
</ul>
<h4 id="1-3-3-举例"><a href="#1-3-3-举例" class="headerlink" title="1.3.3 举例"></a>1.3.3 举例</h4><p>举例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//类变量</span></span><br><span class="line">    <span class="keyword">static</span> String nation;<span class="comment">//国籍</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chinese&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, nation=&#x27;&quot;</span> + nation + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;康师傅&quot;</span>,<span class="number">36</span>);</span><br><span class="line">        c1.nation = <span class="string">&quot;中华人民共和国&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;老干妈&quot;</span>,<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line"></span><br><span class="line">        System.out.println(Chinese.nation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的内存结构：（以经典的JDK6内存解析为例，此时静态变量存储在方法区）</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220514183814514.png" alt="image-20220514183814514" style="zoom:67%;"></p>
<p>举例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> total;<span class="comment">//这里私有化，在类的外面必须使用get/set方法的方式来访问静态变量</span></span><br><span class="line">    <span class="keyword">static</span> String company; <span class="comment">//这里缺省权限修饰符，是为了方便类外以“类名.静态变量”的方式访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">        total++;</span><br><span class="line">        id = total;<span class="comment">//这里使用total静态变量的值为id属性赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTotal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setTotal</span><span class="params">(<span class="type">int</span> total)</span> &#123;</span><br><span class="line">        Employee.total = total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee&#123;company = &quot;</span> + company + <span class="string">&quot;,id = &quot;</span> + id + <span class="string">&quot; ,name=&quot;</span> + name +<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStaticVariable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//静态变量total的默认值是0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee.total = &quot;</span> + Employee.getTotal());</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(e1);<span class="comment">//静态变量company的默认值是null</span></span><br><span class="line">        System.out.println(e2);<span class="comment">//静态变量company的默认值是null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee.total = &quot;</span> + Employee.getTotal());<span class="comment">//静态变量total值是2</span></span><br><span class="line"></span><br><span class="line">        Employee.company = <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line">        System.out.println(e1);<span class="comment">//静态变量company的值是尚硅谷</span></span><br><span class="line">        System.out.println(e2);<span class="comment">//静态变量company的值是尚硅谷</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要权限修饰符允许,虽然不推荐，但是也可以通过“对象.静态变量”的形式来访问</span></span><br><span class="line">        e1.company = <span class="string">&quot;超级尚硅谷&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(e1);<span class="comment">//静态变量company的值是超级尚硅谷</span></span><br><span class="line">        System.out.println(e2);<span class="comment">//静态变量company的值是超级尚硅谷</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-4-内存解析"><a href="#1-3-4-内存解析" class="headerlink" title="1.3.4 内存解析"></a>1.3.4 内存解析</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220104100145059.png" alt="image-20220104100145059"></p>
<h3 id="1-4-静态方法"><a href="#1-4-静态方法" class="headerlink" title="1.4 静态方法"></a>1.4 静态方法</h3><h4 id="1-4-1-语法格式"><a href="#1-4-1-语法格式" class="headerlink" title="1.4.1 语法格式"></a>1.4.1 语法格式</h4><p>用static修饰的成员方法就是静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类&#123;</span><br><span class="line">	[其他修饰符] <span class="keyword">static</span> 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">        方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-2-静态方法的特点"><a href="#1-4-2-静态方法的特点" class="headerlink" title="1.4.2 静态方法的特点"></a>1.4.2 静态方法的特点</h4><ul>
<li>静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。</li>
<li>只要权限修饰符允许，静态方法在其他类中可以通过“类名.静态方法“的方式调用。也可以通过”对象.静态方法“的方式调用（但是更推荐使用类名.静态方法的方式）。</li>
<li>在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。</li>
<li>静态方法可以被子类继承，但不能被子类重写。</li>
<li>静态方法的调用都只看编译时类型。</li>
<li>因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。</li>
</ul>
<h4 id="1-4-3-举例"><a href="#1-4-3-举例" class="headerlink" title="1.4.3 举例"></a>1.4.3 举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.fun&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="comment">//    @Override //尝试重写静态方法，加上@Override编译报错，去掉Override不报错，但是也不是重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son.fun&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStaticMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Father.method();</span><br><span class="line">        Son.method();<span class="comment">//继承静态方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        f.method();<span class="comment">//执行Father类中的method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-练习"><a href="#1-5-练习" class="headerlink" title="1.5 练习"></a>1.5 练习</h3><p>笔试题：如下程序执行会不会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 14:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        test.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>练习：</p>
<p>编写一个类实现银行账户的概念，包含的属性有“帐号”、“密码”、“存款余额”、“利率”、“最小余额”，定义封装这些属性的方法。<code>账号要自动生成。</code></p>
<p>编写主类，使用银行账户类，输入、输出3个储户的上述信息。</p>
<p>考虑：哪些属性可以设计成static属性。</p>
<h2 id="2-单例-Singleton-设计模式"><a href="#2-单例-Singleton-设计模式" class="headerlink" title="2. 单例(Singleton)设计模式"></a>2. 单例(Singleton)设计模式</h2><h3 id="2-1-设计模式概述"><a href="#2-1-设计模式概述" class="headerlink" title="2.1 设计模式概述"></a>2.1 设计模式概述</h3><p><strong>设计模式</strong>是在大量的<code>实践中总结</code>和<code>理论化</code>之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”套路”</p>
<p>经典的设计模式共有23种。每个设计模式均是特定环境下特定问题的处理方法。</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220520174508815.png" alt="image-20220520174508815" style="zoom: 80%;"></p>
<blockquote>
<p>简单工厂模式并不是23中经典模式的一种，是其中工厂方法模式的简化版</p>
<p>对软件设计模式的研究造就了一本可能是面向对象设计方面最有影响的书籍：《设计模式》：《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为”四人组（Gang of Four）”，而这本书也就被称为”四人组（或 GoF）”书。</p>
</blockquote>
<h3 id="2-2-何为单例模式"><a href="#2-2-何为单例模式" class="headerlink" title="2.2 何为单例模式"></a>2.2 何为单例模式</h3><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。</p>
<h3 id="2-3-实现思路"><a href="#2-3-实现思路" class="headerlink" title="2.3 实现思路"></a>2.3 实现思路</h3><p>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将<code>类的构造器的访问权限设置为private</code>，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，<code>只能调用该类的某个静态方法</code>以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的<code>该类对象的变量也必须定义成静态的</code>。</p>
<h3 id="2-4-单例模式的两种实现方式"><a href="#2-4-单例模式的两种实现方式" class="headerlink" title="2.4 单例模式的两种实现方式"></a>2.4 单例模式的两种实现方式</h3><h4 id="2-4-1-饿汉式"><a href="#2-4-1-饿汉式" class="headerlink" title="2.4.1 饿汉式"></a>2.4.1 饿汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-懒汉式"><a href="#2-4-2-懒汉式" class="headerlink" title="2.4.2 懒汉式"></a>2.4.2 懒汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single;</span><br><span class="line">    <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">null</span>) &#123;</span><br><span class="line">            single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-饿汉式-vs-懒汉式"><a href="#2-4-3-饿汉式-vs-懒汉式" class="headerlink" title="2.4.3 饿汉式 vs 懒汉式"></a>2.4.3 饿汉式 vs 懒汉式</h4><p>饿汉式：</p>
<ul>
<li>特点：<code>立即加载</code>，即在使用类的时候已经将对象创建完毕。</li>
<li>优点：实现起来<code>简单</code>；没有多线程安全问题。</li>
<li>缺点：当类被加载的时候，会初始化static的实例，静态变量被创建并分配内存空间，从这以后，这个static的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会<code>耗费内存</code>。</li>
</ul>
<p>懒汉式：</p>
<ul>
<li>特点：<code>延迟加载</code>，即在调用静态方法时实例才被创建。</li>
<li>优点：实现起来比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会<code>节约内存</code>。</li>
<li>缺点：在多线程环境中，这种实现方法是完全错误的，<code>线程不安全</code>，根本不能保证单例的唯一性。<ul>
<li>说明：在多线程章节，会将懒汉式改造成线程安全的模式。</li>
</ul>
</li>
</ul>
<h3 id="2-5-单例模式的优点及应用场景"><a href="#2-5-单例模式的优点及应用场景" class="headerlink" title="2.5 单例模式的优点及应用场景"></a>2.5 单例模式的优点及应用场景</h3><p>由于单例模式只生成一个实例，减少了<code>系统性能开销</code>，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</p>
<p>举例：</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325222541203.png" alt="image-20220325222541203" style="zoom:67%;"></p>
<p><strong>应用场景</strong></p>
<ul>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
<li><p>Application 也是单例的典型应用</p>
</li>
<li><p>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只</p>
<p>能有一个实例去操作，否则内容不好追加。</p>
</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
</ul>
<h2 id="3-理解main方法的语法"><a href="#3-理解main方法的语法" class="headerlink" title="3. 理解main方法的语法"></a>3. 理解main方法的语法</h2><p>由于JVM需要调用类的main()方法，所以该方法的访问权限必须是public，又因为JVM在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。 </p>
<p>又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。</p>
<p><strong>命令行参数用法举例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandPara</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;args[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行程序CommandPara.java</span></span><br><span class="line">java CommandPara <span class="string">&quot;Tom&quot;</span> <span class="string">&quot;Jerry&quot;</span> <span class="string">&quot;Shkstart&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">args[<span class="number">0</span>] = Tom</span><br><span class="line">args[<span class="number">1</span>] = Jerry</span><br><span class="line">args[<span class="number">2</span>] = Shkstart</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325223215924.png" alt="image-20220325223215924"></p>
<p>IDEA工具：</p>
<p>（1）配置运行参数</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20211228101828718.png" alt="image-20211228101828718" style="zoom: 80%;"></p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20211228102022216.png" alt="image-20211228102022216" style="zoom:67%;"></p>
<p>（2）运行程序</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20211228102059327.png" alt="image-20211228102059327" style="zoom: 80%;"></p>
<p>笔试题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处，Something类的文件名叫OtherThing.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] something_to_do)</span> &#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;Do something ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上述程序是否可以正常编译、运行？ </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-类的成员之四：代码块"><a href="#4-类的成员之四：代码块" class="headerlink" title="4. 类的成员之四：代码块"></a>4. 类的成员之四：代码块</h2><p>如果成员变量想要初始化的值不是一个硬编码的常量值，而是需要通过复杂的计算或读取文件、或读取运行环境信息等方式才能获取的一些值，该怎么办呢？此时，可以考虑代码块（或初始化块）。</p>
<ul>
<li><p>代码块(或初始化块)的<code>作用</code>：</p>
<ul>
<li>对Java类或对象进行初始化</li>
</ul>
</li>
<li><p>代码块(或初始化块)的<code>分类</code>：</p>
<ul>
<li><p>一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)</p>
</li>
<li><p>没有使用static修饰的，为非静态代码块。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-1-静态代码块"><a href="#4-1-静态代码块" class="headerlink" title="4.1 静态代码块"></a>4.1 静态代码块</h3><p>如果想要为静态变量初始化，可以直接在静态变量的声明后面直接赋值，也可以使用静态代码块。</p>
<h4 id="4-1-1-语法格式"><a href="#4-1-1-语法格式" class="headerlink" title="4.1.1 语法格式"></a>4.1.1 语法格式</h4><p>在代码块的前面加static，就是静态代码块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 类&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">        静态代码块</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-静态代码块的特点"><a href="#4-1-2-静态代码块的特点" class="headerlink" title="4.1.2 静态代码块的特点"></a>4.1.2 静态代码块的特点</h4><ol>
<li><p>可以有输出语句。</p>
<ol>
<li><p>可以对类的属性、类的声明进行初始化操作。</p>
</li>
<li><p>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</p>
</li>
<li><p>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</p>
</li>
<li><p>静态代码块的执行要先于非静态代码块。</p>
</li>
<li><p>静态代码块随着类的加载而加载，且只执行一次。</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chinese</span> &#123;</span><br><span class="line"><span class="comment">//    private static String country = &quot;中国&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String country;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非静态代码块，country = &quot;</span> + country);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        country = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStaticBlock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-2-非静态代码块"><a href="#4-2-非静态代码块" class="headerlink" title="4.2 非静态代码块"></a>4.2 非静态代码块</h3><h4 id="4-2-1-语法格式"><a href="#4-2-1-语法格式" class="headerlink" title="4.2.1 语法格式"></a>4.2.1 语法格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 类&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        非静态代码块</span><br><span class="line">    &#125;</span><br><span class="line">    【修饰符】 构造器名()&#123;</span><br><span class="line">    	<span class="comment">// 实例初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    【修饰符】 构造器名(参数列表)&#123;</span><br><span class="line">        <span class="comment">// 实例初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-非静态代码块的作用"><a href="#4-2-2-非静态代码块的作用" class="headerlink" title="4.2.2 非静态代码块的作用"></a>4.2.2 非静态代码块的作用</h4><p>和构造器一样，也是用于实例变量的初始化等操作。</p>
<h4 id="4-2-3-非静态代码块的意义"><a href="#4-2-3-非静态代码块的意义" class="headerlink" title="4.2.3 非静态代码块的意义"></a>4.2.3 非静态代码块的意义</h4><p>如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执行的，那么可以将这部分代码抽取到非静态代码块中，减少冗余代码。</p>
<h4 id="4-2-4-非静态代码块的执行特点"><a href="#4-2-4-非静态代码块的执行特点" class="headerlink" title="4.2.4 非静态代码块的执行特点"></a>4.2.4 非静态代码块的执行特点</h4><ol>
<li><p>可以有输出语句。</p>
<ol>
<li><p>可以对类的属性、类的声明进行初始化操作。</p>
</li>
<li><p>除了调用非静态的结构外，还可以调用静态的变量或方法。</p>
</li>
<li><p>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</p>
</li>
<li><p>每次创建对象的时候，都会执行一次。且先于构造器执行。</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-3-举例"><a href="#4-3-举例" class="headerlink" title="4.3 举例"></a>4.3 举例</h3><p><strong>举例1：</strong></p>
<p>（1）声明User类，</p>
<ul>
<li><p>包含属性：username（String类型），password（String类型），registrationTime（long类型），私有化</p>
</li>
<li><p>包含get/set方法，其中registrationTime没有set方法</p>
</li>
<li><p>包含无参构造，</p>
<ul>
<li>输出“新用户注册”，</li>
<li>registrationTime赋值为当前系统时间，</li>
<li>username就默认为当前系统时间值，</li>
<li>password默认为“123456”</li>
</ul>
</li>
<li><p>包含有参构造(String username, String password)，</p>
<ul>
<li>输出“新用户注册”，</li>
<li>registrationTime赋值为当前系统时间，</li>
<li>username和password由参数赋值</li>
</ul>
</li>
<li><p>包含public String getInfo()方法，返回：“用户名：xx，密码：xx，注册时间：xx”</p>
</li>
</ul>
<p>（2）编写测试类，测试类main方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    System.out.println(u1.getInfo());</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;song&quot;</span>,<span class="string">&quot;8888&quot;</span>);</span><br><span class="line">    System.out.println(u2.getInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不用非静态代码块，User类是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.block.no;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> registrationTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新用户注册&quot;</span>);</span><br><span class="line">        registrationTime = System.currentTimeMillis();</span><br><span class="line">        username = registrationTime+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String username,String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新用户注册&quot;</span>);</span><br><span class="line">        registrationTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getRegistrationTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名：&quot;</span> + username + <span class="string">&quot;，密码：&quot;</span> + password + <span class="string">&quot;，注册时间：&quot;</span> + registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果提取构造器公共代码到非静态代码块，User类是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.block.use;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> registrationTime;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新用户注册&quot;</span>);</span><br><span class="line">        registrationTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        username = registrationTime+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getRegistrationTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名：&quot;</span> + username + <span class="string">&quot;，密码：&quot;</span> + password + <span class="string">&quot;，注册时间：&quot;</span> + registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>举例2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		is = DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line">		<span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">		pros.load(is);</span><br><span class="line">		<span class="comment">//调用BasicDataSourceFactory的静态方法，获取数据源。</span></span><br><span class="line">		dataSource = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				is.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-小结：实例变量赋值顺序"><a href="#4-4-小结：实例变量赋值顺序" class="headerlink" title="4.4 小结：实例变量赋值顺序"></a>4.4 小结：实例变量赋值顺序</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325230208941.png" alt="image-20220325230208941" style="zoom:67%;"></p>
<h3 id="4-5-练习"><a href="#4-5-练习" class="headerlink" title="4.5 练习"></a>4.5 练习</h3><p>练习1：分析加载顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Root</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mid</span> <span class="keyword">extends</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		<span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line">		<span class="built_in">this</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">			+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Mid</span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line">		<span class="built_in">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafTest</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Leaf</span>(); </span><br><span class="line">		<span class="comment">//new Leaf();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>练习2：分析加载顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;11111111111&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;22222222222&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;33333333333&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;44444444444&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;55555555555&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;66666666666&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">		System.out.println(<span class="string">&quot;77777777777&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>练习3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu05.field.interview;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getNum(<span class="string">&quot;（1）i&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> getNum(<span class="string">&quot;（2）j&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        print(<span class="string">&quot;（3）父类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;（4）父类非静态代码块，又称为构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Fu()&#123;</span><br><span class="line">        print(<span class="string">&quot;（5）父类构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        print(str);</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> getNum(<span class="string">&quot;（6）k&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> getNum(<span class="string">&quot;（7）h&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        print(<span class="string">&quot;（8）子类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;（9）子类非静态代码块，又称为构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Zi()&#123;</span><br><span class="line">        print(<span class="string">&quot;（10）子类构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">&quot;-&gt;&quot;</span> + k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        print(str);</span><br><span class="line">        <span class="keyword">return</span> ++k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-final关键字"><a href="#5-final关键字" class="headerlink" title="5. final关键字"></a>5. final关键字</h2><h3 id="5-1-final的意义"><a href="#5-1-final的意义" class="headerlink" title="5.1 final的意义"></a>5.1 final的意义</h3><p>final：最终的，不可更改的</p>
<h3 id="5-2-final的使用"><a href="#5-2-final的使用" class="headerlink" title="5.2 final的使用"></a>5.2 final的使用</h3><h4 id="5-2-1-final修饰类"><a href="#5-2-1-final修饰类" class="headerlink" title="5.2.1 final修饰类"></a>5.2.1 final修饰类</h4><p>表示这个类不能被继承，没有子类。提高安全性，提高程序的可读性。</p>
<p>例如：String类、System类、StringBuffer类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Eunuch</span>&#123;<span class="comment">//太监类</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Eunuch</span>&#123;<span class="comment">//错误</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-2-final修饰方法"><a href="#5-2-2-final修饰方法" class="headerlink" title="5.2.2 final修饰方法"></a>5.2.2 final修饰方法</h4><p>表示这个方法不能被子类重写。</p>
<p>例如：Object类中的getClass()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;<span class="comment">//错误</span></span><br><span class="line">		System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-3-final修饰变量"><a href="#5-2-3-final修饰变量" class="headerlink" title="5.2.3 final修饰变量"></a>5.2.3 final修饰变量</h4><p>final修饰某个变量（成员变量或局部变量），一旦赋值，它的值就不能被修改，即常量，常量名建议使用大写字母。</p>
<p>例如：final double MY_PI = 3.14;</p>
<blockquote>
<p>如果某个成员变量用final修饰后，没有set方法，并且必须初始化（可以显式赋值、或在初始化块赋值、实例变量还可以在构造器中赋值）</p>
</blockquote>
<ul>
<li>修饰成员变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">totalNumber</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        ID = ++totalNumber; <span class="comment">// 可在构造器中给final修饰的“变量”赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(t.ID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>修饰局部变量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> MIN_SCORE ;</span><br><span class="line">        MIN_SCORE = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SCORE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        MAX_SCORE = <span class="number">200</span>; <span class="comment">//非法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>错误演示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INFO</span> <span class="operator">=</span> <span class="string">&quot;atguigu&quot;</span>;  <span class="comment">//声明常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//The final field A.INFO cannot be  assigned</span></span><br><span class="line">        <span class="comment">//INFO = &quot;尚硅谷&quot;; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-3-笔试题"><a href="#5-3-笔试题" class="headerlink" title="5.3 笔试题"></a>5.3 笔试题</h3><p>题1：排错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addOne</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">        <span class="comment">// return x + 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题2：排错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Other</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Other</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Something</span>().addOne(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">(<span class="keyword">final</span> Other o)</span> &#123;</span><br><span class="line">        <span class="comment">// o = new Other();</span></span><br><span class="line">        o.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-抽象类与抽象方法-或abstract关键字"><a href="#6-抽象类与抽象方法-或abstract关键字" class="headerlink" title="6. 抽象类与抽象方法(或abstract关键字)"></a>6. 抽象类与抽象方法(或abstract关键字)</h2><h3 id="6-1-由来"><a href="#6-1-由来" class="headerlink" title="6.1 由来"></a>6.1 由来</h3><p>举例1：</p>
<p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325231608838.png" alt="image-20220325231608838"></p>
<p>举例2：</p>
<p>我们声明一些几何图形类：圆、矩形、三角形类等，发现这些类都有共同特征：求面积、求周长。那么这些共同特征应该抽取到一个共同父类：几何图形类中。但是这些方法在父类中又<code>无法给出具体的实现</code>，而是应该交给子类各自具体实现。那么父类在声明这些方法时，<code>就只有方法签名，没有方法体</code>，我们把没有方法体的方法称为<strong>抽象方法</strong>。Java语法规定，包含抽象方法的类必须是<strong>抽象类</strong>。</p>
<h3 id="6-2-语法格式"><a href="#6-2-语法格式" class="headerlink" title="6.2 语法格式"></a>6.2 语法格式</h3><ul>
<li><strong>抽象类</strong>：被abstract修饰的类。</li>
<li><strong>抽象方法</strong>：被abstract修饰没有方法体的方法。</li>
</ul>
<p>抽象类的语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[权限修饰符] <span class="keyword">abstract</span> class 类名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">[权限修饰符] <span class="keyword">abstract</span> class 类名 extends 父类&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象方法的语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[其他修饰符] <span class="keyword">abstract</span> 返回值类型 方法名([形参列表]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：抽象方法没有方法体</p>
</blockquote>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220517204707255.png" alt="image-20220517204707255"></p>
<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span> <span class="params">()</span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;小猫吃鱼和猫粮&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CatTest</span> &#123;</span><br><span class="line"> 	 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); </span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 调用eat方法</span></span><br><span class="line">        c.eat();</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p>
<h3 id="6-3-使用说明"><a href="#6-3-使用说明" class="headerlink" title="6.3 使用说明"></a>6.3 使用说明</h3><ol>
<li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p>
<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
<p>抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p>
</blockquote>
</li>
<li><p>抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。</p>
<blockquote>
<p>理解：子类的构造方法中，有默认的super()或手动的super(实参列表)，需要访问父类构造方法。</p>
</blockquote>
</li>
<li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
</li>
<li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 </p>
<blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
</li>
</ol>
<h3 id="6-4-注意事项"><a href="#6-4-注意事项" class="headerlink" title="6.4 注意事项"></a>6.4 注意事项</h3><ul>
<li><p>不能用abstract修饰变量、代码块、构造器；</p>
</li>
<li><p>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</p>
</li>
</ul>
<h3 id="6-5-应用举例1"><a href="#6-5-应用举例1" class="headerlink" title="6.5 应用举例1"></a>6.5 应用举例1</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325232847872.png" alt="image-20220325232847872"></p>
<p>在航运公司系统中，Vehicle类需要定义两个方法分别<code>计算运输工具的燃料效率</code>和<code>行驶距离</code>。</p>
<p><strong>问题：</strong>卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不同。Vehicle类不能提供计算方法，但子类可以。</p>
<p><strong>解决方案：</strong>Java允许类设计者指定：超类声明一个方法但不提供实现，该方法的实现由子类提供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vehicle是一个抽象类，有两个抽象方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">()</span>;	<span class="comment">//计算燃料效率的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">()</span>;	<span class="comment">//计算行驶距离的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Truck</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">( )</span>   &#123; <span class="comment">//写出计算卡车的燃料效率的具体方法   &#125;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">( )</span>    &#123;  <span class="comment">//写出计算卡车行驶距离的具体方法   &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiverBarge</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">	 <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">( )</span> &#123; <span class="comment">//写出计算驳船的燃料效率的具体方法  &#125;</span></span><br><span class="line">	 <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">( )</span>  &#123;  <span class="comment">//写出计算驳船行驶距离的具体方法&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-6-应用举例2：模板方法设计模式-TemplateMethod"><a href="#6-6-应用举例2：模板方法设计模式-TemplateMethod" class="headerlink" title="6.6 应用举例2：模板方法设计模式(TemplateMethod)"></a>6.6 应用举例2：模板方法设计模式(TemplateMethod)</h3><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<p><strong>解决的问题</strong>：</p>
<ul>
<li><p>当功能内部一部分实现是确定的，另一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p>
</li>
<li><p>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p>
</li>
</ul>
<p><strong>类比举例：</strong>英语六级模板</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220503145003315.png" alt="image-20220503145003315" style="zoom: 80%;"></p>
<p>制作月饼的模板：</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220517205013997.png" alt="image-20220517205013997" style="zoom: 50%;"></p>
<p>举例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        code();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间是：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java;</span><br><span class="line"><span class="comment">//抽象类的应用：模板方法的设计模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateMethodTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">BankTemplateMethod</span> <span class="variable">btm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DrawMoney</span>();</span><br><span class="line">		btm.process();</span><br><span class="line"></span><br><span class="line">		<span class="type">BankTemplateMethod</span> <span class="variable">btm2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ManageMoney</span>();</span><br><span class="line">		btm2.process();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BankTemplateMethod</span> &#123;</span><br><span class="line">	<span class="comment">// 具体方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeNumber</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;取号排队&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">transact</span><span class="params">()</span>; <span class="comment">// 办理具体的业务 //钩子方法</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evaluate</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;反馈评分&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模板方法，把基本操作组合到一起，子类一般不能重写</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.takeNumber();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.transact();<span class="comment">// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.evaluate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawMoney</span> <span class="keyword">extends</span> <span class="title class_">BankTemplateMethod</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transact</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要取款！！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ManageMoney</span> <span class="keyword">extends</span> <span class="title class_">BankTemplateMethod</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transact</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要理财！我这里有2000万美元!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p>
<ul>
<li><p>数据库访问的封装</p>
</li>
<li><p>Junit单元测试</p>
</li>
<li><p>JavaWeb的Servlet中关于doGet/doPost方法调用</p>
</li>
<li><p>Hibernate中模板程序</p>
</li>
<li><p>Spring中JDBCTemlate、HibernateTemplate等</p>
</li>
</ul>
<h3 id="6-7-思考与练习"><a href="#6-7-思考与练习" class="headerlink" title="6.7 思考与练习"></a>6.7 思考与练习</h3><p><strong>思考：</strong></p>
<p>问题1：为什么抽象类不可以使用final关键字声明？</p>
<p>问题2：一个抽象类中可以定义构造器吗？</p>
<p>问题3：是否可以这样理解：抽象类就是比普通类多定义了抽象方法，除了不能直接进行类的实例化操作之外，并没有任何的不同？</p>
<p><strong>练习1：</strong></p>
<p>编写一个Employee类，声明为抽象类，包含如下三个属性：name，id，salary。提供必要的构造器和抽象方法：work()。</p>
<p>对于Manager类来说，他既是员工，还具有奖金(bonus)的属性。</p>
<p>请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。</p>
<p><strong>练习2：软件外包公司外派管理</strong></p>
<p>有一家软件外包公司，可以外派开发人员，该公司有两个角色：普通开发人员Developer和项目经理Manager。他们的关系如下图：</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220504164925878.png" alt="image-20220504164925878"></p>
<p>普通开发人员的工作内容是“开发项目”，项目经理的工作内容是“项目管理”。对外的报价是普通开发人员每天500,元，超过60天每天400元。项目经理每天800元，超过60天每天700元。</p>
<p>有一家银行需要1名项目经理、2名开发人员，现场开发90天，计算银行需要付给软件公司的总金额。</p>
<p>提示：创建数组 Employee[] emps = new Employee[3]。其中存储驻场的3名员工。</p>
<p><strong>练习3：</strong></p>
<p>创建父类Shape，包含绘制形状的抽象方法draw()。</p>
<p>创建Shape的子类Circle和Rectangle，重写draw()方法，绘制圆形和矩形。</p>
<p>绘制多个圆形和矩形。</p>
<p><strong>练习4：</strong></p>
<p>1、声明抽象父类Person，包含抽象方法public abstract void eat();<br>2、声明子类中国人Chinese，重写抽象方法，打印用筷子吃饭<br>3、声明子类美国人American，重写抽象方法，打印用刀叉吃饭<br>4、声明子类印度人Indian，重写抽象方法，打印用手抓饭<br>5、声明测试类PersonTest，创建Person数组，存储各国人对象，并遍历数组，调用eat()方法</p>
<p><strong>练习5：工资系统设计</strong></p>
<p>编写工资系统，实现不同类型员工(多态)的按月发放工资。如果当月出现某个Employee对象的生日，则将该雇员的工资增加100元。</p>
<p>实验说明：</p>
<p>（1）定义一个Employee类，该类包含：</p>
<p>private成员变量name,number,birthday，其中birthday 为MyDate类的对象；</p>
<p>abstract方法earnings()；</p>
<p>toString()方法输出对象的name,number和birthday。</p>
<p>（2）MyDate类包含:</p>
<p>private成员变量year,month,day ；</p>
<p>toDateString()方法返回日期对应的字符串：xxxx年xx月xx日</p>
<p>（3）定义SalariedEmployee类继承Employee类，实现按月计算工资的员工处理。该类包括：private成员变量monthlySalary；</p>
<p>实现父类的抽象方法earnings(),该方法返回monthlySalary值；toString()方法输出员工类型信息及员工的name，number,birthday。</p>
<p>（4）参照SalariedEmployee类定义HourlyEmployee类，实现按小时计算工资的员工处理。该类包括：</p>
<p>private成员变量wage和hour；</p>
<p>实现父类的抽象方法earnings(),该方法返回wage*hour值；</p>
<p>toString()方法输出员工类型信息及员工的name，number,birthday。</p>
<p>（5）定义PayrollSystem类，创建Employee变量数组并初始化，该数组存放各类雇员对象的引用。利用循环结构遍历数组元素，输出各个对象的类型,name,number,birthday,以及该对象生日。当键盘输入本月月份值时，如果本月是某个Employee对象的生日，还要输出增加工资信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提示：</span></span><br><span class="line"><span class="comment">//定义People类型的数组People c1[]=new People[10];</span></span><br><span class="line"><span class="comment">//数组元素赋值</span></span><br><span class="line">c1[<span class="number">0</span>]=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;0001&quot;</span>,<span class="number">20</span>);</span><br><span class="line">c1[<span class="number">1</span>]=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;0002&quot;</span>,<span class="number">19</span>);</span><br><span class="line"><span class="comment">//若People有两个子类Student和Officer，则数组元素赋值时，可以使父类类型的数组元素指向子类。</span></span><br><span class="line">c1[<span class="number">0</span>]=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;0001&quot;</span>,<span class="number">20</span>,<span class="number">85.0</span>);</span><br><span class="line">c1[<span class="number">1</span>]=<span class="keyword">new</span> <span class="title class_">Officer</span>(<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;0002&quot;</span>,<span class="number">19</span>,<span class="number">90.5</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-接口-interface"><a href="#7-接口-interface" class="headerlink" title="7. 接口(interface)"></a>7. 接口(interface)</h2><h3 id="7-1-类比"><a href="#7-1-类比" class="headerlink" title="7.1 类比"></a>7.1 类比</h3><p>生活中大家每天都在用USB接口，那么USB接口与我们今天要学习的接口有什么相同点呢？</p>
<pre><code> USB，（Universal Serial Bus，通用串行总线）是Intel公司开发的总线架构，使得在计算机上添加串行设备（鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等）非常容易。
</code></pre><p>其实，不管是电脑上的USB插口，还是其他设备上的USB插口都只是<code>遵循了USB规范</code>的一种具体设备而已。</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/bbcc80f541000c71b81650cfaa770c86.png" alt="bbcc80f541000c71b81650cfaa770c86"></p>
<p>只要设备遵循USB规范的，那么就可以与电脑互联，并正常通信。至于这个设备、电脑是哪个厂家制造的，内部是如何实现的，我们都无需关心。</p>
<p>Java的软件系统会有很多模块组成，那么各个模块之间也应该采用这种<code>面向接口</code>的<code>低耦合</code>，为系统提供更好的可扩展性和可维护性。</p>
<h3 id="7-2-概述"><a href="#7-2-概述" class="headerlink" title="7.2 概述"></a>7.2 概述</h3><p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。继承是一个”是不是”的is-a关系，而接口实现则是 “能不能”的<code>has-a</code>关系。</p>
<ul>
<li>例如：电脑都预留了可以插入USB设备的USB接口，USB接口具备基本的数据传输的开启功能和关闭功能。你能不能用USB进行连接，或是否具备USB通信功能，就看你能否遵循USB接口规范</li>
</ul>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220517211517846.png" alt="image-20220517211517846" style="zoom:67%;"></p>
<ul>
<li>例如：Java程序是否能够连接使用某种数据库产品，那么要看该数据库产品能否实现Java设计的JDBC规范</li>
</ul>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325235434103.png" alt="image-20220325235434103" style="zoom:67%;"></p>
<blockquote>
<p>接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。</p>
</blockquote>
<h3 id="7-3-定义格式"><a href="#7-3-定义格式" class="headerlink" title="7.3 定义格式"></a>7.3 定义格式</h3><p>接口的定义，它与定义类方式相似，但是使用 <code>interface</code> 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p>
<blockquote>
<p>引用数据类型：数组，类，枚举，接口，注解。</p>
</blockquote>
<h4 id="7-3-1-接口的声明格式"><a href="#7-3-1-接口的声明格式" class="headerlink" title="7.3.1 接口的声明格式"></a>7.3.1 接口的声明格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] interface 接口名&#123;</span><br><span class="line">    <span class="comment">//接口的成员列表：</span></span><br><span class="line">    <span class="comment">// 公共的静态常量</span></span><br><span class="line">    <span class="comment">// 公共的抽象方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公共的默认方法（JDK1.8以上）</span></span><br><span class="line">    <span class="comment">// 公共的静态方法（JDK1.8以上）</span></span><br><span class="line">    <span class="comment">// 私有方法（JDK1.9以上）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB3</span>&#123;</span><br><span class="line">    <span class="comment">//静态常量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">500</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">//500MB/s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;USB 3.0可以同步全速地进行读写操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-3-2-接口的成员说明"><a href="#7-3-2-接口的成员说明" class="headerlink" title="7.3.2 接口的成员说明"></a>7.3.2 接口的成员说明</h4><p><strong>在JDK8.0 之前</strong>，接口中只允许出现：</p>
<p>（1）公共的静态的常量：其中<code>public static final</code>可以省略</p>
<p>（2）公共的抽象的方法：其中<code>public abstract</code>可以省略</p>
<blockquote>
<p>理解：接口是从多个相似类中抽象出来的规范，不需要提供具体实现</p>
</blockquote>
<p><strong>在JDK8.0 时</strong>，接口中允许声明<code>默认方法</code>和<code>静态方法</code>：</p>
<p>（3）公共的默认的方法：其中public 可以省略，建议保留，但是default不能省略</p>
<p>（4）公共的静态的方法：其中public 可以省略，建议保留，但是static不能省略</p>
<p><strong>在JDK9.0 时</strong>，接口又增加了：</p>
<p>（5）私有方法</p>
<p>除此之外，接口中没有构造器，没有初始化块，因为接口中没有成员变量需要动态初始化。</p>
<h3 id="7-4-接口的使用规则"><a href="#7-4-接口的使用规则" class="headerlink" title="7.4 接口的使用规则"></a>7.4 接口的使用规则</h3><p><strong>1、类实现接口（implements）</strong></p>
<p>接口<strong>不能创建对象</strong>，但是可以被类实现（<code>implements</code> ，类似于被继承）。</p>
<p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code>implements</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 实现类  implements 接口&#123;</span><br><span class="line">	<span class="comment">// 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  	<span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 class 实现类 extends 父类 implements 接口&#123;</span><br><span class="line">    <span class="comment">// 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  	<span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220514163212312.png" alt="image-20220514163212312" style="zoom:80%;"></p>
<p>注意：</p>
<ol>
<li><p>如果接口的实现类是非抽象类，那么必须<code>重写接口中所有抽象方法</code>。</p>
</li>
<li><p>默认方法可以选择保留，也可以重写。</p>
<blockquote>
<p>重写时，default单词就不要再写了，它只用于在接口中表示默认方法，到类中就没有默认方法的概念了</p>
</blockquote>
</li>
<li><p>接口中的静态方法不能被继承也不能被重写</p>
</li>
</ol>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;		<span class="comment">// </span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> ;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> ;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(USB usb)</span>&#123;	</span><br><span class="line">		usb.start() ;</span><br><span class="line">		System.out.println(<span class="string">&quot;=========== USB 设备工作 ========&quot;</span>) ;</span><br><span class="line">		usb.stop() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flash</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;	<span class="comment">// 重写方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;U盘开始工作。&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;		<span class="comment">// 重写方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;U盘停止工作。&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;	<span class="comment">// 重写方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;打印机开始工作。&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;		<span class="comment">// 重写方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;打印机停止工作。&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">		Computer.show(<span class="keyword">new</span> <span class="title class_">Flash</span>()) ;</span><br><span class="line">		Computer.show(<span class="keyword">new</span> <span class="title class_">Print</span>()) ;</span><br><span class="line"></span><br><span class="line">		c.show(<span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;移动硬盘开始运行&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;移动硬盘停止运行&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2、接口的多实现（implements）</strong></p>
<p>之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的<code>多实现</code>。并且，一个类能继承一个父类，同时实现多个接口。</p>
<p>实现格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 实现类  implements 接口<span class="number">1</span>，接口<span class="number">2</span>，接口<span class="number">3</span>。。。&#123;</span><br><span class="line">	<span class="comment">// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  	<span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 class 实现类 extends 父类 implements 接口<span class="number">1</span>，接口<span class="number">2</span>，接口<span class="number">3</span>。。。&#123;</span><br><span class="line">    <span class="comment">// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  	<span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接口中，有多个抽象方法时，实现类必须重写所有抽象方法。<strong>如果抽象方法有重名的，只需要重写一次</strong>。</p>
</blockquote>
<p>举例：</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220514163311418.png" alt="image-20220514163311418" style="zoom:80%;"></p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325235321778.png" alt="image-20220325235321778" style="zoom:67%;"></p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/1562216188519.png" alt="1562216188519"></p>
<p>定义多个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span>,B &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;showA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;showB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.showA();</span><br><span class="line">        c.showB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、接口的多继承(extends)</strong></p>
<p>一个接口能继承另一个或者多个接口，接口的继承也使用 <code>extends</code> 关键字，子接口继承父接口的方法。</p>
<p>定义父接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Chargeable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义子接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UsbC</span> <span class="keyword">extends</span> <span class="title class_">Chargeable</span>,USB3 &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义子接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeCConverter</span> <span class="keyword">implements</span> <span class="title class_">UsbC</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正反面都支持&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;可充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输出数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有父接口的抽象方法都有重写。</p>
<p>方法签名相同的抽象方法只需要实现一次。</p>
</blockquote>
<p><strong>4、接口与实现类对象构成多态引用</strong></p>
<p>实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你new的实现类对象实现的方法体。</p>
<p>接口的不同实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">USB3</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送脉冲信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不接收信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeyBoard</span> <span class="keyword">implements</span> <span class="title class_">USB3</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不接收信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送按键信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestComputer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">USB3</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">        computer.setUsb(usb);</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.out();</span><br><span class="line">        usb.in();</span><br><span class="line">        usb.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        usb = <span class="keyword">new</span> <span class="title class_">KeyBoard</span>();</span><br><span class="line">        computer.setUsb(usb);</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.out();</span><br><span class="line">        usb.in();</span><br><span class="line">        usb.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        usb = <span class="keyword">new</span> <span class="title class_">MobileHDD</span>();</span><br><span class="line">        computer.setUsb(usb);</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.out();</span><br><span class="line">        usb.in();</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5、使用接口的静态成员</strong></p>
<p>接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUSB3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过“接口名.”调用接口的静态方法 (JDK8.0才能开始使用)</span></span><br><span class="line">        USB3.show();</span><br><span class="line">        <span class="comment">//通过“接口名.”直接使用接口的静态常量</span></span><br><span class="line">        System.out.println(USB3.MAX_SPEED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6、使用接口的非静态方法</strong></p>
<ul>
<li>对于接口的静态方法，直接使用“<code>接口名.</code>”进行调用即可<ul>
<li>也只能使用“接口名.”进行调用，不能通过实现类的对象进行调用</li>
</ul>
</li>
<li>对于接口的抽象方法、默认方法，只能通过实现类对象才可以调用<ul>
<li>接口不能直接创建对象，只能创建实现类的对象</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMobileHDD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建实现类对象</span></span><br><span class="line">        <span class="type">MobileHDD</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MobileHDD</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过实现类对象调用重写的抽象方法，以及接口的默认方法，如果实现类重写了就执行重写的默认方法，如果没有重写，就执行接口中的默认方法</span></span><br><span class="line">        b.start();</span><br><span class="line">        b.in();</span><br><span class="line">        b.stop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过接口名调用接口的静态方法</span></span><br><span class="line"><span class="comment">//        MobileHDD.show();</span></span><br><span class="line"><span class="comment">//        b.show();</span></span><br><span class="line">        Usb3.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-5-JDK8中相关冲突问题"><a href="#7-5-JDK8中相关冲突问题" class="headerlink" title="7.5 JDK8中相关冲突问题"></a>7.5 JDK8中相关冲突问题</h3><h4 id="7-5-1-默认方法冲突问题"><a href="#7-5-1-默认方法冲突问题" class="headerlink" title="7.5.1 默认方法冲突问题"></a>7.5.1 默认方法冲突问题</h4><p><strong>（1）类优先原则</strong></p>
<p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。代码如下：</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span>&#123;<span class="comment">//约会</span></span><br><span class="line">        System.out.println(<span class="string">&quot;吃喝玩乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span>&#123;<span class="comment">//约会</span></span><br><span class="line">        System.out.println(<span class="string">&quot;爸爸约吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> <span class="keyword">implements</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//(1)不重写默认保留父类的</span></span><br><span class="line">        <span class="comment">//(2)调用父类被重写的</span></span><br><span class="line"><span class="comment">//        super.date();</span></span><br><span class="line">        <span class="comment">//(3)保留父接口的</span></span><br><span class="line"><span class="comment">//        Friend.super.date();</span></span><br><span class="line">        <span class="comment">//(4)完全重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;跟康师傅学Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        s.date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（2）接口冲突（左右为难）</strong></p>
<ul>
<li>当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？</li>
</ul>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/选择困难.jpg" alt></p>
<p>无论你多难抉择，最终都是要做出选择的。</p>
<p>声明接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BoyFriend</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span>&#123;<span class="comment">//约会</span></span><br><span class="line">        System.out.println(<span class="string">&quot;神秘约会&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择保留其中一个，通过“<code>接口名.super.方法名</code>“的方法选择保留哪个接口的默认方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">Friend</span>,BoyFriend&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//(1)保留其中一个父接口的</span></span><br><span class="line"><span class="comment">//        Friend.super.date();</span></span><br><span class="line"><span class="comment">//        BoyFriend.super.date();</span></span><br><span class="line">        <span class="comment">//(2)完全重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;跟康师傅学Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGirl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">        girl.date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？</li>
</ul>
<p>另一个父接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB2</span> &#123;</span><br><span class="line">    <span class="comment">//静态常量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">60</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">//60MB/s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;USB 2.0可以高速地进行读写操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB</span> <span class="keyword">extends</span> <span class="title class_">USB2</span>,USB3 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Usb.start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Usb.stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：</p>
<p>子接口重写默认方法时，default关键字可以保留。</p>
<p>子类重写默认方法时，default关键字不可以保留。</p>
</blockquote>
<h4 id="7-5-2-常量冲突问题"><a href="#7-5-2-常量冲突问题" class="headerlink" title="7.5.2 常量冲突问题"></a>7.5.2 常量冲突问题</h4><ul>
<li>当子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。</li>
<li>当子类同时实现多个接口，而多个接口存在相同同名常量。</li>
</ul>
<p>此时在子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突问题。</p>
<p>父类和父接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SuperInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MotherInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> <span class="keyword">implements</span> <span class="title class_">SuperInterface</span>,MotherInterface &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;x = &quot; + x);//模糊不清</span></span><br><span class="line">        System.out.println(<span class="string">&quot;super.x = &quot;</span> + <span class="built_in">super</span>.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperInterface.x = &quot;</span> + SuperInterface.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;MotherInterface.x = &quot;</span> + MotherInterface.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;y = &quot;</span> + y);<span class="comment">//没有重名问题，可以直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-6-接口的总结与面试题"><a href="#7-6-接口的总结与面试题" class="headerlink" title="7.6 接口的总结与面试题"></a>7.6 接口的总结与面试题</h3><ul>
<li>接口本身不能创建对象，只能创建接口的实现类对象，接口类型的变量可以与实现类对象构成多态引用。</li>
<li>声明接口用interface，接口的成员声明有限制：<ul>
<li>（1）公共的静态常量</li>
<li>（2）公共的抽象方法</li>
<li>（3）公共的默认方法（JDK8.0 及以上）</li>
<li>（4）公共的静态方法（JDK8.0 及以上）</li>
<li>（5）私有方法（JDK9.0 及以上）</li>
</ul>
</li>
<li>类可以实现接口，关键字是implements，而且支持多实现。如果实现类不是抽象类，就必须实现接口中所有的抽象方法。如果实现类既要继承父类又要实现父接口，那么继承（extends）在前，实现（implements）在后。</li>
<li>接口可以继承接口，关键字是extends，而且支持多继承。</li>
<li>接口的默认方法可以选择重写或不重写。如果有冲突问题，另行处理。子类重写父接口的默认方法，要去掉default，子接口重写父接口的默认方法，不要去掉default。</li>
<li>接口的静态方法不能被继承，也不能被重写。接口的静态方法只能通过“接口名.静态方法名”进行调用。</li>
</ul>
<p><strong>面试题</strong></p>
<p><strong>1、为什么接口中只能声明公共的静态的常量？</strong></p>
<p>因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则就有“危险”。</p>
<p>例如：USB1.0规范中规定最大传输速率是1.5Mbps，最大输出电流是5V/500mA</p>
<p>​           USB3.0规范中规定最大传输速率是5Gbps(500MB/s)，最大输出电流是5V/900mA</p>
<p>例如：尚硅谷学生行为规范中规定学员，早上8:25之前进班，晚上21:30之后离开等等。</p>
<p><strong>2、为什么JDK8.0 之后允许接口定义静态方法和默认方法呢？因为它违反了接口作为一个抽象标准定义的概念。</strong></p>
<p><code>静态方法</code>：因为之前的标准类库设计中，有很多Collection/Colletions或者Path/Paths这样成对的接口和类，后面的类中都是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对API，不如把静态方法直接定义到接口中使用和维护更方便。</p>
<p><code>默认方法</code>：（1）我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有问题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8中对Collection、List、Comparator等接口提供了丰富的默认方法。（2）当我们接口的某个抽象方法，在很多实现类中的实现代码是一样的，此时将这个抽象方法设计为默认方法更为合适，那么实现类就可以选择重写，也可以选择不重写。</p>
<p><strong>3、为什么JDK1.9要允许接口定义私有方法呢？因为我们说接口是规范，规范是需要公开让大家遵守的。</strong></p>
<p><strong>私有方法</strong>：因为有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法由共同的代码可以抽取，而这些共同的代码抽取出来的方法又只希望在接口内部使用，所以就增加了私有方法。</p>
<h3 id="7-7-接口与抽象类之间的对比"><a href="#7-7-接口与抽象类之间的对比" class="headerlink" title="7.7 接口与抽象类之间的对比"></a>7.7 接口与抽象类之间的对比</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220328002053452.png" alt="image-20220328002053452"></p>
<blockquote>
<p>在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。</p>
</blockquote>
<h3 id="7-8-练习"><a href="#7-8-练习" class="headerlink" title="7.8 练习"></a>7.8 练习</h3><p><strong>笔试题：</strong>排错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pX</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().pX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>笔试题：</strong>排错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Playable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bounceable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Rollable</span> <span class="keyword">extends</span> <span class="title class_">Playable</span>, Bounceable &#123;</span><br><span class="line">    <span class="type">Ball</span> <span class="variable">ball</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ball</span>(<span class="string">&quot;PingPang&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ball</span> <span class="keyword">implements</span> <span class="title class_">Rollable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ball</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        ball = <span class="keyword">new</span> <span class="title class_">Ball</span>(<span class="string">&quot;Football&quot;</span>);</span><br><span class="line">        System.out.println(ball.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>练习1：</strong></p>
<p>定义一个接口用来实现两个对象的比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CompareObject</span>&#123;</span><br><span class="line">	<span class="comment">//若返回值是 0 , 代表相等; 若为正数，代表当前对象大；负数代表当前对象小</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个Circle类，声明redius属性，提供getter和setter方法</p>
<p>定义一个ComparableCircle类，继承Circle类并且实现CompareObject接口。在ComparableCircle类中给出接口中方法compareTo的实现体，用来比较两个圆的半径大小。</p>
<p>定义一个测试类InterfaceTest，创建两个ComparableCircle对象，调用compareTo方法比较两个类的半径大小。</p>
<p>思考：参照上述做法定义矩形类Rectangle和ComparableRectangle类，在ComparableRectangle类中给出compareTo方法的实现，比较两个矩形的面积大小。</p>
<p><strong>练习2：交通工具案例</strong></p>
<p>阿里的一个工程师，声明的属性和方法如下：</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220504172547709.png" alt="image-20220504172547709"></p>
<p>其中，有一个乘坐交通工具的方法takingVehicle()，在此方法中调用交通工具的run()。为了出行方便，他买了一辆捷安特自行车、一辆雅迪电动车和一辆奔驰轿车。这里涉及到的相关类及接口关系如下：</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220504172918861.png" alt="image-20220504172918861"></p>
<p>其中，电动车增加动力的方式是充电，轿车增加动力的方式是加油。在具体交通工具的run()中调用其所在类的相关属性信息。</p>
<p>请编写相关代码，并测试。</p>
<p>提示：创建Vehicle[]数组，保存阿里工程师的三辆交通工具，并分别在工程师的takingVehicle()中调用。</p>
<h2 id="8-内部类（InnerClass"><a href="#8-内部类（InnerClass" class="headerlink" title="8. 内部类（InnerClass)"></a>8. 内部类（InnerClass)</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><h4 id="8-1-1-什么是内部类"><a href="#8-1-1-什么是内部类" class="headerlink" title="8.1.1 什么是内部类"></a>8.1.1 什么是内部类</h4><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<code>内部类（InnerClass）</code>，类B则称为<code>外部类（OuterClass）</code>。</p>
<h4 id="8-1-2-为什么要声明内部类呢"><a href="#8-1-2-为什么要声明内部类呢" class="headerlink" title="8.1.2 为什么要声明内部类呢"></a>8.1.2 为什么要声明内部类呢</h4><p>具体来说，当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整的结构B又只为外部事物A提供服务，不在其他地方单独使用，那么整个内部的完整结构B最好使用内部类。</p>
<p>总的来说，遵循<code>高内聚、低耦合</code>的面向对象开发原则。</p>
<h4 id="8-1-3-内部类的分类"><a href="#8-1-3-内部类的分类" class="headerlink" title="8.1.3 内部类的分类"></a>8.1.3 内部类的分类</h4><p>根据内部类声明的位置（如同变量的分类），我们可以分为：</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20221124223912529.png" alt="image-20221124223912529"></p>
<h3 id="8-2-成员内部类"><a href="#8-2-成员内部类" class="headerlink" title="8.2 成员内部类"></a>8.2 成员内部类</h3><h4 id="8-2-1-概述"><a href="#8-2-1-概述" class="headerlink" title="8.2.1 概述"></a>8.2.1 概述</h4><p>如果成员内部类中不使用外部类的非静态成员，那么通常将内部类声明为静态内部类，否则声明为非静态内部类。</p>
<p><strong>语法格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 外部类&#123;</span><br><span class="line">    [其他修饰符] [<span class="keyword">static</span>] class 内部类&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>成员内部类的使用特征，概括来讲有如下两种角色：</strong></p>
<ul>
<li>成员内部类作为<code>类的成员的角色</code>：<ul>
<li>和外部类不同，Inner class还可以声明为private或protected；</li>
<li>可以调用外部类的结构。（注意：在静态内部类中不能使用外部类的非静态成员）</li>
<li>Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；</li>
</ul>
</li>
<li>成员内部类作为<code>类的角色</code>：<ul>
<li>可以在内部定义属性、方法、构造器等结构</li>
<li>可以继承自己的想要继承的父类，实现自己想要实现的父接口们，和外部类的父类和父接口无关</li>
<li>可以声明为abstract类 ，因此可以被其它的内部类继承</li>
<li>可以声明为final的，表示不能被继承</li>
<li>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</li>
</ul>
</li>
</ul>
<p>注意点：</p>
<ol>
<li><p>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</p>
</li>
<li><p>成员内部类可以直接使用外部类的所有成员，包括私有的数据</p>
</li>
<li><p>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</p>
</li>
</ol>
<h4 id="8-2-2-创建成员内部类对象"><a href="#8-2-2-创建成员内部类对象" class="headerlink" title="8.2.2 创建成员内部类对象"></a>8.2.2 创建成员内部类对象</h4><ul>
<li>实例化静态内部类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部类名.静态内部类名 变量 = 外部类名.静态内部类名();</span><br><span class="line">变量.非静态方法();</span><br></pre></td></tr></table></figure>
<ul>
<li>实例化非静态内部类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部类名 变量1 = new 外部类();</span><br><span class="line">外部类名.非静态内部类名 变量2 = 变量1.new 非静态内部类名();</span><br><span class="line">变量2.非静态方法();</span><br></pre></td></tr></table></figure>
<h4 id="8-2-3-举例"><a href="#8-2-3-举例" class="headerlink" title="8.2.3 举例"></a>8.2.3 举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMemberInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建静态内部类实例，并调用方法</span></span><br><span class="line">        Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br><span class="line">        inner.inFun();</span><br><span class="line">        <span class="comment">//调用静态内部类静态方法</span></span><br><span class="line">        Outer.StaticInner.inMethod();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建非静态内部类实例（方式1），并调用方法</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">NoStaticInner</span> <span class="variable">inner1</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">NoStaticInner</span>();</span><br><span class="line">        inner1.inFun();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建非静态内部类实例（方式2）</span></span><br><span class="line">        Outer.<span class="type">NoStaticInner</span> <span class="variable">inner2</span> <span class="operator">=</span> outer.getNoStaticInner();</span><br><span class="line">        inner1.inFun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;外部类的静态a&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">b</span>  <span class="operator">=</span> <span class="string">&quot;外部类的静态b&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;外部类对象的非静态c&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;外部类对象的非静态d&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span><span class="string">&quot;静态内部类的静态a&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;静态内部类对象的非静态c&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.a = &quot;</span> + Outer.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inFun</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.inFun&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.a = &quot;</span> + Outer.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">            System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line"><span class="comment">//            System.out.println(&quot;d = &quot; + d);//不能访问外部类的非静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NoStaticInner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;非静态内部类对象的非静态a&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;非静态内部类对象的非静态c&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inFun</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NoStaticInner.inFun&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.a = &quot;</span> + Outer.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.c = &quot;</span> + Outer.<span class="built_in">this</span>.c);</span><br><span class="line">            System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">            System.out.println(<span class="string">&quot;d = &quot;</span> + d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NoStaticInner <span class="title function_">getNoStaticInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NoStaticInner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-局部内部类"><a href="#8-3-局部内部类" class="headerlink" title="8.3 局部内部类"></a>8.3 局部内部类</h3><h4 id="8-3-1-非匿名局部内部类"><a href="#8-3-1-非匿名局部内部类" class="headerlink" title="8.3.1 非匿名局部内部类"></a>8.3.1 非匿名局部内部类</h4><p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 外部类&#123;</span><br><span class="line">    [修饰符] 返回值类型  方法名(形参列表)&#123;</span><br><span class="line">            [<span class="keyword">final</span>/<span class="keyword">abstract</span>] class 内部类&#123;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译后有自己的独立的字节码文件，只不过在内部类名前面冠以外部类名、$符号、编号。<ul>
<li>这里有编号是因为同一个外部类中，不同的方法中存在相同名称的局部内部类</li>
</ul>
</li>
</ul>
<ul>
<li>和成员内部类不同的是，它前面不能有权限修饰符等</li>
<li>局部内部类如同局部变量一样，有作用域</li>
<li>局部内部类中是否能访问外部类的非静态的成员，取决于所在的方法</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: TestLocalInner</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span> 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLocalInner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.outMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        out.outTest();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runner</span> <span class="variable">runner</span> <span class="operator">=</span> Outer.getRunner();</span><br><span class="line">        runner.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer.outMethod&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;局部变量c&quot;</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inMethod</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inner.inMethod&quot;</span>);</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.inMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inMethod1</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inner.inMethod1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.inMethod1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runner <span class="title function_">getRunner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalRunner</span> <span class="keyword">implements</span> <span class="title class_">Runner</span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;LocalRunner.run&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalRunner</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Runner</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-2-匿名内部类"><a href="#8-3-2-匿名内部类" class="headerlink" title="8.3.2 匿名内部类"></a>8.3.2 匿名内部类</h4><p>因为考虑到这个子类或实现类是一次性的，那么我们“费尽心机”的给它取名字，就显得多余。那么我们完全可以使用匿名内部类的方式来实现，避免给类命名的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类([实参列表])&#123;</span><br><span class="line">    重写方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父接口()&#123;</span><br><span class="line">    重写方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例1：使用匿名内部类的对象直接调用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	<span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例2：通过父类或父接口的变量多态引用匿名内部类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	<span class="type">A</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;;</span><br><span class="line">    	obj.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例3：匿名内部类的对象作为实参</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(A a)</span>&#123;</span><br><span class="line">    	a.method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	test(<span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-练习"><a href="#8-4-练习" class="headerlink" title="8.4 练习"></a>8.4 练习</h3><p>练习：判断输出结果为何？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        s1.a = <span class="number">10</span>;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        s2.a = <span class="number">20</span>;</span><br><span class="line">        Test.<span class="type">Inner</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>.Inner();</span><br><span class="line">        System.out.println(s3.a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">r</span> <span class="operator">=</span> t.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        System.out.println(r.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>练习2：</p>
<p>编写一个匿名内部类，它继承Object，并在匿名内部类中，声明一个方法public void test()打印尚硅谷。</p>
<p>请编写代码调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Object</span>()&#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="9-枚举类"><a href="#9-枚举类" class="headerlink" title="9. 枚举类"></a>9. 枚举类</h2><h3 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h3><ul>
<li><p>枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。</p>
</li>
<li><p>枚举类的例子举不胜举：</p>
<ul>
<li><code>星期</code>：Monday(星期一)……Sunday(星期天)</li>
<li><code>性别</code>：Man(男)、Woman(女)</li>
<li><code>月份</code>：January(1月)……December(12月)</li>
<li><code>季节</code>：Spring(春节)……Winter(冬天)</li>
<li><code>三原色</code>：red(红色)、green(绿色)、blue(蓝色)</li>
<li><code>支付方式</code>：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)</li>
<li><code>就职状态</code>：Busy(忙碌)、Free(空闲)、Vocation(休假)、Dimission(离职)</li>
<li><code>订单状态</code>：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Checked（已确认收货）、Return（退货）、Exchange（换货）、Cancel（取消）</li>
<li><code>线程状态</code>：创建、就绪、运行、阻塞、死亡</li>
</ul>
</li>
<li><strong>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。</strong></li>
<li>枚举类的实现：<ul>
<li>在JDK5.0 之前，需要程序员自定义枚举类型。</li>
<li>在JDK5.0 之后，Java支持<code>enum</code>关键字来快速定义枚举类型。</li>
</ul>
</li>
</ul>
<h3 id="9-2-定义枚举类（JDK5-0-之前）"><a href="#9-2-定义枚举类（JDK5-0-之前）" class="headerlink" title="9.2 定义枚举类（JDK5.0 之前）"></a>9.2 定义枚举类（JDK5.0 之前）</h3><p>在JDK5.0 之前如何声明枚举类呢？</p>
<ul>
<li><code>私有化</code>类的构造器，保证不能在类的外部创建其对象</li>
<li>在类的内部创建枚举类的实例。声明为：<code>public static final</code> ，对外暴露这些常量对象</li>
<li>对象如果有<code>实例变量</code>，应该声明为<code>private final</code>（建议，不是必须），并在构造器中初始化</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;<span class="comment">//季节的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;<span class="comment">//季节的描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SEASONNAME = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.SEASONDESC = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;SEASONNAME=&#x27;&quot;</span> + SEASONNAME + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, SEASONDESC=&#x27;&quot;</span> + SEASONDESC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeasonTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-定义枚举类（JDK5-0-之后）"><a href="#9-3-定义枚举类（JDK5-0-之后）" class="headerlink" title="9.3 定义枚举类（JDK5.0 之后）"></a>9.3 定义枚举类（JDK5.0 之后）</h3><h4 id="9-3-1-enum关键字声明枚举"><a href="#9-3-1-enum关键字声明枚举" class="headerlink" title="9.3.1 enum关键字声明枚举"></a>9.3.1 enum关键字声明枚举</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    常量对象列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    常量对象列表;</span><br><span class="line">    </span><br><span class="line">    对象的实例变量列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">		System.out.println(spring);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-3-2-enum方式定义的要求和特点"><a href="#9-3-2-enum方式定义的要求和特点" class="headerlink" title="9.3.2 enum方式定义的要求和特点"></a>9.3.2 enum方式定义的要求和特点</h4><ul>
<li>枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写。</li>
<li>列出的实例系统会自动添加 public static final 修饰。</li>
<li>如果常量对象列表后面没有其他代码，那么“；”可以省略，否则不可以省略“；”。</li>
<li>编译器给枚举类默认提供的是private的无参构造，如果枚举类需要的是无参构造，就不需要声明，写常量对象列表时也不用加参数</li>
<li>如果枚举类需要的是有参构造，需要手动定义，有参构造的private可以省略，调用有参构造的方法就是在常量对象名后面加(实参列表)就可以。</li>
<li>枚举类默认继承的是java.lang.Enum类，因此不能再继承其他的类型。</li>
<li>JDK5.0 之后switch，提供支持枚举类型，case后面可以写枚举常量名，无需添加枚举类作为限定。</li>
</ul>
<p>举例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    MONDAY(<span class="string">&quot;星期一&quot;</span>),</span><br><span class="line">    TUESDAY(<span class="string">&quot;星期二&quot;</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">&quot;星期三&quot;</span>),</span><br><span class="line">    THURSDAY(<span class="string">&quot;星期四&quot;</span>),</span><br><span class="line">    FRIDAY(<span class="string">&quot;星期五&quot;</span>),</span><br><span class="line">    SATURDAY(<span class="string">&quot;星期六&quot;</span>),</span><br><span class="line">    SUNDAY(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Week</span><span class="params">(String description)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() +<span class="string">&quot;:&quot;</span>+ description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWeek</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Week</span> <span class="variable">week</span> <span class="operator">=</span> Week.MONDAY;</span><br><span class="line">        System.out.println(week);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (week)&#123;</span><br><span class="line">            <span class="keyword">case</span> MONDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;怀念周末，困意很浓&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TUESDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;进入学习状态&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;死撑&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> THURSDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;小放松&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRIDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;又信心满满&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SATURDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;开始盼周末，无心学习&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUNDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;一觉到下午&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>经验之谈：</p>
<p>开发中，当需要定义一组常量时，强烈建议使用枚举类。</p>
</blockquote>
<h3 id="9-4-enum中常用方法"><a href="#9-4-enum中常用方法" class="headerlink" title="9.4 enum中常用方法"></a>9.4 enum中常用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！</span><br><span class="line">    </span><br><span class="line">static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法</span><br><span class="line">    </span><br><span class="line">static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</span><br><span class="line">    </span><br><span class="line">String name():得到当前枚举常量的名称。建议优先使用toString()。</span><br><span class="line">    </span><br><span class="line">int ordinal():返回当前枚举常量的次序号，默认从0开始</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEnumMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//values()</span></span><br><span class="line">        Week[] values = Week.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="comment">//ordinal()、name()</span></span><br><span class="line">            System.out.println((values[i].ordinal()+<span class="number">1</span>) + <span class="string">&quot;-&gt;&quot;</span> + values[i].name());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入星期值：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">weekValue</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="type">Week</span> <span class="variable">week</span> <span class="operator">=</span> values[weekValue-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//toString()</span></span><br><span class="line">        System.out.println(week);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入星期名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">weekName</span> <span class="operator">=</span> input.next();</span><br><span class="line">        <span class="comment">//valueOf()</span></span><br><span class="line">        week = Week.valueOf(weekName);</span><br><span class="line">        System.out.println(week);</span><br><span class="line"></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-5-实现接口的枚举类"><a href="#9-5-实现接口的枚举类" class="headerlink" title="9.5 实现接口的枚举类"></a>9.5 实现接口的枚举类</h3><ul>
<li>和普通 Java 类一样，枚举类可以实现一个或多个接口</li>
<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li>
<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li>
</ul>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、枚举类可以像普通的类一样，实现接口，并且可以多个，但要求必须实现里面所有的抽象方法！</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> implements 接口<span class="number">1</span>，接口<span class="number">2</span>&#123;</span><br><span class="line">	<span class="comment">//抽象方法的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、如果枚举类的常量可以继续重写抽象方法!</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> implements 接口<span class="number">1</span>，接口<span class="number">2</span>&#123;</span><br><span class="line">    常量名<span class="number">1</span>(参数)&#123;</span><br><span class="line">        <span class="comment">//抽象方法的实现或重写</span></span><br><span class="line">    &#125;,</span><br><span class="line">    常量名<span class="number">2</span>(参数)&#123;</span><br><span class="line">        <span class="comment">//抽象方法的实现或重写</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字定义枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">	<span class="comment">//1. 创建枚举类中的对象,声明在enum枚举类的首位</span></span><br><span class="line">	SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;宁静的夏天&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;秋天是用来分手的季节&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;白雪皑皑&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;2002年的第一场雪&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 声明每个对象拥有的属性:private final修饰</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String SEASON_NAME;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String SEASON_DESC;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 私有化类的构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.SEASON_NAME = seasonName;</span><br><span class="line">		<span class="built_in">this</span>.SEASON_DESC = seasonDesc;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSEASON_NAME</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SEASON_NAME;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSEASON_DESC</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SEASON_DESC;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-注解-Annotation"><a href="#10-注解-Annotation" class="headerlink" title="10. 注解(Annotation)"></a>10. 注解(Annotation)</h2><h3 id="10-1-注解概述"><a href="#10-1-注解概述" class="headerlink" title="10.1 注解概述"></a>10.1 注解概述</h3><h4 id="10-1-1-什么是注解"><a href="#10-1-1-什么是注解" class="headerlink" title="10.1.1 什么是注解"></a>10.1.1 什么是注解</h4><p>注解（Annotation）是从<code>JDK5.0</code>开始引入，以“<code>@注解名</code>”在代码中存在。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(value=”unchecked”)</span></span><br></pre></td></tr></table></figure>
<p>Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “name=value” 对中。</p>
<p>注解可以在类编译、运行时进行加载，体现不同的功能。</p>
<h4 id="10-1-2-注解与注释"><a href="#10-1-2-注解与注释" class="headerlink" title="10.1.2 注解与注释"></a>10.1.2 注解与注释</h4><p>注解也可以看做是一种注释，通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。但是，注解，不同于单行注释和多行注释。</p>
<ul>
<li>对于单行注释和多行注释是给程序员看的。</li>
<li>而注解是可以被编译器或其他程序读取的。程序还可以根据注解的不同，做出相应的处理。</li>
</ul>
<h4 id="10-1-3-注解的重要性"><a href="#10-1-3-注解的重要性" class="headerlink" title="10.1.3 注解的重要性"></a>10.1.3 注解的重要性</h4><p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在<code>JavaEE/Android中注解占据了更重要的角色</code>，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的<code>繁冗代码</code>和<code>XML配置</code>等。</p>
<p>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，Struts2有一部分也是基于注解的了。<code>注解是一种趋势</code>，一定程度上可以说：<code>框架 = 注解 + 反射 + 设计模式</code>。</p>
<h3 id="10-2-常见的Annotation作用"><a href="#10-2-常见的Annotation作用" class="headerlink" title="10.2 常见的Annotation作用"></a>10.2 常见的Annotation作用</h3><p><strong>示例1：生成文档相关的注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@author</span> 标明开发该类模块的作者，多个作者之间使用,分割</span><br><span class="line"><span class="meta">@version</span> 标明该类模块的版本</span><br><span class="line"><span class="meta">@see</span> 参考转向，也就是相关主题</span><br><span class="line"><span class="meta">@since</span> 从哪个版本开始增加的</span><br><span class="line"><span class="meta">@param</span> 对方法中某参数的说明，如果没有参数就不能写</span><br><span class="line"><span class="meta">@return</span> 对方法返回值的说明，如果方法的返回值类型是<span class="keyword">void</span>就不能写</span><br><span class="line"><span class="meta">@exception</span> 对方法可能抛出的异常进行说明 ，如果方法没有用<span class="keyword">throws</span>显式抛出的异常就不能写</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.annotation.javadoc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Math.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavadocTest</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 程序的主方法，程序的入口</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args String[] 命令行参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 求圆面积的方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> radius double 半径值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> double 圆的面积</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例2：在编译时进行格式检查(JDK内置的三个基本注解)</strong></p>
<p><code>@Override</code>: 限定重写父类方法，该注解只能用于方法</p>
<p><code>@Deprecated</code>: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</p>
<p><code>@SuppressWarnings</code>: 抑制编译器警告</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.annotation.javadoc;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;过时的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;重写的toString方法()&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例3：跟踪代码依赖性，实现替代配置文件功能</strong></p>
<ul>
<li>Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.servlet.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Spring框架中关于“事务”的管理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(String username, String isbn)</span> &#123;</span><br><span class="line">	<span class="comment">//1.查询书的单价</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line">    <span class="comment">//2. 更新库存</span></span><br><span class="line">    bookShopDao.updateBookStock(isbn);	</span><br><span class="line">    <span class="comment">//3. 更新用户的余额</span></span><br><span class="line">    bookShopDao.updateUserAccount(username, price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;dataSourceTransactionManager&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置每个方法使用的事务属性 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;buyBook&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span> </span></span><br><span class="line"><span class="tag">	 <span class="attr">isolation</span>=<span class="string">&quot;READ_COMMITTED&quot;</span>  <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>  <span class="attr">timeout</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="10-3-三个最基本的注解"><a href="#10-3-三个最基本的注解" class="headerlink" title="10.3 三个最基本的注解"></a>10.3 三个最基本的注解</h3><h4 id="10-3-1-Override"><a href="#10-3-1-Override" class="headerlink" title="10.3.1 @Override"></a>10.3.1 @Override</h4><ul>
<li>用于检测被标记的方法为有效的重写方法，如果不是，则报编译错误！</li>
</ul>
<ul>
<li>只能标记在方法上。</li>
</ul>
<ul>
<li>它会被编译器程序读取。</li>
</ul>
<h4 id="10-3-2-Deprecated"><a href="#10-3-2-Deprecated" class="headerlink" title="10.3.2 @Deprecated"></a>10.3.2 @Deprecated</h4><ul>
<li>用于表示被标记的数据已经过时，不推荐使用。</li>
</ul>
<ul>
<li>可以用于修饰 属性、方法、构造、类、包、局部变量、参数。</li>
</ul>
<ul>
<li>它会被编译器程序读取。</li>
</ul>
<h4 id="10-3-3-SuppressWarnings"><a href="#10-3-3-SuppressWarnings" class="headerlink" title="10.3.3 @SuppressWarnings"></a>10.3.3 @SuppressWarnings</h4><ul>
<li>抑制编译警告。当我们不希望看到警告信息的时候，可以使用 SuppressWarnings 注解来抑制警告信息</li>
</ul>
<ul>
<li>可以用于修饰类、属性、方法、构造、局部变量、参数</li>
</ul>
<ul>
<li><p>它会被编译器程序读取。</p>
</li>
<li><p>可以指定的警告类型有（了解）</p>
<ul>
<li>all，抑制所有警告</li>
<li>unchecked，抑制与未检查的作业相关的警告</li>
<li>unused，抑制与未用的程式码及停用的程式码相关的警告</li>
<li>deprecation，抑制与淘汰的相关警告</li>
<li>nls，抑制与非 nls 字串文字相关的警告</li>
<li>null，抑制与空值分析相关的警告</li>
<li>rawtypes，抑制与使用 raw 类型相关的警告</li>
<li>static-access，抑制与静态存取不正确相关的警告</li>
<li>static-method，抑制与可能宣告为 static 的方法相关的警告</li>
<li>super，抑制与置换方法相关但不含 super 呼叫的警告</li>
<li>…</li>
</ul>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnnotation</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        f.show();</span><br><span class="line">        f.methodOl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodOl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="comment">/*	@Override</span></span><br><span class="line"><span class="comment">	void method01() &#123;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;Son Method&quot;);</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-4-元注解"><a href="#10-4-元注解" class="headerlink" title="10.4 元注解"></a>10.4 元注解</h3><p>JDK1.5在java.lang.annotation包定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。</p>
<p>（1）<strong>@Target：</strong>用于描述注解的使用范围</p>
<ul>
<li>可以通过枚举类型ElementType的10个常量对象来指定</li>
<li>TYPE，METHOD，CONSTRUCTOR，PACKAGE…..</li>
</ul>
<p>（2）<strong>@Retention：</strong>用于描述注解的生命周期</p>
<ul>
<li>可以通过枚举类型RetentionPolicy的3个常量对象来指定</li>
<li>SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）</li>
<li><code>唯有RUNTIME阶段才能被反射读取到</code>。</li>
</ul>
<p>（3）<strong>@Documented</strong>：表明这个注解应该被 javadoc工具记录。</p>
<p>（4）<strong>@Inherited：</strong>允许子类继承父类中的注解</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>拓展：元数据</p>
<p>String name = “Tom”;</p>
</blockquote>
<h3 id="10-5-自定义注解的使用"><a href="#10-5-自定义注解的使用" class="headerlink" title="10.5 自定义注解的使用"></a>10.5 自定义注解的使用</h3><p>一个完整的注解应该包含三个部分：<br>（1）声明<br>（2）使用<br>（3）读取</p>
<h4 id="10-5-1-声明自定义注解"><a href="#10-5-1-声明自定义注解" class="headerlink" title="10.5.1 声明自定义注解"></a>10.5.1 声明自定义注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【元注解】</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    【成员列表】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义注解可以通过四个元注解@Retention,@Target，@Inherited,@Documented，分别说明它的声明周期，使用位置，是否被继承，是否被生成到API文档中。</li>
<li>Annotation 的成员在 Annotation 定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组</li>
<li>可以使用 default 关键字为抽象方法指定默认返回值</li>
<li>如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是“方法名 = 返回值”，如果只有一个抽象方法需要赋值，且方法名为value，可以省略“value=”，所以如果注解只有一个抽象方法成员，建议使用方法名value。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    String <span class="title function_">columnName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">columnType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-5-2-使用自定义注解"><a href="#10-5-2-使用自定义注解" class="headerlink" title="10.5.2 使用自定义注解"></a>10.5.2 使用自定义注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.annotation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Table(&quot;t_stu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Column(columnName = &quot;sid&quot;,columnType = &quot;int&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@Column(columnName = &quot;sname&quot;,columnType = &quot;varchar(20)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="10-5-3-读取和处理自定义注解"><a href="#10-5-3-读取和处理自定义注解" class="headerlink" title="10.5.3 读取和处理自定义注解"></a>10.5.3 读取和处理自定义注解</h4><p>自定义注解必须配上注解的信息处理流程才有意义。</p>
<p>我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。</p>
<p>具体的使用见<code>《尚硅谷_宋红康_第17章_反射机制.md》</code>。</p>
<h3 id="10-6-JUnit单元测试"><a href="#10-6-JUnit单元测试" class="headerlink" title="10.6 JUnit单元测试"></a>10.6 JUnit单元测试</h3><h4 id="10-6-1-测试分类"><a href="#10-6-1-测试分类" class="headerlink" title="10.6.1 测试分类"></a>10.6.1 测试分类</h4><p><strong>黑盒测试：</strong>不需要写代码，给输入值，看程序是否能够输出期望的值。 </p>
<p><strong>白盒测试：</strong>需要写代码的。关注程序具体的执行流程。</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220511181800694.png" alt="image-20220511181800694" style="zoom: 50%;"></p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220524102038600.png" alt="image-20220524102038600"></p>
<h4 id="10-6-2-JUnit单元测试介绍"><a href="#10-6-2-JUnit单元测试介绍" class="headerlink" title="10.6.2 JUnit单元测试介绍"></a>10.6.2 JUnit单元测试介绍</h4><p>JUnit 是由 Erich Gamma 和 Kent Beck 编写的一个测试框架（regression testing framework），供Java开发人员编写单元测试之用。</p>
<p><strong>JUnit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。</strong></p>
<p>要使用JUnit，必须在项目的编译路径中<code>引入JUnit的库</code>，即相关的.class文件组成的jar包。jar就是一个压缩包，压缩包都是开发好的第三方（Oracle公司第一方，我们自己第二方，其他都是第三方）工具类，都是以class文件形式存在的。</p>
<h4 id="10-6-3-引入本地JUnit-jar"><a href="#10-6-3-引入本地JUnit-jar" class="headerlink" title="10.6.3 引入本地JUnit.jar"></a>10.6.3 引入本地JUnit.jar</h4><p>第1步：在项目中File-Project Structure中操作：添加Libraries库</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20211228180938922.png" alt="image-20211228180938922" style="zoom:80%;"></p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20221002195547325.png" alt="image-20221002195547325"></p>
<p>其中，junit-libs包内容如下：</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813005206452.png" alt="image-20220813005206452"></p>
<p>第2步：选择要在哪些module中应用JUnit库</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813005511062.png" alt="image-20220813005511062"></p>
<p>第3步：检查是否应用成功</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813005729233.png" alt="image-20220813005729233"></p>
<p><strong>注意Scope：选择Compile，否则编译时，无法使用JUnit。</strong></p>
<p>第4步：下次如果有新的模块要使用该libs库，这样操作即可</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813005944022.png" alt="image-20220813005944022"></p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813010018152.png" alt="image-20220813010018152"></p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813010055217.png" alt="image-20220813010055217"></p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813010124381.png" alt="image-20220813010124381"></p>
<h4 id="10-6-4-编写和运行-Test单元测试方法"><a href="#10-6-4-编写和运行-Test单元测试方法" class="headerlink" title="10.6.4 编写和运行@Test单元测试方法"></a>10.6.4 编写和运行@Test单元测试方法</h4><p>JUnit4版本，要求@Test标记的方法必须满足如下要求：</p>
<ul>
<li>所在的类必须是public的，非抽象的，包含唯一的无参构造器。</li>
<li>@Test标记的方法本身必须是public，非抽象的，非静态的，void无返回值，()无参数的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.junit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJUnit</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestJUnit.test01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestJUnit.test02&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestJUnit.test03&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220106152412245.png" alt="image-20220106152412245"></p>
<h4 id="10-6-5-设置执行JUnit用例时支持控制台输入"><a href="#10-6-5-设置执行JUnit用例时支持控制台输入" class="headerlink" title="10.6.5 设置执行JUnit用例时支持控制台输入"></a>10.6.5 设置执行JUnit用例时支持控制台输入</h4><p><strong>1. 设置数据：</strong></p>
<p>默认情况下，在单元测试方法中使用Scanner时，并不能实现控制台数据的输入。需要做如下设置：</p>
<p>在<code>idea64.exe.vmoptions配置文件</code>中加入下面一行设置，重启idea后生效。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">-Deditable.java.test.console</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 配置文件位置：</strong></p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813011625546.png" alt="image-20220813011625546"></p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813011642180.png" alt="image-20220813011642180"></p>
<p>添加完成之后，重启IDEA即可。</p>
<p><strong>3. 如果上述位置设置不成功，需要继续修改如下位置</strong></p>
<p>修改位置1：IDEA安装目录的bin目录（例如：<code>D:\develop_tools\IDEA\IntelliJ IDEA 2022.1.2\bin</code>）下的idea64.exe.vmoptions文件。 </p>
<p>修改位置2：C盘的用户目录<code>C:\Users\用户名\AppData\Roaming\JetBrains\IntelliJIdea2022.1</code> 下的idea64.exe.vmoptions`件。</p>
<h4 id="10-6-6-定义test测试方法模板"><a href="#10-6-6-定义test测试方法模板" class="headerlink" title="10.6.6 定义test测试方法模板"></a>10.6.6 定义test测试方法模板</h4><p>选中自定义的模板组，点击”+”（1.Live Template）来定义模板。</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20211229100040505.png" alt="image-20211229100040505"></p>
<h2 id="11-包装类"><a href="#11-包装类" class="headerlink" title="11. 包装类"></a>11. 包装类</h2><h3 id="11-1-为什么需要包装类"><a href="#11-1-为什么需要包装类" class="headerlink" title="11.1 为什么需要包装类"></a>11.1 为什么需要包装类</h3><p>Java提供了两个类型系统，<code>基本数据类型</code>与<code>引用数据类型</code>。使用基本数据类型在于效率，然而当要使用只针对对象设计的API或新特性（例如泛型），怎么办呢？例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况1：方法形参</span></span><br><span class="line">Object类的equals(Object obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2：方法形参</span></span><br><span class="line">ArrayList类的add(Object obj)</span><br><span class="line"><span class="comment">//没有如下的方法：</span></span><br><span class="line">add(<span class="type">int</span> number)</span><br><span class="line">add(<span class="type">double</span> d)</span><br><span class="line">add(<span class="type">boolean</span> b)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况3：泛型</span></span><br><span class="line">Set&lt;T&gt;</span><br><span class="line">List&lt;T&gt;</span><br><span class="line">Cllection&lt;T&gt;</span><br><span class="line">Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<h3 id="11-2-有哪些包装类"><a href="#11-2-有哪些包装类" class="headerlink" title="11.2 有哪些包装类"></a>11.2 有哪些包装类</h3><p>Java针对八种基本数据类型定义了相应的引用类型：包装类（封装类）。有了类的特点，就可以调用类中的方法，Java才是真正的面向对象。</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220329001912486.png" alt="image-20220329001912486" style="zoom:80%;"></p>
<p>封装以后的，内存结构对比：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">520</span>;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">520</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220514163725830.png" alt="image-20220514163725830" style="zoom:80%;"></p>
<h3 id="11-3-自定义包装类"><a href="#11-3-自定义包装类" class="headerlink" title="11.3 自定义包装类"></a>11.3 自定义包装类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInteger</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInteger</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="11-4-包装类与基本数据类型间的转换"><a href="#11-4-包装类与基本数据类型间的转换" class="headerlink" title="11.4 包装类与基本数据类型间的转换"></a>11.4 包装类与基本数据类型间的转换</h3><h4 id="11-4-1-装箱"><a href="#11-4-1-装箱" class="headerlink" title="11.4.1 装箱"></a>11.4.1 装箱</h4><p> <strong>装箱：把基本数据类型转为包装类对象</strong></p>
<blockquote>
<p>转为包装类的对象，是为了使用专门为对象设计的API和特性</p>
</blockquote>
<p>基本数值——&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line"><span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(“<span class="number">4.56</span>”);</span><br><span class="line"><span class="type">Long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Long</span>(“asdf”);  <span class="comment">//NumberFormatException</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">obj2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure>
<h4 id="11-4-2-拆箱"><a href="#11-4-2-拆箱" class="headerlink" title="11.4.2 拆箱"></a>11.4.2 拆箱</h4><p><strong>拆箱：把包装类对象拆为基本数据类型</strong></p>
<blockquote>
<p>转为基本数据类型，一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的。比较、算术等</p>
</blockquote>
<p>包装对象——&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> obj.intValue();</span><br></pre></td></tr></table></figure>
<p><strong>自动装箱与拆箱：</strong></p>
<p>由于我们经常要做基本类型与包装类之间的转换，从<code>JDK5.0</code>开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//错误的，1是int类型</span></span><br></pre></td></tr></table></figure>
<h3 id="11-5-基本数据类型、包装类与字符串间的转换"><a href="#11-5-基本数据类型、包装类与字符串间的转换" class="headerlink" title="11.5 基本数据类型、包装类与字符串间的转换"></a>11.5 基本数据类型、包装类与字符串间的转换</h3><p><strong>（1）基本数据类型转为字符串</strong></p>
<p><strong>方式1：</strong>调用字符串重载的valueOf()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//String str = a;//错误的</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(a);</span><br></pre></td></tr></table></figure>
<p><strong>方式2：</strong>更直接的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> a + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>（2）字符串转为基本数据类型</strong></p>
<p><strong>方式1：</strong>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型，例如：</p>
<ul>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
</ul>
<p><strong>方式2：</strong>字符串转为包装类，然后可以自动拆箱为基本数据类型</p>
<ul>
<li><code>public static Integer valueOf(String s)</code>：将字符串参数转换为对应的Integer包装类，然后可以自动拆箱为int基本类型</li>
<li><code>public static Long valueOf(String s)</code>：将字符串参数转换为对应的Long包装类，然后可以自动拆箱为long基本类型</li>
<li><code>public static Double valueOf(String s)</code>：将字符串参数转换为对应的Double包装类，然后可以自动拆箱为double基本类型</li>
</ul>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
<p><strong>方式3：</strong>通过包装类的构造器实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;整数的字符串&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;小数的字符串&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true或false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;整数的字符串&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.valueOf(<span class="string">&quot;小数的字符串&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.valueOf(<span class="string">&quot;true或false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(“<span class="number">12</span>”);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其他方式小结：</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813012801907.png" alt="image-20220813012801907"></p>
<h3 id="11-6-包装类的其它API"><a href="#11-6-包装类的其它API" class="headerlink" title="11.6 包装类的其它API"></a>11.6 包装类的其它API</h3><h4 id="11-6-1-数据类型的最大最小值"><a href="#11-6-1-数据类型的最大最小值" class="headerlink" title="11.6.1 数据类型的最大最小值"></a>11.6.1 数据类型的最大最小值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.MAX_VALUE和Integer.MIN_VALUE</span><br><span class="line">    </span><br><span class="line">Long.MAX_VALUE和Long.MIN_VALUE</span><br><span class="line">    </span><br><span class="line">Double.MAX_VALUE和Double.MIN_VALUE</span><br></pre></td></tr></table></figure>
<h4 id="11-6-2-字符转大小写"><a href="#11-6-2-字符转大小写" class="headerlink" title="11.6.2 字符转大小写"></a>11.6.2 字符转大小写</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character.toUpperCase(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Character.toLowerCase(<span class="string">&#x27;X&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="11-6-3-整数转进制"><a href="#11-6-3-整数转进制" class="headerlink" title="11.6.3 整数转进制"></a>11.6.3 整数转进制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="type">int</span> i) </span><br><span class="line">    </span><br><span class="line">Integer.toHexString(<span class="type">int</span> i)</span><br><span class="line">    </span><br><span class="line">Integer.toOctalString(<span class="type">int</span> i)</span><br></pre></td></tr></table></figure>
<h4 id="11-6-4-比较的方法"><a href="#11-6-4-比较的方法" class="headerlink" title="11.6.4 比较的方法"></a>11.6.4 比较的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double.compare(<span class="type">double</span> d1, <span class="type">double</span> d2)</span><br><span class="line">    </span><br><span class="line">Integer.compare(<span class="type">int</span> x, <span class="type">int</span> y) </span><br></pre></td></tr></table></figure>
<h3 id="11-7-包装类对象的特点"><a href="#11-7-包装类对象的特点" class="headerlink" title="11.7 包装类对象的特点"></a>11.7 包装类对象的特点</h3><h4 id="11-7-1-包装类缓存对象"><a href="#11-7-1-包装类缓存对象" class="headerlink" title="11.7.1 包装类缓存对象"></a>11.7.1 包装类缓存对象</h4><div class="table-container">
<table>
<thead>
<tr>
<th>包装类</th>
<th>缓存对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Byte</td>
<td>-128~127</td>
</tr>
<tr>
<td>Short</td>
<td>-128~127</td>
</tr>
<tr>
<td>Integer</td>
<td>-128~127</td>
</tr>
<tr>
<td>Long</td>
<td>-128~127</td>
</tr>
<tr>
<td>Float</td>
<td>没有</td>
</tr>
<tr>
<td>Double</td>
<td>没有</td>
</tr>
<tr>
<td>Character</td>
<td>0~127</td>
</tr>
<tr>
<td>Boolean</td>
<td>true和false</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//这个用的是缓冲的常量对象，在方法区</span></span><br><span class="line">System.out.println(m == n);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);<span class="comment">//另一个新new的在堆中</span></span><br><span class="line">System.out.println(x == y);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">System.out.println(d1==d2);<span class="comment">//false 比较地址，没有缓存对象，每一个都是新new的</span></span><br></pre></td></tr></table></figure>
<h4 id="11-7-2-类型转换问题"><a href="#11-7-2-类型转换问题" class="headerlink" title="11.7.2 类型转换问题"></a>11.7.2 类型转换问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(i==j);<span class="comment">//true  会先将i自动拆箱为int，然后根据基本数据类型“自动类型转换”规则，转为double比较</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(i==j);<span class="comment">//true 会自动拆箱，按照基本数据类型进行比较</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.0</span></span><br><span class="line">System.out.println(i==d);<span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure>
<h4 id="11-7-3-包装类对象不可变"><a href="#11-7-3-包装类对象不可变" class="headerlink" title="11.7.3 包装类对象不可变"></a>11.7.3 包装类对象不可变</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExam</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="type">Circle</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">		change(i,j,c);</span><br><span class="line">		System.out.println(<span class="string">&quot;i = &quot;</span> + i);<span class="comment">//1</span></span><br><span class="line">		System.out.println(<span class="string">&quot;j = &quot;</span> + j);<span class="comment">//2</span></span><br><span class="line">		System.out.println(<span class="string">&quot;c.radius = &quot;</span> + c.radius);<span class="comment">//10.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 方法的参数传递机制：</span></span><br><span class="line"><span class="comment">	 * （1）基本数据类型：形参的修改完全不影响实参</span></span><br><span class="line"><span class="comment">	 * （2）引用数据类型：通过形参修改对象的属性值，会影响实参的属性值</span></span><br><span class="line"><span class="comment">	 * 这类Integer等包装类对象是“不可变”对象，即一旦修改，就是新对象，和实参就无关了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a ,Integer b,Circle c )</span>&#123;</span><br><span class="line">		a += <span class="number">10</span>;</span><br><span class="line"><span class="comment">//		b += 10;//等价于  b = new Integer(b+10);</span></span><br><span class="line">		c.radius += <span class="number">10</span>;</span><br><span class="line">		<span class="comment">/*c = new Circle();</span></span><br><span class="line"><span class="comment">		c.radius+=10;*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">	<span class="type">double</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-8-练习"><a href="#11-8-练习" class="headerlink" title="11.8 练习"></a>11.8 练习</h3><p>笔试题：如下两个题目输出结果相同吗？各是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o1);<span class="comment">//1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o2;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">    o2 = <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    o2 = <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o2);<span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>面试题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y);<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>练习：</p>
<p>利用Vector代替数组处理：从键盘读入学生成绩（以负数代表输入结束），找出最高分，并输出学生成绩等级。</p>
<ul>
<li><p>提示：数组一旦创建，长度就固定不变，所以在创建数组前就需要知道它的长度。而向量类java.util.Vector可以根据需要动态伸缩。</p>
</li>
<li><p>创建Vector对象：Vector v=new Vector();</p>
</li>
<li><p>给向量添加元素：v.addElement(Object obj);  //obj必须是对象</p>
</li>
<li><p>取出向量中的元素：Object obj=v.elementAt(0);</p>
<ul>
<li>注意第一个元素的下标是0，返回值是Object类型的。</li>
</ul>
</li>
<li><p>计算向量的长度：v.size();</p>
</li>
<li><p>若与最高分相差10分内：A等；20分内：B等；30分内：C等；其它：D等</p>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post-share"><div class="social-share" data-image="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/" title="第07章_面向对象编程(进阶)"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">第07章_面向对象编程(进阶)</div></div><div class="info-2"><div class="info-item-1">第07章_面向对象编程(进阶)讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com  本章专题与脉络 1. 关键字：this1.1 this是什么？ 在Java中，this关键字不算难理解，它的作用和其词义很接近。  它在方法（准确的说是实例方法或非static的方法）内部使用，表示调用该方法的对象 它在构造器内部使用，表示该构造器正在初始化的对象。   this可以调用的结构：成员变量、方法和构造器   1.2 什么时候使用this1.2.1 实例方法或构造器中使用当前对象的成员在实例方法或构造器中，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的可读性。不过，通常我们都习惯省略this。 但是，当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量。即：我们可以用this来区分成员变量和局部变量。比如：  另外，使用this访问属性和方法时，如果在本类中未找到，会从父类中查找。这个在继承中会讲到。 举例1： class Person&#123;		//...</div></div></div></a><a class="pagination-related" href="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="第09章_异常处理"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第09章_异常处理</div></div><div class="info-2"><div class="info-item-1">第09章_异常处理讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com  本章专题与脉络 1. 异常概述1.1 什么是生活的异常男主角小明每天开车上班，正常车程1小时。但是，不出意外的话，可能会出现意外。  出现意外，即为异常情况。我们会做相应的处理。如果不处理，到不了公司。处理完了，就可以正常开车去公司。  1.2 什么是程序的异常在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式问题，读取文件是否存在，网络是否始终保持通畅等等。  异常 ：指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止。   异常指的并不是语法错误和逻辑错误。语法错了，编译不通过，不会产生字节码文件，根本不能运行。 代码逻辑错误，只是没有得到想要的结果，例如：求a与b的和，你写成了a-b  1.3...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" title="第01章_Java语言概述"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="info-item-2">第01章_Java语言概述</div></div><div class="info-2"><div class="info-item-1">第01章_Java语言概述讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com  1. Java知识脉络图1.1 Java基础全程脉络图 1.2 本章专题与脉络 2. 抽丝剥茧话Java2.1 当前大学生就业形势 麦可思研究院发布了《2022年中国大学生就业报告》，针对2021届毕业生收入较高的本科专业排行榜：    麦可思研究院发布过《2021年中国大学生就业报告》，应届本科毕业生就业数量较大的前十位行业类的就业质量：   报告还对毕业三年后的2017届毕业生所在十大行业进行了统计：     从国家统计局发布的2021年全国平均工资来看，不管在城镇非私营单位还是私营单位，IT业均为最高。  2.2 IT互联网是否依旧靠谱过去不能代表未来！互联网是否依旧靠谱？！   2014 年至 2018 年间，我国网民规模从 6.49 亿增长为 8.29 亿，增幅为 27.5%。同一时间段，全国移动互联网接入的流量却从 20.6EB 增长到了 711.1EB，增幅达 3352%（获取和处理的信息量大幅增加）。  随着 5G...</div></div></div></a><a class="pagination-related" href="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/" title="第02章_变量与运算符"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="info-item-2">第02章_变量与运算符</div></div><div class="info-2"><div class="info-item-1">第02章_变量与运算符讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com  本章专题与脉络 1. 关键字（keyword） 定义：被Java语言赋予了特殊含义，用做专门用途的字符串（或单词） HelloWorld案例中，出现的关键字有 class、public  、 static 、  void  等，这些单词已经被Java定义好了。   特点：全部关键字都是小写字母。 关键字比较多，不需要死记硬背，学到哪里记到哪里即可。 官方地址： https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html     说明：  关键字一共50个，其中const和goto是保留字(reserved word)。 true，false，null不在其中，它们看起来像关键字，其实是字面量，表示特殊的布尔值和空值。     2. 标识符(...</div></div></div></a><a class="pagination-related" href="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/" title="第03章_流程控制语句"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="info-item-2">第03章_流程控制语句</div></div><div class="info-2"><div class="info-item-1">第03章_流程控制语句讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com  本章专题与脉络   流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。  程序设计中规定的三种流程结构，即：  顺序结构 程序从上到下逐行地执行，中间没有任何判断和跳转。   分支结构 根据条件，选择性地执行某段代码。 有if…else和switch-case两种分支语句。   循环结构 根据循环条件，重复性的执行某段代码。 有for、while、do-while三种循环语句。 补充：JDK5.0 提供了foreach循环，方便的遍历集合、数组元素。（第12章集合中讲解）     生活中、工业生产中流程控制举例   1. 顺序结构顺序结构就是程序从上到下逐行地执行。表达式语句都是顺序执行的。并且上一行对某个变量的修改对下一行会产生影响。  public class StatementTest&#123;	public static void main(String[] args)&#123;		int x =...</div></div></div></a><a class="pagination-related" href="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/" title="第04章_IDEA的安装与使用（上）"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="info-item-2">第04章_IDEA的安装与使用（上）</div></div><div class="info-2"><div class="info-item-1">第04章_IDEA的安装与使用（上）讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com  本章专题与脉络  【Why IDEA ?】    【注】JetBrains官方说明： 尽管我们采取了多种措施确保受访者的代表性，但结果可能会略微偏向 JetBrains 产品的用户，因为这些用户更有可能参加调查。  此外，2022年，某美国软件开发商在对近千名专业的Java开发者调研后，发布了《2022年Java开发者生产力报告》。报告提到：JetBrains 的 IntelliJ IDEA是最受欢迎的 Java IDE，占 48%，其次是 Eclipse，占 24%，Visual Studio Code 占 18%。  本着”工欲善其事必先利其器“的精神，本章从IDEA的介绍、安装、设置入手，讲解IDEA中项目的创建、快捷键与模板的使用、断点调试、常用插件等。 1. 认识IntelliJ IDEA1.1 JetBrains  公司介绍IDEA，是 JetBrains...</div></div></div></a><a class="pagination-related" href="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/" title="第04章_IDEA的安装与使用（下）"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="info-item-2">第04章_IDEA的安装与使用（下）</div></div><div class="info-2"><div class="info-item-1">第04章_IDEA的安装与使用（下）讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com  8. 快捷键的使用8.1 常用快捷键见《尚硅谷_宋红康_IntelliJ IDEA 常用快捷键一览表.md》 8.2 查看快捷键1、已知快捷键操作名，未知快捷键 2、已知快捷键，不知道对应的操作名 8.3 自定义快捷键 8.4 使用其它平台快捷键苹果电脑或者是用惯Eclipse快捷的，可以选择其他快捷键插件。  9. IDEA断点调试(Debug)9.1 为什么需要Debug编好的程序在执行过程中如果出现错误，该如何查找或定位错误呢？简单的代码直接就可以看出来，但如果代码比较复杂，就需要借助程序调试工具（Debug）来查找错误了。 运行编写好的程序时，可能出现的几种情况：&gt; 情况1：没有任何bug,程序执行正确！====================如果出现如下的三种情况，都又必要使用debug=============================&gt;...</div></div></div></a><a class="pagination-related" href="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/" title="第05章_数组"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="info-item-2">第05章_数组</div></div><div class="info-2"><div class="info-item-1">第05章_数组讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com  本章专题与脉络 1. 数组的概述1.1 为什么需要数组需求分析1： 需要统计某公司50个员工的工资情况，例如计算平均工资、找到最高工资等。用之前知识，首先需要声明50个变量来分别记录每位员工的工资，这样会很麻烦。因此我们可以将所有的数据全部存储到一个容器中统一管理，并使用容器进行计算。 需求分析2：  容器的概念：  生活中的容器：水杯（装水等液体），衣柜（装衣服等物品），集装箱（装货物等）。 程序中的容器：将多个数据存储到一起，每个数据称为该容器的元素。  1.2...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">YZ</div><div class="author-info-description">YZ的博客,欢迎访问</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yangzhengyz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yangzhengyz" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2863057582yz@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/2863057582yz@gmail.com" target="_blank" title="twitter"><i class="fa-brands fa-twitter"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to  my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC08%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7"><span class="toc-text">第08章_面向对象编程(高级)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E4%B8%93%E9%A2%98%E4%B8%8E%E8%84%89%E7%BB%9C"><span class="toc-text">本章专题与脉络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Astatic"><span class="toc-text">1. 关键字：static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%B1%BB%E5%B1%9E%E6%80%A7%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-text">1.1 类属性、类方法的设计思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">1.2 static关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">1.3 静态变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-text">1.3.1 语法格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">1.3.2 静态变量的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E4%B8%BE%E4%BE%8B"><span class="toc-text">1.3.3 举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-text">1.3.4 内存解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">1.4 静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-text">1.4.1 语法格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">1.4.2 静态方法的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E4%B8%BE%E4%BE%8B"><span class="toc-text">1.4.3 举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E7%BB%83%E4%B9%A0"><span class="toc-text">1.5 练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8D%95%E4%BE%8B-Singleton-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">2. 单例(Singleton)设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 设计模式概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BD%95%E4%B8%BA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2 何为单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">2.3 实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">2.4 单例模式的两种实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-text">2.4.1 饿汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-text">2.4.2 懒汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E9%A5%BF%E6%B1%89%E5%BC%8F-vs-%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-text">2.4.3 饿汉式 vs 懒汉式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.5 单例模式的优点及应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%90%86%E8%A7%A3main%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">3. 理解main方法的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">4. 类的成员之四：代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">4.1 静态代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-text">4.1.1 语法格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">4.1.2 静态代码块的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">4.2 非静态代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-text">4.2.1 语法格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">4.2.2 非静态代码块的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">4.2.3 非静态代码块的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E6%89%A7%E8%A1%8C%E7%89%B9%E7%82%B9"><span class="toc-text">4.2.4 非静态代码块的执行特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%B8%BE%E4%BE%8B"><span class="toc-text">4.3 举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%B0%8F%E7%BB%93%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-text">4.4 小结：实例变量赋值顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E7%BB%83%E4%B9%A0"><span class="toc-text">4.5 练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">5. final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-final%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">5.1 final的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-final%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">5.2 final的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-final%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-text">5.2.1 final修饰类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-final%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-text">5.2.2 final修饰方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-final%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-text">5.2.3 final修饰变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-text">5.3 笔试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-%E6%88%96abstract%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">6. 抽象类与抽象方法(或abstract关键字)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E7%94%B1%E6%9D%A5"><span class="toc-text">6.1 由来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-text">6.2 语法格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-text">6.3 使用说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">6.4 注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B1"><span class="toc-text">6.5 应用举例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B2%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-TemplateMethod"><span class="toc-text">6.6 应用举例2：模板方法设计模式(TemplateMethod)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E6%80%9D%E8%80%83%E4%B8%8E%E7%BB%83%E4%B9%A0"><span class="toc-text">6.7 思考与练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8E%A5%E5%8F%A3-interface"><span class="toc-text">7. 接口(interface)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%B1%BB%E6%AF%94"><span class="toc-text">7.1 类比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%A6%82%E8%BF%B0"><span class="toc-text">7.2 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="toc-text">7.3 定义格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A3%B0%E6%98%8E%E6%A0%BC%E5%BC%8F"><span class="toc-text">7.3.1 接口的声明格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%88%90%E5%91%98%E8%AF%B4%E6%98%8E"><span class="toc-text">7.3.2 接口的成员说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">7.4 接口的使用规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-JDK8%E4%B8%AD%E7%9B%B8%E5%85%B3%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-text">7.5 JDK8中相关冲突问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-text">7.5.1 默认方法冲突问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-2-%E5%B8%B8%E9%87%8F%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-text">7.5.2 常量冲突问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">7.6 接口的总结与面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">7.7 接口与抽象类之间的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-%E7%BB%83%E4%B9%A0"><span class="toc-text">7.8 练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88InnerClass"><span class="toc-text">8. 内部类（InnerClass)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">8.1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">8.1.1 什么是内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A3%B0%E6%98%8E%E5%86%85%E9%83%A8%E7%B1%BB%E5%91%A2"><span class="toc-text">8.1.2 为什么要声明内部类呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">8.1.3 内部类的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">8.2 成员内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">8.2.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-%E5%88%9B%E5%BB%BA%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.2.2 创建成员内部类对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-%E4%B8%BE%E4%BE%8B"><span class="toc-text">8.2.3 举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">8.3 局部内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-%E9%9D%9E%E5%8C%BF%E5%90%8D%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">8.3.1 非匿名局部内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">8.3.2 匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E7%BB%83%E4%B9%A0"><span class="toc-text">8.4 练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">9. 枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">9.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88JDK5-0-%E4%B9%8B%E5%89%8D%EF%BC%89"><span class="toc-text">9.2 定义枚举类（JDK5.0 之前）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88JDK5-0-%E4%B9%8B%E5%90%8E%EF%BC%89"><span class="toc-text">9.3 定义枚举类（JDK5.0 之后）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%A3%B0%E6%98%8E%E6%9E%9A%E4%B8%BE"><span class="toc-text">9.3.1 enum关键字声明枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-enum%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A6%81%E6%B1%82%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-text">9.3.2 enum方式定义的要求和特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-enum%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">9.4 enum中常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">9.5 实现接口的枚举类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%B3%A8%E8%A7%A3-Annotation"><span class="toc-text">10. 注解(Annotation)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0"><span class="toc-text">10.1 注解概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E8%A7%A3"><span class="toc-text">10.1.1 什么是注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E6%B3%A8%E9%87%8A"><span class="toc-text">10.1.2 注解与注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-3-%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-text">10.1.3 注解的重要性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%B8%B8%E8%A7%81%E7%9A%84Annotation%E4%BD%9C%E7%94%A8"><span class="toc-text">10.2 常见的Annotation作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E4%B8%89%E4%B8%AA%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-text">10.3 三个最基本的注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-Override"><span class="toc-text">10.3.1 @Override</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2-Deprecated"><span class="toc-text">10.3.2 @Deprecated</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-3-SuppressWarnings"><span class="toc-text">10.3.3 @SuppressWarnings</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-text">10.4 元注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">10.5 自定义注解的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-1-%E5%A3%B0%E6%98%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">10.5.1 声明自定义注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-2-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">10.5.2 使用自定义注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-3-%E8%AF%BB%E5%8F%96%E5%92%8C%E5%A4%84%E7%90%86%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">10.5.3 读取和处理自定义注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">10.6 JUnit单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-1-%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB"><span class="toc-text">10.6.1 测试分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-2-JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">10.6.2 JUnit单元测试介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-3-%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0JUnit-jar"><span class="toc-text">10.6.3 引入本地JUnit.jar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-4-%E7%BC%96%E5%86%99%E5%92%8C%E8%BF%90%E8%A1%8C-Test%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-text">10.6.4 编写和运行@Test单元测试方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-5-%E8%AE%BE%E7%BD%AE%E6%89%A7%E8%A1%8CJUnit%E7%94%A8%E4%BE%8B%E6%97%B6%E6%94%AF%E6%8C%81%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5"><span class="toc-text">10.6.5 设置执行JUnit用例时支持控制台输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-6-%E5%AE%9A%E4%B9%89test%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-text">10.6.6 定义test测试方法模板</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">11. 包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">11.1 为什么需要包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">11.2 有哪些包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">11.3 自定义包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">11.4 包装类与基本数据类型间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-1-%E8%A3%85%E7%AE%B1"><span class="toc-text">11.4.1 装箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-2-%E6%8B%86%E7%AE%B1"><span class="toc-text">11.4.2 拆箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">11.5 基本数据类型、包装类与字符串间的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%85%B6%E5%AE%83API"><span class="toc-text">11.6 包装类的其它API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">11.6.1 数据类型的最大最小值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-2-%E5%AD%97%E7%AC%A6%E8%BD%AC%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-text">11.6.2 字符转大小写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-3-%E6%95%B4%E6%95%B0%E8%BD%AC%E8%BF%9B%E5%88%B6"><span class="toc-text">11.6.3 整数转进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-4-%E6%AF%94%E8%BE%83%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">11.6.4 比较的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">11.7 包装类对象的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-1-%E5%8C%85%E8%A3%85%E7%B1%BB%E7%BC%93%E5%AD%98%E5%AF%B9%E8%B1%A1"><span class="toc-text">11.7.1 包装类缓存对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-2-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98"><span class="toc-text">11.7.2 类型转换问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-3-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">11.7.3 包装类对象不可变</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-8-%E7%BB%83%E4%B9%A0"><span class="toc-text">11.8 练习</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/JUC/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java并发编程学习笔记"><img src="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发编程学习笔记"/></a><div class="content"><a class="title" href="/2025/03/01/JUC/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java并发编程学习笔记">Java并发编程学习笔记</a><time datetime="2025-03-01T08:44:39.000Z" title="发表于 2025-03-01 16:44:39">2025-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/16/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/" title="代码演示"><img src="https://img1.baidu.com/it/u=3486908499,2121835088&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码演示"/></a><div class="content"><a class="title" href="/2024/05/16/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/" title="代码演示">代码演示</a><time datetime="2024-05-16T13:02:53.090Z" title="发表于 2024-05-16 21:02:53">2024-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/16/hello-world/" title="Hello World"><img src="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2024/05/16/hello-world/" title="Hello World">Hello World</a><time datetime="2024-05-16T13:02:41.430Z" title="发表于 2024-05-16 21:02:41">2024-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/08/Java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6/" title="泛型和通配符"><img src="https://img1.baidu.com/it/u=3486908499,2121835088&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="泛型和通配符"/></a><div class="content"><a class="title" href="/2023/08/08/Java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6/" title="泛型和通配符">泛型和通配符</a><time datetime="2023-08-08T02:17:47.000Z" title="发表于 2023-08-08 10:17:47">2023-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/01/Java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EThreadLocal/" title="关于ThreadLocal"><img src="https://img1:baidu:com/it/u=1777496104,822946362&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于ThreadLocal"/></a><div class="content"><a class="title" href="/2023/08/01/Java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EThreadLocal/" title="关于ThreadLocal">关于ThreadLocal</a><time datetime="2023-08-01T03:11:23.000Z" title="发表于 2023-08-01 11:11:23">2023-08-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By YZ</div><div class="footer_custom_text">很高兴认识你</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="7193364325" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true 
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>