<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第18章_JDK8-17新特性（上） | YZ</title><meta name="author" content="YZ"><meta name="copyright" content="YZ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第18章_JDK8-17新特性（上）讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com  本章专题与脉络  1. Java版本迭代概述1.1 发布特点（小步快跑，快速迭代）    发行版本 发行时间 备注     Java..."><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第18章_JDK8-17新特性（上）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-19 15:38:43'
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="YZ" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic2.zhimg.com%2F50%2Fv2-64c5dbd1e6a174f1371a13b018df0a8d_r.jpg&amp;refer=http%3A%2F%2Fpic2.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1654421720&amp;t=cf6b4b204d29dc42447fb634cdc8bd33));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">YZ</span></a><a class="nav-page-title" href="/"><span class="site-name">第18章_JDK8-17新特性（上）</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">第18章_JDK8-17新特性（上）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-18T12:37:01.000Z" title="发表于 2023-02-18 20:37:01">2023-02-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-19T07:38:43.083Z" title="更新于 2023-02-19 15:38:43">2023-02-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java2023/">Java2023</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第18章-JDK8-17新特性（上）"><a href="#第18章-JDK8-17新特性（上）" class="headerlink" title="第18章_JDK8-17新特性（上）"></a>第18章_JDK8-17新特性（上）</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p>
<p>官网：<a target="_blank" rel="noopener" href="http://www.atguigu.com/">http://www.atguigu.com</a></p>
<hr>
<h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/第3阶段：Java高级应用-第18章.png" alt="第3阶段：Java高级应用-第18章"></p>
<hr>
<h2 id="1-Java版本迭代概述"><a href="#1-Java版本迭代概述" class="headerlink" title="1. Java版本迭代概述"></a>1. Java版本迭代概述</h2><h3 id="1-1-发布特点（小步快跑，快速迭代）"><a href="#1-1-发布特点（小步快跑，快速迭代）" class="headerlink" title="1.1 发布特点（小步快跑，快速迭代）"></a>1.1 发布特点（小步快跑，快速迭代）</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">发行版本</th>
<th style="text-align:center">发行时间</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Java 1.0</td>
<td style="text-align:center">1996.01.23</td>
<td style="text-align:center">Sun公司发布了Java的第一个开发工具包</td>
</tr>
<tr>
<td style="text-align:center">Java 5.0</td>
<td style="text-align:center">2004.09.30</td>
<td style="text-align:center">①版本号从1.4直接更新至5.0；②平台更名为JavaSE、JavaEE、JavaME</td>
</tr>
<tr>
<td style="text-align:center">Java 8.0</td>
<td style="text-align:center">2014.03.18</td>
<td style="text-align:center">此版本是继Java 5.0以来变化最大的版本。是长期支持版本（<code>LTS</code>）</td>
</tr>
<tr>
<td style="text-align:center">Java 9.0</td>
<td style="text-align:center">2017.09.22</td>
<td style="text-align:center"><strong>此版本开始，每半年更新一次</strong></td>
</tr>
<tr>
<td style="text-align:center">Java 10.0</td>
<td style="text-align:center">2018.03.21</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Java 11.0</td>
<td style="text-align:center">2018.09.25</td>
<td style="text-align:center">JDK安装包取消独立JRE安装包，是长期支持版本（<code>LTS</code>）</td>
</tr>
<tr>
<td style="text-align:center">Java 12.0</td>
<td style="text-align:center">2019.03.19</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Java17.0</td>
<td style="text-align:center">2021.09</td>
<td style="text-align:center">发布Java 17.0，版本号也称为21.9，是长期支持版本（<code>LTS</code>）</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Java19.0</td>
<td style="text-align:center">2022.09</td>
<td style="text-align:center">发布Java19.0，版本号也称为22.9。</td>
</tr>
</tbody>
</table>
</div>
<p>从Java 9 这个版本开始，Java 的计划发布周期是 <code>6个月</code>。</p>
<p>这意味着Java的更新从传统的以<code>特性驱动</code>的发布周期，转变为以<code>时间驱动</code>的发布模式，并且承诺不会跳票。通过这样的方式，开发团队可以把一些关键特性尽早合并到 JDK 之中，以快速得到开发者反馈，在一定程度上避免出现像 Java 9 两次被迫延迟发布的窘况。</p>
<p>针对企业客户的需求，Oracle 将以<code>三年</code>为周期发布长期支持版本（long term support）。</p>
<p>Oracle 的官方观点认为：<strong>与 Java 7-&gt;8-&gt;9 相比，Java 9-&gt;10-&gt;11的升级和 8-&gt;8u20-&gt;8u40 更相似。</strong></p>
<p>新模式下的 Java 版本发布都会包含许多变更，包括<code>语言变更</code>和 <code>JVM 变更</code>，这两者都会对 IDE、字节码库和框架产生重大影响。此外，不仅会新增其他 API，还会有 <code>API被删除</code>（这在 Java 8 之前没有发生过）。</p>
<p>目前看这种发布策略是非常成功的，<strong>解开了 Java/JVM 演进的许多枷锁，至关重要的是，OpenJDK 的权力中心，正在转移到开发社区和开发者手中。</strong>在新的模式中，既可以利用 LTS 满足企业长期可靠支持的需求，也可以满足各种开发者对于新特性迭代的诉求。因为用 2-3 年的最小间隔粒度来试验一个特性，基本是不现实的。</p>
<h3 id="1-2-名词解释"><a href="#1-2-名词解释" class="headerlink" title="1.2 名词解释"></a>1.2 名词解释</h3><h4 id="名词解释：Oracle-JDK和Open-JDK"><a href="#名词解释：Oracle-JDK和Open-JDK" class="headerlink" title="名词解释：Oracle JDK和Open JDK"></a>名词解释：Oracle JDK和Open JDK</h4><p>这两个JDK最大不同就是许可证不一样。<strong>但是对于个人用户来讲，没区别。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Oracle JDK</th>
<th>Open JDK</th>
</tr>
</thead>
<tbody>
<tr>
<td>来源</td>
<td>Oracle团队维护</td>
<td>Oracle和Open Java社区</td>
</tr>
<tr>
<td>授权协议</td>
<td>Java 17及更高版本 Oracle Java SE 许可证<br>Java16及更低版本甲骨文免费条款和条件 （NFTC） 许可协议</td>
<td>GPL v2许可证</td>
</tr>
<tr>
<td>关系</td>
<td>由Open JDK构建，增加了少许内容</td>
<td></td>
</tr>
<tr>
<td>是否收费</td>
<td>2021年9月起Java17及更高版本所有用户免费。 16及更低版本，个人用户、开发用户免费。</td>
<td>2017年9月起，所有版本免费</td>
</tr>
<tr>
<td>对语法的支持</td>
<td>一致</td>
<td>一致</td>
</tr>
</tbody>
</table>
</div>
<h4 id="名词解释：JEP"><a href="#名词解释：JEP" class="headerlink" title="名词解释：JEP"></a>名词解释：JEP</h4><p>JEP(JDK Enhancement Proposals)：jdk 改进提案，每当需要有新的设想时候，JEP可以提出非正式的规范(specification)，被正式认可的JEP正式写进JDK的发展路线图并分配版本号。</p>
<h4 id="名词解释：LTS"><a href="#名词解释：LTS" class="headerlink" title="名词解释：LTS"></a>名词解释：LTS</h4><p>LTS（Long-term Support）即长期支持。Oracle官网提供了对Oracle JDK个别版本的长期支持，即使发发行了新版本，比如目前最新的JDK19，在结束日期前，LTS版本都会被长期支持。（出了bug，会被修复，非LTS则不会再有补丁发布）所以，一定要选一个LTS版本，不然出了漏洞没人修复了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>版本</th>
<th>开始日期</th>
<th>结束日期</th>
<th>延期结束日期</th>
</tr>
</thead>
<tbody>
<tr>
<td>7（LTS）</td>
<td>2011年7月</td>
<td>2019年7月</td>
<td>2022年7月</td>
</tr>
<tr>
<td>8（LTS）</td>
<td>2014年3月</td>
<td>2022年3月</td>
<td>2030年12月</td>
</tr>
<tr>
<td>11（LTS）</td>
<td>2018年9月</td>
<td>2023年9月</td>
<td>2026年9月</td>
</tr>
<tr>
<td>17（LTS）</td>
<td>2021年9月</td>
<td>2026年9月</td>
<td>2029年9月</td>
</tr>
<tr>
<td>21（LTS）</td>
<td>2023年9月</td>
<td>2028年9月</td>
<td>2031年9月</td>
</tr>
</tbody>
</table>
</div>
<p>如果要选择Oracle JDK，目前可选的LTS版本为8、11、17三个。</p>
<h3 id="1-3-各版本支持时间路线图"><a href="#1-3-各版本支持时间路线图" class="headerlink" title="1.3 各版本支持时间路线图"></a>1.3 各版本支持时间路线图</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/4428b288361296048.png" alt="4428b288361296048"></p>
<h3 id="1-4-各版本介绍"><a href="#1-4-各版本介绍" class="headerlink" title="1.4 各版本介绍"></a>1.4 各版本介绍</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/jdkxintexing.jpg" alt="jdkxintexing"></p>
<h4 id="jdk-9"><a href="#jdk-9" class="headerlink" title="jdk 9"></a>jdk 9</h4><p>Java 9 提供了<code>超过150项</code>新功能特性，包括备受期待的模块化系统、可交互的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安全增强、扩展提升、性能管理改善等。</p>
<p>特性太多，查看链接：</p>
<p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk9/">https://openjdk.java.net/projects/jdk9/</a></p>
<h4 id="jdk-10"><a href="#jdk-10" class="headerlink" title="jdk 10"></a>jdk 10</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/10/">https://openjdk.java.net/projects/jdk/10/</a></p>
<blockquote>
<p>286: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/286">Local-Variable Type Inference</a> 局部变量类型推断<br> 296: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/296">Consolidate the JDK Forest into a Single Repository</a> JDK库的合并<br> 304: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/304">Garbage-Collector Interface</a> 统一的垃圾回收接口<br> 307: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/307">Parallel Full GC for G1</a> 为G1提供并行的Full GC<br> 310: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/310">Application Class-Data Sharing</a> 应用程序类数据（AppCDS）共享<br> 312: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/312">Thread-Local Handshakes</a> ThreadLocal握手交互<br> 313: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/313">Remove the Native-Header Generation Tool (javah)</a> 移除JDK中附带的javah工具<br> 314: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/314">Additional Unicode Language-Tag Extensions</a> 使用附加的Unicode语言标记扩展<br> 316: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/316">Heap Allocation on Alternative Memory Devices</a> 能将堆内存占用分配给用户指定的备用内存设备<br> 317: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/317">Experimental Java-Based JIT Compiler</a> 使用Graal基于Java的编译器</p>
<p>319: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/319">Root Certificates</a> 根证书<br> 322: <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/322">Time-Based Release Versioning</a> 基于时间定于的发布版本</p>
</blockquote>
<h4 id="jdk-11"><a href="#jdk-11" class="headerlink" title="jdk 11"></a>jdk 11</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/11/">https://openjdk.java.net/projects/jdk/11/</a></p>
<blockquote>
<p>181: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/181">Nest-Based Access Control</a>  基于嵌套的访问控制<br>309: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/309">Dynamic Class-File Constants</a> 动态类文件常量<br>315: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/315">Improve Aarch64 Intrinsics</a> 改进 Aarch64 Intrinsics<br>318: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/318">Epsilon: A No-Op Garbage Collector</a> Epsilon — 一个No-Op（无操作）的垃圾收集器<br>320: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/320">Remove the Java EE and CORBA Modules</a> 删除 Java EE 和 CORBA 模块<br>321: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/321">HTTP Client (Standard)</a>  HTTPClient API<br>323: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/323">Local-Variable Syntax for Lambda Parameters</a>  用于 Lambda 参数的局部变量语法<br>324: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/324">Key Agreement with Curve25519 and Curve448</a> Curve25519 和 Curve448 算法的密钥协议<br>327: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/327">Unicode 10</a><br>328: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/328">Flight Recorder</a> 飞行记录仪<br>329: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/329">ChaCha20 and Poly1305 Cryptographic Algorithms</a> ChaCha20 和 Poly1305 加密算法<br>330: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/330">Launch Single-File Source-Code Programs</a> 启动单一文件的源代码程序<br>331: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/331">Low-Overhead Heap Profiling</a> 低开销的 Heap Profiling<br>332: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/332">Transport Layer Security (TLS) 1.3</a> 支持 TLS 1.3<br>333: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/333">ZGC: A Scalable Low-Latency Garbage Collector<br>   (Experimental)</a> 可伸缩低延迟垃圾收集器<br>335: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/335">Deprecate the Nashorn JavaScript Engine</a> 弃用 Nashorn JavaScript 引擎<br>336: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/336">Deprecate the Pack200 Tools and API</a>  弃用 Pack200 工具和 API</p>
</blockquote>
<h4 id="jdk-12"><a href="#jdk-12" class="headerlink" title="jdk 12"></a>jdk 12</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/12/">https://openjdk.java.net/projects/jdk/12/</a></p>
<blockquote>
<p>189：<a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/189">Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</a> 低暂停时间的GC<br>230: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/230">Microbenchmark Suite</a> 微基准测试套件<br>325: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/325">Switch Expressions (Preview)</a> switch表达式<br>334: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/334">JVM Constants API </a> JVM常量API<br>340: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/340">One AArch64 Port, Not Two</a> 只保留一个AArch64实现<br>341: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/341">Default CDS Archives</a> 默认类数据共享归档文件<br>344: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/344">Abortable Mixed Collections for G1</a> 可中止的G1 Mixed GC<br>346: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/346">Promptly Return Unused Committed Memory from G1</a> G1及时返回未使用的已分配内存</p>
</blockquote>
<h4 id="jdk-13"><a href="#jdk-13" class="headerlink" title="jdk 13"></a>jdk 13</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/13/">https://openjdk.java.net/projects/jdk/13/</a></p>
<blockquote>
<p>350: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/350">Dynamic CDS Archives</a> 动态CDS档案<br>351: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/351">ZGC: Uncommit Unused Memory</a> ZGC:取消使用未使用的内存<br>353: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/353">Reimplement the Legacy Socket API</a> 重新实现旧版套接字API<br>354: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/354">Switch Expressions (Preview)</a> switch表达式（预览）<br>355: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/355">Text Blocks (Preview)</a> 文本块（预览）</p>
</blockquote>
<h4 id="jdk-14"><a href="#jdk-14" class="headerlink" title="jdk 14"></a>jdk 14</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/14/">https://openjdk.java.net/projects/jdk/14/</a></p>
<blockquote>
<p>305: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/305">Pattern Matching for instanceof (Preview)</a> instanceof的模式匹配<br>343: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/343">Packaging Tool (Incubator)</a> 打包工具<br>345: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/345">NUMA-Aware Memory Allocation for G1</a> G1的NUMA-Aware内存分配<br>349: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/349">JFR Event Streaming</a> JFR事件流<br>352: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/352">Non-Volatile Mapped Byte Buffers</a> 非易失性映射字节缓冲区<br>358: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/358">Helpful NullPointerExceptions</a> 实用的NullPointerExceptions<br>359: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/359">Records (Preview)</a><br>361: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/361">Switch Expressions (Standard)</a> Switch表达式<br>362: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/362">Deprecate the Solaris and SPARC Ports</a> 弃用Solaris和SPARC端口<br>363: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/363">Remove the Concurrent Mark Sweep (CMS) Garbage Collector</a> 删除并发标记扫描（CMS）垃圾回收器<br>364: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/364">ZGC on macOS</a><br>365: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/365">ZGC on Windows</a><br>366: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/366">Deprecate the ParallelScavenge + SerialOld GC Combination</a> 弃用ParallelScavenge + SerialOld GC组合<br>367: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/367">Remove the Pack200 Tools and API</a> 删除Pack200工具和API<br>368: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/368">Text Blocks (Second Preview)</a> 文本块<br>370: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/370">Foreign-Memory Access API (Incubator)</a> 外部存储器访问API</p>
</blockquote>
<h4 id="jdk-15"><a href="#jdk-15" class="headerlink" title="jdk 15"></a>jdk 15</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/15/">https://openjdk.java.net/projects/jdk/15/</a></p>
<blockquote>
<p>339: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/339">Edwards-Curve Digital Signature Algorithm (EdDSA)</a> EdDSA 数字签名算法<br>360: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/360">Sealed Classes (Preview)</a> 密封类（预览）<br>371: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/371">Hidden Classes</a> 隐藏类<br>372: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/372">Remove the Nashorn JavaScript Engine</a> 移除 Nashorn JavaScript 引擎<br>373: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/373">Reimplement the Legacy DatagramSocket API</a> 重新实现 Legacy DatagramSocket API<br>374: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/374">Disable and Deprecate Biased Locking</a> 禁用偏向锁定<br>375: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/375">Pattern Matching for instanceof (Second Preview)</a> instanceof 模式匹配（第二次预览）<br>377: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/377">ZGC: A Scalable Low-Latency Garbage Collector</a> ZGC：一个可扩展的低延迟垃圾收集器<br>378: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/378">Text Blocks</a> 文本块<br>379: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/379">Shenandoah: A Low-Pause-Time Garbage Collector</a> Shenandoah:低暂停时间垃圾收集器<br>381: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/381">Remove the Solaris and SPARC Ports</a> 移除 Solaris 和 SPARC 端口<br>383: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/383">Foreign-Memory Access API (Second Incubator)</a> 外部存储器访问 API（第二次孵化版）<br>384: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/384">Records (Second Preview)</a> Records（第二次预览）<br>385: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/385">Deprecate RMI Activation for Removal</a> 废弃 RMI 激活机制</p>
</blockquote>
<h4 id="jdk-16"><a href="#jdk-16" class="headerlink" title="jdk 16"></a>jdk 16</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/16/">https://openjdk.java.net/projects/jdk/16/</a></p>
<blockquote>
<p>338: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/338">Vector API (Incubator)</a> Vector API（孵化器）<br>347: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/347">Enable C++14 Language Features</a> JDK C++的源码中允许使用C++14的语言特性<br>357: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/357">Migrate from Mercurial to Git</a> OpenJDK源码的版本控制从Mercurial (hg) 迁移到git<br>369: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/369">Migrate to GitHub</a> OpenJDK源码的版本控制迁移到github上<br>376: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/376">ZGC: Concurrent Thread-Stack Processing</a> ZGC：并发线程处理<br>380: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/380">Unix-Domain Socket Channels</a> Unix域套接字通道<br>386: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/386">Alpine Linux Port</a> 将glibc的jdk移植到使用musl的alpine linux上<br>387: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/387">Elastic Metaspace</a> 弹性元空间<br>388: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/388">Windows/AArch64 Port</a> 移植JDK到Windows/AArch64<br>389: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/389">Foreign Linker API (Incubator)</a> 提供jdk.incubator.foreign来简化native code的调用<br>390: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/390">Warnings for Value-Based Classes</a> 提供基于值的类的警告<br>392: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/392">Packaging Tool</a> jpackage打包工具转正<br>393: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/393">Foreign-Memory Access API (Third Incubator)</a><br>394: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/394">Pattern Matching for instanceof</a> Instanceof的模式匹配转正<br>395: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/395">Records</a> Records转正<br>396: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/396">Strongly Encapsulate JDK Internals by Default</a> 默认情况下，封装了JDK内部构件<br>397: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/397">Sealed Classes (Second Preview)</a> 密封类</p>
</blockquote>
<h4 id="jdk-17"><a href="#jdk-17" class="headerlink" title="jdk 17"></a>jdk 17</h4><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/17/">https://openjdk.java.net/projects/jdk/17/</a></p>
<blockquote>
<p>306: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/306">Restore Always-Strict Floating-Point Semantics</a> 恢复始终严格的浮点语义</p>
<p>356: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/356">Enhanced Pseudo-Random Number Generators</a> 增强型伪随机数生成器</p>
<p>382: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/382">New macOS Rendering Pipeline</a> 新的macOS渲染管道</p>
<p>391: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/391">macOS/AArch64 Port</a> macOS/AArch64端口</p>
<p>398: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/398">Deprecate the Applet API for Removal</a> 弃用Applet API后续将进行删除</p>
<p>403: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/403">Strongly Encapsulate JDK Internals</a> 强封装JDK的内部API</p>
<p>406: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/406">Pattern Matching for switch (Preview)</a> switch模式匹配（预览）</p>
<p>407: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/407">Remove RMI Activation</a> 删除RMI激活机制</p>
<p>409: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/409">Sealed Classes</a> 密封类转正</p>
<p>410: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/410">Remove the Experimental AOT and JIT Compiler</a> 删除实验性的AOT和JIT编译器</p>
<p>411: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/411">Deprecate the Security Manager for Removal</a> 弃用即将删除的安全管理器</p>
<p>412: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/412">Foreign Function &amp; Memory API (Incubator)</a> 外部函数和内存API（孵化特性）</p>
<p>414: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/414">Vector API (Second Incubator)</a> Vector API（第二次孵化特性）</p>
<p>415: <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/415">Context-Specific Deserialization Filters</a> 上下文特定的反序列化过滤器</p>
</blockquote>
<h3 id="1-5-JDK各版本下载链接"><a href="#1-5-JDK各版本下载链接" class="headerlink" title="1.5 JDK各版本下载链接"></a>1.5 JDK各版本下载链接</h3><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://www.oracle.com/java/technologies/downloads/archive/</span><br></pre></td></tr></table></figure>
<p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220525200441935.png" alt="image-20220525200441935" style="zoom:80%;"></p>
<blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/15QrBUOvfE9vjlTzN_EeVLg">https://pan.baidu.com/s/15QrBUOvfE9vjlTzN_EeVLg</a><br>提取码：yyds </p>
</blockquote>
<p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221213235332866.png" alt="image-20221213235332866"></p>
<h3 id="1-6-如何学习新特性"><a href="#1-6-如何学习新特性" class="headerlink" title="1.6 如何学习新特性"></a>1.6 如何学习新特性</h3><p>对于新特性，我们应该从哪几个角度学习新特性呢？</p>
<ul>
<li><p>语法层面：</p>
<ul>
<li>比如JDK5中的自动拆箱、自动装箱、enum、泛型</li>
<li>比如JDK8中的lambda表达式、接口中的默认方法、静态方法</li>
<li>比如JDK10中局部变量的类型推断</li>
<li>比如JDK12中的switch</li>
<li>比如JDK13中的文本块</li>
</ul>
</li>
<li><p>API层面：</p>
<ul>
<li>比如JDK8中的Stream、Optional、新的日期时间、HashMap的底层结构</li>
<li>比如JDK9中String的底层结构</li>
<li>新的 / 过时的 API</li>
</ul>
</li>
<li><p>底层优化</p>
<ul>
<li><p>比如JDK8中永久代被元空间替代、新的JS执行引擎</p>
</li>
<li><p>比如新的垃圾回收器、GC参数、JVM的优化</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-Java8新特性：Lambda表达式"><a href="#2-Java8新特性：Lambda表达式" class="headerlink" title="2. Java8新特性：Lambda表达式"></a>2. Java8新特性：Lambda表达式</h2><h3 id="2-1-关于Java8新特性简介"><a href="#2-1-关于Java8新特性简介" class="headerlink" title="2.1 关于Java8新特性简介"></a>2.1 关于Java8新特性简介</h3><p>Java 8 (又称为 JDK 8或JDK1.8) 是 Java 语言开发的一个主要版本。 Java 8 是oracle公司于2014年3月发布，可以看成是自Java 5 以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220525201653599.png" alt="image-20220525201653599" style="zoom:80%;"></p>
<ul>
<li><p>速度更快</p>
</li>
<li><p>代码更少(增加了新的语法：<strong>Lambda</strong> <strong>表达式</strong>)</p>
</li>
<li><p>强大的 <strong>Stream API</strong></p>
</li>
<li><p>便于并行</p>
<ul>
<li><strong>并行流</strong>就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</li>
<li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</li>
</ul>
</li>
<li><p>最大化减少空指针异常：Optional</p>
</li>
<li><p>Nashorn引擎，允许在JVM上运行JS应用</p>
<ul>
<li>发音“nass-horn”，是德国二战时一个坦克的命名</li>
<li>javascript运行在jvm已经不是新鲜事了，Rhino早在jdk6的时候已经存在。现在替代Rhino，官方的解释是Rhino相比其他JavaScript引擎（比如google的V8）实在太慢了，改造Rhino还不如重写。所以Nashorn的性能也是其一个亮点。</li>
<li>Nashorn 项目在 JDK 9 中得到改进；在JDK11 中<code>Deprecated</code>，后续JDK15版本中<code>remove</code>。在JDK11中取以代之的是GraalVM。（GraalVM是一个运行时平台，它支持Java和其他基于Java字节码的语言，但也支持其他语言，如JavaScript，Ruby，Python或LLVM。性能是Nashorn的2倍以上。）</li>
</ul>
</li>
</ul>
<h3 id="2-2-冗余的匿名内部类"><a href="#2-2-冗余的匿名内部类" class="headerlink" title="2.2 冗余的匿名内部类"></a>2.2 冗余的匿名内部类</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.fp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseFunctionalProgramming</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<p><strong>代码分析：</strong></p>
<p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<h3 id="2-3-好用的lambda表达式"><a href="#2-3-好用的lambda表达式" class="headerlink" title="2.3 好用的lambda表达式"></a>2.3 好用的lambda表达式</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/lambda表达式.jpg" alt="lambda表达式" style="zoom:67%;"></p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221111213355625.png" alt="image-20221111213355625"></p>
<h3 id="2-4-Lambda-及其使用举例"><a href="#2-4-Lambda-及其使用举例" class="headerlink" title="2.4 Lambda 及其使用举例"></a>2.4 Lambda 及其使用举例</h3><p>Lambda 是一个<strong>匿名函数</strong>，我们可以把 Lambda 表达式理解为是<strong>一段可以传递的代码</strong>（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<ul>
<li>从匿名类到 Lambda 的转换举例1</li>
</ul>
<p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220527101737072.png" alt="image-20220527101737072" style="zoom:67%;"></p>
<ul>
<li>从匿名类到 Lambda 的转换举例2</li>
</ul>
<p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220527101814203.png" alt="image-20220527101814203" style="zoom:80%;"></p>
<h3 id="2-5-语法"><a href="#2-5-语法" class="headerlink" title="2.5 语法"></a>2.5 语法</h3><p>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “<code>-&gt;</code>” ， 该操作符被称为 <code>Lambda 操作符</code>或<code>箭头操作符</code>。它将 Lambda 分为两个部分：</p>
<ul>
<li>左侧：指定了 Lambda 表达式需要的参数列表</li>
<li>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。</li>
</ul>
<p><strong>语法格式一：</strong>无参，无返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//未使用Lambda表达式</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我爱北京天安门&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    r1.run();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Lambda表达式</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我爱北京故宫&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    r2.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>语法格式二：</strong>Lambda 需要一个参数，但是没有返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//未使用Lambda表达式</span></span><br><span class="line">    Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    con.accept(<span class="string">&quot;谎言和誓言的区别是什么？&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Lambda表达式</span></span><br><span class="line">    Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>语法格式三：</strong>数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//语法格式三使用前</span></span><br><span class="line">    Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">    <span class="comment">//语法格式三使用后</span></span><br><span class="line">    Consumer&lt;String&gt; con2 = (s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    con2.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>语法格式四：</strong>Lambda 若只需要一个参数时，参数的小括号可以省略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//语法格式四使用前</span></span><br><span class="line">    Consumer&lt;String&gt; con1 = (s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">    <span class="comment">//语法格式四使用后</span></span><br><span class="line">    Consumer&lt;String&gt; con2 = s -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    con2.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>语法格式五：</strong>Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//语法格式五使用前</span></span><br><span class="line">    Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(o2);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(com1.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">    <span class="comment">//语法格式五使用后</span></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; &#123;</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(com2.compare(<span class="number">12</span>,<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>语法格式六：</strong>当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//语法格式六使用前</span></span><br><span class="line">    Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(com1.compare(<span class="number">12</span>,<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">    <span class="comment">//语法格式六使用后</span></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2);</span><br><span class="line"></span><br><span class="line">    System.out.println(com2.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//语法格式六使用前</span></span><br><span class="line">    Consumer&lt;String&gt; con1 = s -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;;</span><br><span class="line">    con1.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">    <span class="comment">//语法格式六使用后</span></span><br><span class="line">    Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s);</span><br><span class="line"></span><br><span class="line">    con2.accept(<span class="string">&quot;一个是听得人当真了，一个是说的人当真了&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-关于类型推断"><a href="#2-6-关于类型推断" class="headerlink" title="2.6 关于类型推断"></a>2.6 关于类型推断</h3><p>在语法格式三 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“<code>类型推断</code>”。</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220527103215741.png" alt="image-20220527103215741" style="zoom:67%;"></p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//类型推断1</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//类型推断2</span></span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Java8新特性：函数式-Functional-接口"><a href="#3-Java8新特性：函数式-Functional-接口" class="headerlink" title="3. Java8新特性：函数式(Functional)接口"></a>3. Java8新特性：函数式(Functional)接口</h2><h3 id="3-1-什么是函数式接口"><a href="#3-1-什么是函数式接口" class="headerlink" title="3.1 什么是函数式接口"></a>3.1 什么是函数式接口</h3><ul>
<li>只包含<code>一个抽象方法</code>（Single Abstract Method，简称SAM）的接口，称为函数式接口。当然该接口可以包含其他非抽象方法。</li>
<li>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</li>
<li>我们可以在一个接口上使用 <code>@FunctionalInterface</code> 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li>
<li>在<code>java.util.function</code>包下定义了Java 8 的丰富的函数式接口</li>
</ul>
<h3 id="3-2-如何理解函数式接口"><a href="#3-2-如何理解函数式接口" class="headerlink" title="3.2 如何理解函数式接口"></a>3.2 如何理解函数式接口</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/03-Overview.png" alt></p>
<ul>
<li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，即Java不但可以支持OOP还可以支持OOF（面向函数编程）<ul>
<li>Java8引入了Lambda表达式之后，Java也开始支持函数式编程。</li>
<li>Lambda表达式不是Java最早使用的。目前C++，C#，Python，Scala等均支持Lambda表达式。</li>
</ul>
</li>
<li>面向对象的思想：<ul>
<li>做一件事情，找一个能解决这个事情的对象，调用对象的方法，完成事情。</li>
</ul>
</li>
<li>函数式编程思想：<ul>
<li>只要能获取到结果，谁去做的，怎么做的都不重要，重视的是结果，不重视过程。</li>
</ul>
</li>
<li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。</li>
<li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li>
</ul>
<h3 id="3-3-举例"><a href="#3-3-举例" class="headerlink" title="3.3 举例"></a>3.3 举例</h3><p>举例1：</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220527111442115.png" alt="image-20220527111442115" style="zoom: 80%;"></p>
<p>举例2：</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220527111621424.png" alt="image-20220527111621424" style="zoom:80%;"></p>
<p>作为参数传递 Lambda 表达式：</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220527111751485.png" alt="image-20220527111751485" style="zoom:80%;"></p>
<blockquote>
<p>作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。</p>
</blockquote>
<h3 id="3-4-Java-内置函数式接口"><a href="#3-4-Java-内置函数式接口" class="headerlink" title="3.4 Java 内置函数式接口"></a>3.4 Java 内置函数式接口</h3><h4 id="3-4-1-之前的函数式接口"><a href="#3-4-1-之前的函数式接口" class="headerlink" title="3.4.1 之前的函数式接口"></a>3.4.1 之前的函数式接口</h4><p>之前学过的接口，有些就是函数式接口，比如：</p>
<ul>
<li>java.lang.Runnable<ul>
<li>public void run()</li>
</ul>
</li>
<li>java.lang.Iterable<T><ul>
<li>public Iterator<T> iterate()</T></li>
</ul>
</T></li>
<li>java.lang.Comparable<T><ul>
<li>public int compareTo(T t)</li>
</ul>
</T></li>
<li>java.util.Comparator<T><ul>
<li>public int compare(T t1, T t2)</li>
</ul>
</T></li>
</ul>
<h4 id="3-4-2-四大核心函数式接口"><a href="#3-4-2-四大核心函数式接口" class="headerlink" title="3.4.2 四大核心函数式接口"></a>3.4.2 四大核心函数式接口</h4><div class="table-container">
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>称谓</th>
<th>参数类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Consumer&lt;T&gt;</code></td>
<td>消费型接口</td>
<td>T</td>
<td>对类型为T的对象应用操作，包含方法：  <code>void accept(T t)</code></td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;</code></td>
<td>供给型接口</td>
<td>无</td>
<td>返回类型为T的对象，包含方法：<code>T get()</code></td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;</code></td>
<td>函数型接口</td>
<td>T</td>
<td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t)</code></td>
</tr>
<tr>
<td><code>Predicate&lt;T&gt;</code></td>
<td>判断型接口</td>
<td>T</td>
<td>确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：<code>boolean test(T t)</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-4-3-其它接口"><a href="#3-4-3-其它接口" class="headerlink" title="3.4.3 其它接口"></a>3.4.3 其它接口</h4><p><strong>类型1：消费型接口</strong></p>
<p>消费型接口的抽象方法特点：有形参，但是返回值类型是void</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BiConsumer<T,U></T,U></td>
<td>void accept(T t, U u)</td>
<td>接收两个对象用于完成功能</td>
</tr>
<tr>
<td>DoubleConsumer</td>
<td>void accept(double value)</td>
<td>接收一个double值</td>
</tr>
<tr>
<td>IntConsumer</td>
<td>void accept(int value)</td>
<td>接收一个int值</td>
</tr>
<tr>
<td>LongConsumer</td>
<td>void accept(long value)</td>
<td>接收一个long值</td>
</tr>
<tr>
<td>ObjDoubleConsumer<T></T></td>
<td>void accept(T t, double value)</td>
<td>接收一个对象和一个double值</td>
</tr>
<tr>
<td>ObjIntConsumer<T></T></td>
<td>void accept(T t, int value)</td>
<td>接收一个对象和一个int值</td>
</tr>
<tr>
<td>ObjLongConsumer<T></T></td>
<td>void accept(T t, long value)</td>
<td>接收一个对象和一个long值</td>
</tr>
</tbody>
</table>
</div>
<p><strong>类型2：供给型接口</strong></p>
<p>这类接口的抽象方法特点：无参，但是有返回值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BooleanSupplier</td>
<td>boolean getAsBoolean()</td>
<td>返回一个boolean值</td>
</tr>
<tr>
<td>DoubleSupplier</td>
<td>double getAsDouble()</td>
<td>返回一个double值</td>
</tr>
<tr>
<td>IntSupplier</td>
<td>int getAsInt()</td>
<td>返回一个int值</td>
</tr>
<tr>
<td>LongSupplier</td>
<td>long getAsLong()</td>
<td>返回一个long值</td>
</tr>
</tbody>
</table>
</div>
<p><strong>类型3：函数型接口</strong></p>
<p>这类接口的抽象方法特点：既有参数又有返回值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UnaryOperator<T></T></td>
<td>T apply(T t)</td>
<td>接收一个T类型对象，返回一个T类型对象结果</td>
</tr>
<tr>
<td>DoubleFunction<R></R></td>
<td>R apply(double value)</td>
<td>接收一个double值，返回一个R类型对象</td>
</tr>
<tr>
<td>IntFunction<R></R></td>
<td>R apply(int value)</td>
<td>接收一个int值，返回一个R类型对象</td>
</tr>
<tr>
<td>LongFunction<R></R></td>
<td>R apply(long value)</td>
<td>接收一个long值，返回一个R类型对象</td>
</tr>
<tr>
<td>ToDoubleFunction<T></T></td>
<td>double applyAsDouble(T value)</td>
<td>接收一个T类型对象，返回一个double</td>
</tr>
<tr>
<td>ToIntFunction<T></T></td>
<td>int applyAsInt(T value)</td>
<td>接收一个T类型对象，返回一个int</td>
</tr>
<tr>
<td>ToLongFunction<T></T></td>
<td>long applyAsLong(T value)</td>
<td>接收一个T类型对象，返回一个long</td>
</tr>
<tr>
<td>DoubleToIntFunction</td>
<td>int applyAsInt(double value)</td>
<td>接收一个double值，返回一个int结果</td>
</tr>
<tr>
<td>DoubleToLongFunction</td>
<td>long applyAsLong(double value)</td>
<td>接收一个double值，返回一个long结果</td>
</tr>
<tr>
<td>IntToDoubleFunction</td>
<td>double applyAsDouble(int value)</td>
<td>接收一个int值，返回一个double结果</td>
</tr>
<tr>
<td>IntToLongFunction</td>
<td>long applyAsLong(int value)</td>
<td>接收一个int值，返回一个long结果</td>
</tr>
<tr>
<td>LongToDoubleFunction</td>
<td>double applyAsDouble(long value)</td>
<td>接收一个long值，返回一个double结果</td>
</tr>
<tr>
<td>LongToIntFunction</td>
<td>int applyAsInt(long value)</td>
<td>接收一个long值，返回一个int结果</td>
</tr>
<tr>
<td>DoubleUnaryOperator</td>
<td>double applyAsDouble(double operand)</td>
<td>接收一个double值，返回一个double</td>
</tr>
<tr>
<td>IntUnaryOperator</td>
<td>int applyAsInt(int operand)</td>
<td>接收一个int值，返回一个int结果</td>
</tr>
<tr>
<td>LongUnaryOperator</td>
<td>long applyAsLong(long operand)</td>
<td>接收一个long值，返回一个long结果</td>
</tr>
<tr>
<td>BiFunction<T,U,R></T,U,R></td>
<td>R apply(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个R类型对象结果</td>
</tr>
<tr>
<td>BinaryOperator<T></T></td>
<td>T apply(T t, T u)</td>
<td>接收两个T类型对象，返回一个T类型对象结果</td>
</tr>
<tr>
<td>ToDoubleBiFunction<T,U></T,U></td>
<td>double applyAsDouble(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个double</td>
</tr>
<tr>
<td>ToIntBiFunction<T,U></T,U></td>
<td>int applyAsInt(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个int</td>
</tr>
<tr>
<td>ToLongBiFunction<T,U></T,U></td>
<td>long applyAsLong(T t, U u)</td>
<td>接收一个T类型和一个U类型对象，返回一个long</td>
</tr>
<tr>
<td>DoubleBinaryOperator</td>
<td>double applyAsDouble(double left, double right)</td>
<td>接收两个double值，返回一个double结果</td>
</tr>
<tr>
<td>IntBinaryOperator</td>
<td>int applyAsInt(int left, int right)</td>
<td>接收两个int值，返回一个int结果</td>
</tr>
<tr>
<td>LongBinaryOperator</td>
<td>long applyAsLong(long left, long right)</td>
<td>接收两个long值，返回一个long结果</td>
</tr>
</tbody>
</table>
</div>
<p><strong>类型4：判断型接口</strong></p>
<p>这类接口的抽象方法特点：有参，但是返回值类型是boolean结果。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BiPredicate<T,U></T,U></td>
<td>boolean test(T t, U u)</td>
<td>接收两个对象</td>
</tr>
<tr>
<td>DoublePredicate</td>
<td>boolean test(double value)</td>
<td>接收一个double值</td>
</tr>
<tr>
<td>IntPredicate</td>
<td>boolean test(int value)</td>
<td>接收一个int值</td>
</tr>
<tr>
<td>LongPredicate</td>
<td>boolean test(long value)</td>
<td>接收一个long值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-4-4-内置接口代码演示"><a href="#3-4-4-内置接口代码演示" class="headerlink" title="3.4.4 内置接口代码演示"></a>3.4.4 内置接口代码演示</h4><p>举例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.four;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="string">&quot;c++&quot;</span>,<span class="string">&quot;VB&quot;</span>,<span class="string">&quot;C#&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历Collection集合，并将传递给action参数的操作代码应用在每一个元素上。</span></span><br><span class="line">        list.forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.four;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSupplier</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.four;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPredicate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;删除之前：&quot;</span>);</span><br><span class="line">        list.forEach(t-&gt; System.out.println(t));</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//用于删除集合中满足filter指定的条件判断的。</span></span><br><span class="line">        <span class="comment">//删除包含o字母的元素</span></span><br><span class="line">        list.removeIf(s -&gt; s.contains(<span class="string">&quot;o&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;删除包含o字母的元素之后：&quot;</span>);</span><br><span class="line">        list.forEach(t-&gt; System.out.println(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例4：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.four;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFunction</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用Lambda表达式实现Function&lt;T,R&gt;接口，可以实现将一个字符串首字母转为大写的功能。</span></span><br><span class="line">        Function&lt;String,String&gt; fun = s -&gt; s.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + s.substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(fun.apply(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-4-5-练习"><a href="#3-4-5-练习" class="headerlink" title="3.4.5 练习"></a>3.4.5 练习</h4><p><strong>练习1：无参无返回值形式</strong></p>
<p>假如有自定义函数式接口Call如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Call</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试类中声明一个如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">callSomething</span><span class="params">(Call call)</span>&#123;</span><br><span class="line">		call.shout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试类的main方法中调用callSomething方法，并用Lambda表达式为形参call赋值，可以喊出任意你想说的话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		callSomething(()-&gt;System.out.println(<span class="string">&quot;回家吃饭&quot;</span>));</span><br><span class="line">		callSomething(()-&gt;System.out.println(<span class="string">&quot;我爱你&quot;</span>));</span><br><span class="line">		callSomething(()-&gt;System.out.println(<span class="string">&quot;滚蛋&quot;</span>));</span><br><span class="line">		callSomething(()-&gt;System.out.println(<span class="string">&quot;回来&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">callSomething</span><span class="params">(Call call)</span>&#123;</span><br><span class="line">		call.shout();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Call</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习2：消费型接口</strong></p>
<p>代码示例：Consumer<T>接口</T></p>
<p>在JDK1.8中Collection集合接口的父接口Iterable接口中增加了一个默认方法：</p>
<p><code>public default void forEach(Consumer&lt;? super T&gt; action)</code>遍历Collection集合的每个元素，执行“xxx消费型”操作。</p>
<p>在JDK1.8中Map集合接口中增加了一个默认方法：</p>
<p><code>public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>遍历Map集合的每对映射关系，执行“xxx消费型”操作。</p>
<p>案例：</p>
<p>（1）创建一个Collection系列的集合，添加一些字符串，调用forEach方法遍历查看</p>
<p>（2）创建一个Map系列的集合，添加一些(key,value)键值对，调用forEach方法遍历查看</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">	List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;lambda&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">	list.forEach(s -&gt; System.out.println(s));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">	HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	map.put(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	map.put(<span class="number">2</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">	map.put(<span class="number">3</span>, <span class="string">&quot;lambda&quot;</span>);</span><br><span class="line">	map.put(<span class="number">4</span>, <span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">	map.forEach((k,v) -&gt; System.out.println(k+<span class="string">&quot;-&gt;&quot;</span>+v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习3：供给型接口</strong></p>
<p>代码示例：Supplier<T>接口</T></p>
<p>在JDK1.8中增加了StreamAPI，java.util.stream.Stream<T>是一个数据流。这个类型有一个静态方法：</T></p>
<p><code>public static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code>可以创建Stream的对象。而又包含一个forEach方法可以遍历流中的元素：<code>public void forEach(Consumer&lt;? super T&gt; action)</code>。</p>
<p>案例：</p>
<p>现在请调用Stream的generate方法，来产生一个流对象，并调用Math.random()方法来产生数据，为Supplier函数式接口的形参赋值。最后调用forEach方法遍历流中的数据查看结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">	Stream.generate(() -&gt; Math.random()).forEach(num -&gt; System.out.println(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习4：功能型接口</strong></p>
<p>代码示例：Function<T,R>接口</T,R></p>
<p>在JDK1.8时Map接口增加了很多方法，例如：</p>
<p><code>public default void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>按照function指定的操作替换map中的value。</p>
<p><code>public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>遍历Map集合的每对映射关系，执行“xxx消费型”操作。</p>
<p>案例：</p>
<p>（1）声明一个Employee员工类型，包含编号、姓名、薪资。</p>
<p>（2）添加n个员工对象到一个HashMap<Integer,Employee>集合中，其中员工编号为key，员工对象为value。</Integer,Employee></p>
<p>（3）调用Map的forEach遍历集合</p>
<p>（4）调用Map的replaceAll方法，将其中薪资低于10000元的，薪资设置为10000。</p>
<p>（5）再次调用Map的forEach遍历集合查看结果</p>
<p>Employee类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Employee [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, salary=&quot;</span> + salary + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		HashMap&lt;Integer,Employee&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">e3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">e4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">4</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">11000</span>);</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">e5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">5</span>, <span class="string">&quot;钱七&quot;</span>, <span class="number">12000</span>);</span><br><span class="line">		</span><br><span class="line">		map.put(e1.getId(), e1);</span><br><span class="line">		map.put(e2.getId(), e2);</span><br><span class="line">		map.put(e3.getId(), e3);</span><br><span class="line">		map.put(e4.getId(), e4);</span><br><span class="line">		map.put(e5.getId(), e5);</span><br><span class="line">		</span><br><span class="line">		map.forEach((k,v) -&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		map.replaceAll((k,v)-&gt;&#123;</span><br><span class="line">			<span class="keyword">if</span>(v.getSalary()&lt;<span class="number">10000</span>)&#123;</span><br><span class="line">				v.setSalary(<span class="number">10000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> v;</span><br><span class="line">		&#125;);</span><br><span class="line">		map.forEach((k,v) -&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习5：判断型接口</strong></p>
<p>代码示例：Predicate<T>接口</T></p>
<p>JDK1.8时，Collecton<E>接口增加了一下方法，其中一个如下：</E></p>
<p><code>public default boolean removeIf(Predicate&lt;? super E&gt; filter)</code> 用于删除集合中满足filter指定的条件判断的。</p>
<p><code>public default void forEach(Consumer&lt;? super T&gt; action)</code>遍历Collection集合的每个元素，执行“xxx消费型”操作。</p>
<p>案例：</p>
<p>（1）添加一些字符串到一个Collection集合中</p>
<p>（2）调用forEach遍历集合</p>
<p>（3）调用removeIf方法，删除其中字符串的长度&lt;5的</p>
<p>（4）再次调用forEach遍历集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		list.forEach(str-&gt;System.out.println(str));</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		list.removeIf(str-&gt;str.length()&lt;<span class="number">5</span>);</span><br><span class="line">		list.forEach(str-&gt;System.out.println(str));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习6：判断型接口</strong></p>
<p>案例：</p>
<p>（1）声明一个Employee员工类型，包含编号、姓名、性别，年龄，薪资。</p>
<p>（2）声明一个EmployeeSerice员工管理类，包含一个ArrayList<Employee>集合的属性all，在EmployeeSerice的构造器中，创建一些员工对象，为all集合初始化。</Employee></p>
<p>（3）在EmployeeSerice员工管理类中，声明一个方法：ArrayList<Employee> get(Predicate<Employee> p)，即将满足p指定的条件的员工，添加到一个新的ArrayList<Employee> 集合中返回。</Employee></Employee></Employee></p>
<p>（4）在测试类中创建EmployeeSerice员工管理类的对象，并调用get方法，分别获取：</p>
<ul>
<li>所有员工对象</li>
<li>所有年龄超过35的员工</li>
<li>所有薪资高于15000的女员工</li>
<li>所有编号是偶数的员工</li>
<li>名字是“张三”的员工</li>
<li>年龄超过25，薪资低于10000的男员工</li>
</ul>
<p>示例代码：</p>
<p>Employee类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">char</span> gender;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">char</span> gender, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.gender = gender;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Employee [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, gender=&quot;</span> + gender + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, salary=&quot;</span> + salary</span><br><span class="line">				+ <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>员工管理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeService</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Employee&gt; all;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">EmployeeService</span><span class="params">()</span>&#123;</span><br><span class="line">		all = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">		all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">33</span>, <span class="number">8000</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">2</span>, <span class="string">&quot;翠花&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">23</span>, <span class="number">18000</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">3</span>, <span class="string">&quot;无能&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">46</span>, <span class="number">8000</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">4</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">23</span>, <span class="number">9000</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">5</span>, <span class="string">&quot;老王&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">23</span>, <span class="number">15000</span>));</span><br><span class="line">		all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">6</span>, <span class="string">&quot;大嘴&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">23</span>, <span class="number">11000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Employee&gt; <span class="title function_">get</span><span class="params">(Predicate&lt;Employee&gt; p)</span>&#123;</span><br><span class="line">		ArrayList&lt;Employee&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Employee emp : result) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p.test(emp))&#123;</span><br><span class="line">				result.add(emp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">EmployeeService</span> <span class="variable">es</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeService</span>();</span><br><span class="line">		</span><br><span class="line">		es.get(e -&gt; <span class="literal">true</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">		System.out.println();</span><br><span class="line">		es.get(e -&gt; e.getAge()&gt;<span class="number">35</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">		System.out.println();</span><br><span class="line">		es.get(e -&gt; e.getSalary()&gt;<span class="number">15000</span> &amp;&amp; e.getGender()==<span class="string">&#x27;女&#x27;</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">		System.out.println();</span><br><span class="line">		es.get(e -&gt; e.getId()%<span class="number">2</span>==<span class="number">0</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">		System.out.println();</span><br><span class="line">		es.get(e -&gt; <span class="string">&quot;张三&quot;</span>.equals(e.getName())).forEach(e-&gt;System.out.println(e));</span><br><span class="line">		System.out.println();</span><br><span class="line">		es.get(e -&gt; e.getAge()&gt;<span class="number">25</span> &amp;&amp; e.getSalary()&lt;<span class="number">10000</span> &amp;&amp; e.getGender()==<span class="string">&#x27;男&#x27;</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-Java8新特性：方法引用与构造器引用"><a href="#4-Java8新特性：方法引用与构造器引用" class="headerlink" title="4. Java8新特性：方法引用与构造器引用"></a>4. Java8新特性：方法引用与构造器引用</h2><p>Lambda表达式是可以简化函数式接口的变量或形参赋值的语法。而方法引用和构造器引用是为了简化Lambda表达式的。</p>
<h3 id="4-1-方法引用"><a href="#4-1-方法引用" class="headerlink" title="4.1 方法引用"></a>4.1 方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>
<p>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p>
<blockquote>
<p>语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法<code>对语言的功能并没有影响，但是更方便程序员使用</code>。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>
</blockquote>
<h4 id="4-1-1-方法引用格式"><a href="#4-1-1-方法引用格式" class="headerlink" title="4.1.1 方法引用格式"></a>4.1.1 方法引用格式</h4><ul>
<li><p>格式：使用方法引用操作符 “<code>::</code>” 将类(或对象) 与 方法名分隔开来。</p>
<ul>
<li>两个:中间不能有空格，而且必须英文状态下半角输入</li>
</ul>
</li>
<li><p>如下三种主要使用情况：</p>
<ul>
<li>情况1：<code>对象 :: 实例方法名</code></li>
<li>情况2：<code>类 :: 静态方法名</code></li>
<li>情况3：<code>类 :: 实例方法名</code></li>
</ul>
</li>
</ul>
<h4 id="4-1-2-方法引用使用前提"><a href="#4-1-2-方法引用使用前提" class="headerlink" title="4.1.2 方法引用使用前提"></a>4.1.2 方法引用使用前提</h4><p><strong>要求1：</strong>Lambda体只有一句语句，并且是通过调用一个对象的/类现有的方法来完成的</p>
<p>例如：System.out对象，调用println()方法来完成Lambda体</p>
<p>​           Math类，调用random()静态方法来完成Lambda体</p>
<p><strong>要求2：</strong></p>
<p>针对情况1：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。</p>
<p>针对情况2：函数式接口中的抽象方法a在被重写时使用了某一个类的静态方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。</p>
<p>针对情况3：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的返回值类型与方法b的返回值类型相同，同时方法a的形参列表中有n个参数，方法b的形参列表有n-1个参数，且方法a的第1个参数作为方法b的调用者，且方法a的后n-1参数与方法b的n-1参数匹配（类型相同或满足多态场景也可以）</p>
<p>例如：t-&gt;System.out.println(t)</p>
<p>​        () -&gt; Math.random() 都是无参</p>
<h4 id="4-1-3-举例"><a href="#4-1-3-举例" class="headerlink" title="4.1.3 举例"></a>4.1.3 举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodRefTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 情况一：对象 :: 实例方法</span></span><br><span class="line">	<span class="comment">//Consumer中的void accept(T t)</span></span><br><span class="line">	<span class="comment">//PrintStream中的void println(T t)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">		Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">		con1.accept(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">		<span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> System.out;</span><br><span class="line">		Consumer&lt;String&gt; con2 = ps::println;</span><br><span class="line">		con2.accept(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Supplier中的T get()</span></span><br><span class="line">	<span class="comment">//Employee中的String getName()</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>,<span class="number">5600</span>);</span><br><span class="line"></span><br><span class="line">		Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class="line">		System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">		Supplier&lt;String&gt; sup2 = emp::getName;</span><br><span class="line">		System.out.println(sup2.get());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 情况二：类 :: 静态方法</span></span><br><span class="line">	<span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line">	<span class="comment">//Integer中的int compare(T t1,T t2)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">		Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class="line">		System.out.println(com1.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">		System.out.println(com2.compare(<span class="number">12</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">	<span class="comment">//Math中的Long round(Double d)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">		Function&lt;Double,Long&gt; func = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double d)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> Math.round(d);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">		System.out.println(func1.apply(<span class="number">12.3</span>));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Function&lt;Double,Long&gt; func2 = Math::round;</span><br><span class="line">		System.out.println(func2.apply(<span class="number">12.6</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 情况三：类 :: 实例方法  (有难度)</span></span><br><span class="line">	<span class="comment">// Comparator中的int comapre(T t1,T t2)</span></span><br><span class="line">	<span class="comment">// String中的int t1.compareTo(t2)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">		Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);</span><br><span class="line">		System.out.println(com1.compare(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class="line">		System.out.println(com2.compare(<span class="string">&quot;abd&quot;</span>,<span class="string">&quot;abm&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line">	<span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">		BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);</span><br><span class="line">		System.out.println(pre1.test(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">		BiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class="line">		System.out.println(pre2.test(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abd&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Function中的R apply(T t)</span></span><br><span class="line">	<span class="comment">// Employee中的String getName();</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="number">23</span>, <span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();</span><br><span class="line">		System.out.println(func1.apply(employee));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">		Function&lt;Employee,String&gt; func2 = Employee::getName;</span><br><span class="line">		System.out.println(func2.apply(employee));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-构造器引用"><a href="#4-2-构造器引用" class="headerlink" title="4.2 构造器引用"></a>4.2 构造器引用</h3><p>当Lambda表达式是创建一个对象，并且满足Lambda表达式形参，正好是给创建这个对象的构造器的实参列表，就可以使用构造器引用。</p>
<p>格式：<code>类名::new</code></p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorRefTest</span> &#123;</span><br><span class="line">	<span class="comment">//构造器引用</span></span><br><span class="line">    <span class="comment">//Supplier中的T get()</span></span><br><span class="line">    <span class="comment">//Employee的空参构造器：Employee()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Employee&gt;  sup1 = () -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Employee&gt;  sup2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">        System.out.println(sup2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> func1.apply(<span class="number">1001</span>);</span><br><span class="line">        System.out.println(employee);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Integer,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee1</span> <span class="operator">=</span> func2.apply(<span class="number">1002</span>);</span><br><span class="line">        System.out.println(employee1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//BiFunction中的R apply(T t,U u)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id,name);</span><br><span class="line">        System.out.println(func1.apply(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">        System.out.println(func2.apply(<span class="number">1002</span>,<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康 邮箱：shkstart@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> salary;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Employee().....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		System.out.println(<span class="string">&quot;Employee(int id).....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Employee&#123;&quot;</span> + <span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, salary=&quot;</span> + salary + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-3-数组构造引用"><a href="#4-3-数组构造引用" class="headerlink" title="4.3 数组构造引用"></a>4.3 数组构造引用</h3><p>当Lambda表达式是创建一个数组对象，并且满足Lambda表达式形参，正好是给创建这个数组对象的长度，就可以数组构造引用。</p>
<p>格式：<code>数组类型名::new</code></p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组引用</span></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">    String[] arr1 = func1.apply(<span class="number">5</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Integer,String[]&gt; func2 = String[] :: <span class="keyword">new</span>;</span><br><span class="line">    String[] arr2 = func2.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-Java8新特性：强大的Stream-API"><a href="#5-Java8新特性：强大的Stream-API" class="headerlink" title="5. Java8新特性：强大的Stream API"></a>5. Java8新特性：强大的Stream API</h2><h3 id="5-1-说明"><a href="#5-1-说明" class="headerlink" title="5.1 说明"></a>5.1 说明</h3><ul>
<li>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。</li>
<li>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库<code>最好的补充</code>，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li>
<li>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 <strong>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。</strong>也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</li>
</ul>
<h3 id="5-2-为什么要使用Stream-API"><a href="#5-2-为什么要使用Stream-API" class="headerlink" title="5.2 为什么要使用Stream API"></a>5.2 为什么要使用Stream API</h3><p>实际开发中，项目中多数数据源都来自于MySQL、Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。</p>
<h3 id="5-3-什么是Stream"><a href="#5-3-什么是Stream" class="headerlink" title="5.3 什么是Stream"></a>5.3 什么是Stream</h3><p>Stream 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>
<p>Stream 和 Collection 集合的区别：<strong>Collection 是一种静态的内存数据结构，讲的是数据，而 Stream 是有关计算的，讲的是计算。</strong>前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>
<p>注意：</p>
<p>①Stream 自己不会存储元素。</p>
<p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p>
<p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。</p>
<p>④ Stream一旦执行了终止操作，就不能再调用其它中间操作或终止操作了。</p>
<h3 id="5-4-Stream的操作三个步骤"><a href="#5-4-Stream的操作三个步骤" class="headerlink" title="5.4 Stream的操作三个步骤"></a>5.4 Stream的操作三个步骤</h3><p><strong>1- 创建 Stream</strong><br>一个数据源（如：集合、数组），获取一个流</p>
<p><strong>2- 中间操作</strong><br>每次处理都会返回一个持有结果的新Stream，即中间操作的方法返回值仍然是Stream类型的对象。因此中间操作可以是个<code>操作链</code>，可对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。</p>
<p><strong>3- 终止操作(终端操作)</strong><br>终止操作的方法返回值类型就不再是Stream了，因此一旦执行终止操作，就结束整个Stream操作了。一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。</p>
<p><img src="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220514180803311.png" alt="image-20220514180803311" style="zoom: 50%;"></p>
<h4 id="5-4-1-创建Stream实例"><a href="#5-4-1-创建Stream实例" class="headerlink" title="5.4.1 创建Stream实例"></a>5.4.1 创建Stream实例</h4><p><strong>方式一：通过集合</strong></p>
<p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p>
<ul>
<li><p>default Stream<E> stream() : 返回一个顺序流</E></p>
</li>
<li><p>default Stream<E> parallelStream() : 返回一个并行流</E></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JDK1.8中，Collection系列集合增加了方法</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方式二：通过数组</strong></p>
<p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p>
<ul>
<li>static <T> Stream<T> stream(T[] array): 返回一个流</T></T></li>
<li>public static IntStream stream(int[] array)</li>
<li>public static LongStream stream(long[] array)</li>
<li>public static DoubleStream stream(double[] array)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">    Stream&lt;String&gt; stream = Arrays.stream(arr); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方式三：通过Stream的of()</strong></p>
<p>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</p>
<ul>
<li>public static<T> Stream<T> of(T… values) : 返回一个流</T></T></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方式四：创建无限流(了解)</strong></p>
<p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p>
<ul>
<li><p>迭代<br>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) </T></T></T></p>
</li>
<li><p>生成<br>public static<T> Stream<T> generate(Supplier<T> s) </T></T></T></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式四：创建无限流</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 迭代</span></span><br><span class="line">	<span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final</span></span><br><span class="line">	<span class="comment">// UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">	Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, x -&gt; x + <span class="number">2</span>);</span><br><span class="line">	stream.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成</span></span><br><span class="line">	<span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">	Stream&lt;Double&gt; stream1 = Stream.generate(Math::random);</span><br><span class="line">	stream1.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-4-2-一系列中间操作"><a href="#5-4-2-一系列中间操作" class="headerlink" title="5.4.2 一系列中间操作"></a>5.4.2 一系列中间操作</h4><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p>
<p>1-筛选与切片</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方   法</strong></th>
<th><strong>描   述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>filter(Predicatep)</strong></td>
<td>接收  Lambda ， 从流中排除某些元素</td>
</tr>
<tr>
<td><strong>distinct()</strong></td>
<td>筛选，通过流所生成元素的  hashCode() 和 equals() 去除重复元素</td>
</tr>
<tr>
<td><strong>limit(long maxSize)</strong></td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td><strong>skip(long n)</strong></td>
<td>跳过元素，返回一个扔掉了前  n 个元素的流。<br>若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td>
</tr>
</tbody>
</table>
</div>
<p>2-映 射</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>map(Function f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td><strong>mapToDouble(ToDoubleFunction f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td><strong>mapToInt(ToIntFunction  f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的  IntStream。</td>
</tr>
<tr>
<td><strong>mapToLong(ToLongFunction  f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的  LongStream。</td>
</tr>
<tr>
<td><strong>flatMap(Function  f)</strong></td>
<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>
</tr>
</tbody>
</table>
</div>
<p>3-排序</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>sorted()</strong></td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td><strong>sorted(Comparator</strong> <strong>com)</strong></td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody>
</table>
</div>
<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamMiddleOperate</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、创建Stream</span></span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、加工处理</span></span><br><span class="line">        <span class="comment">//过滤：filter(Predicate p)</span></span><br><span class="line">        <span class="comment">//把里面的偶数拿出来</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * filter(Predicate p)</span></span><br><span class="line"><span class="comment">         * Predicate是函数式接口，抽象方法：boolean test(T t)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        stream = stream.filter(t -&gt; t%<span class="number">2</span>==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、终结操作：例如：遍历</span></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">                .filter(t -&gt; t%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .limit(<span class="number">3</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">                .distinct()  <span class="comment">//(1,2,3,4,5,6,7)</span></span><br><span class="line">                .filter(t -&gt; t%<span class="number">2</span>!=<span class="number">0</span>) <span class="comment">//(1,3,5,7)</span></span><br><span class="line">                .limit(<span class="number">3</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .skip(<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .skip(<span class="number">5</span>)</span><br><span class="line">                .distinct()</span><br><span class="line">                .filter(t -&gt; t%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .distinct()</span><br><span class="line">                .peek(System.out::println)  <span class="comment">//Consumer接口的抽象方法  void accept(T t)</span></span><br><span class="line">                .count();</span><br><span class="line">        System.out.println(<span class="string">&quot;count=&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//希望能够找出前三个最大值，前三名最大的，不重复</span></span><br><span class="line">        Stream.of(<span class="number">11</span>,<span class="number">2</span>,<span class="number">39</span>,<span class="number">4</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">22</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">54</span>,<span class="number">54</span>)</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted((t1,t2) -&gt; -Integer.compare(t1, t2))<span class="comment">//Comparator接口  int compare(T t1, T t2)</span></span><br><span class="line">                .limit(<span class="number">3</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .map(t -&gt; t+=<span class="number">1</span>)<span class="comment">//Function&lt;T,R&gt;接口抽象方法 R apply(T t)</span></span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;java&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.stream(arr)</span><br><span class="line">                .map(t-&gt;t.toUpperCase())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;java&quot;</span>&#125;;</span><br><span class="line">        Arrays.stream(arr)</span><br><span class="line">                .flatMap(t -&gt; Stream.of(t.split(<span class="string">&quot;|&quot;</span>)))<span class="comment">//Function&lt;T,R&gt;接口抽象方法 R apply(T t)  现在的R是一个Stream</span></span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-4-3-终止操作"><a href="#5-4-3-终止操作" class="headerlink" title="5.4.3 终止操作"></a>5.4.3 终止操作</h4><ul>
<li><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</p>
</li>
<li><p>流进行了终止操作后，不能再次使用。</p>
</li>
</ul>
<p>1-匹配与查找</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>allMatch(Predicate  p)</strong></td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td><strong>anyMatch(Predicate  p)  </strong></td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td><strong>noneMatch(Predicate</strong>  <strong>p)</strong></td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td><strong>findFirst()</strong></td>
<td>返回第一个元素</td>
</tr>
<tr>
<td><strong>findAny()</strong></td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td><strong>count()</strong></td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td><strong>max(Comparator c)</strong></td>
<td>返回流中最大值</td>
</tr>
<tr>
<td><strong>min(Comparator c)</strong></td>
<td>返回流中最小值</td>
</tr>
<tr>
<td><strong>forEach(Consumer c)</strong></td>
<td>内部迭代(使用  Collection  接口需要用户去做迭代，称为外部迭代。<br>相反，Stream  API 使用内部迭代——它帮你把迭代做了)</td>
</tr>
</tbody>
</table>
</div>
<p>2-归约</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>reduce(T  identity, BinaryOperator b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回  T</td>
</tr>
<tr>
<td><strong>reduce(BinaryOperator  b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回 Optional<T></T></td>
</tr>
</tbody>
</table>
</div>
<p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p>
<p>3-收集</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方   法</strong></th>
<th><strong>描   述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>collect(Collector  c)</strong></td>
<td>将流转换为其他形式。接收一个  Collector接口的实现，<br>用于给Stream中元素做汇总的方法</td>
</tr>
</tbody>
</table>
</div>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。</p>
<p>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>toList</strong></td>
<td>Collector<T, ?, list<t>&gt;</T,></td>
<td>把流中元素收集到List</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>toSet</strong></td>
<td>Collector<T, ?, set<t>&gt;</T,></td>
<td>把流中元素收集到Set</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>toCollection</strong></td>
<td>Collector<T, ?, c></T,></td>
<td>把流中元素收集到创建的集合</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>counting</strong></td>
<td>Collector<T, ?, long></T,></td>
<td>计算流中元素的个数</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().collect(Collectors.counting());</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>summingInt</strong></td>
<td>Collector<T, ?, integer></T,></td>
<td>对流中元素的整数属性求和</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> total=list.stream().collect(Collectors.summingInt(Employee::getSalary));</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>averagingInt</strong></td>
<td>Collector<T, ?, double></T,></td>
<td>计算流中元素Integer属性的平均值</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> list.stream().collect(Collectors.averagingInt(Employee::getSalary));</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>summarizingInt</strong></td>
<td>Collector<T, ?, intsummarystatistics></T,></td>
<td>收集流中Integer属性的统计值。如：平均值</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>joining</strong></td>
<td>Collector<CharSequence, ?, string></CharSequence,></td>
<td>连接流中每个字符串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str= list.stream().map(Employee::getName).collect(Collectors.joining());</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>maxBy</strong></td>
<td>Collector<T, ?, optional<t>&gt;</T,></td>
<td>根据比较器选择最大值</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Emp&gt;max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>minBy</strong></td>
<td>Collector<T, ?, optional<t>&gt;</T,></td>
<td>根据比较器选择最小值</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>reducing</strong></td>
<td>Collector<T, ?, optional<t>&gt;</T,></td>
<td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> total=list.stream().collect(Collectors.reducing(<span class="number">0</span>, Employee::getSalar, Integer::sum));</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>collectingAndThen</strong></td>
<td>Collector<T,A,RR></T,A,RR></td>
<td>包裹另一个收集器，对其结果转换函数</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>groupingBy</strong></td>
<td>Collector<T, ?, map<k, list<t>&gt;&gt;</T,></td>
<td>根据某属性值对流分组，属性为K，结果为V</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>partitioningBy</strong></td>
<td>Collector<T, ?, map<boolean, list<t>&gt;&gt;</T,></td>
<td>根据true或false进行分区</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean,List&lt;Emp&gt;&gt; vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage));</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamEndding</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">                .count();</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">                .allMatch(t -&gt; t%<span class="number">2</span>!=<span class="number">0</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">                .anyMatch(t -&gt; t%<span class="number">2</span>==<span class="number">0</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">        Optional&lt;Integer&gt; opt = Stream.of(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>).findFirst();</span><br><span class="line">        System.out.println(opt);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line">        Optional&lt;Integer&gt; opt = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">                .filter(t -&gt; t%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">                .findFirst();</span><br><span class="line">        System.out.println(opt);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">        Optional&lt;Integer&gt; opt = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">                .filter(t -&gt; t%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">                .findFirst();</span><br><span class="line">        System.out.println(opt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line">        Optional&lt;Integer&gt; max = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">                .max((t1,t2) -&gt; Integer.compare(t1, t2));</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">                .reduce(<span class="number">0</span>, (t1,t2) -&gt; t1+t2);<span class="comment">//BinaryOperator接口   T apply(T t1, T t2)</span></span><br><span class="line">        System.out.println(reduce);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">        Optional&lt;Integer&gt; max = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">                .reduce((t1,t2) -&gt; t1&gt;t2?t1:t2);<span class="comment">//BinaryOperator接口   T apply(T t1, T t2)</span></span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">                .filter(t -&gt; t%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-Java9新增API"><a href="#5-5-Java9新增API" class="headerlink" title="5.5 Java9新增API"></a>5.5 Java9新增API</h3><p><strong>新增1：Stream实例化方法</strong></p>
<p>ofNullable()的使用：</p>
<p>Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//报NullPointerException</span></span><br><span class="line"><span class="comment">//Stream&lt;Object&gt; stream1 = Stream.of(null);</span></span><br><span class="line"><span class="comment">//System.out.println(stream1.count());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不报异常，允许通过</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">System.out.println(stringStream.count());<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不报异常，允许通过</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">list.add(<span class="literal">null</span>);</span><br><span class="line">System.out.println(list.stream().count());<span class="comment">//2</span></span><br><span class="line"><span class="comment">//ofNullable()：允许值为null</span></span><br><span class="line">Stream&lt;Object&gt; stream1 = Stream.ofNullable(<span class="literal">null</span>);</span><br><span class="line">System.out.println(stream1.count());<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream = Stream.ofNullable(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">System.out.println(stream.count());<span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>iterator()重载的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原来的控制终止方式：</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>,i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在的终止方式：</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>,i -&gt; i &lt; <span class="number">100</span>,i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-6-练习"><a href="#5-6-练习" class="headerlink" title="5.6 练习"></a>5.6 练习</h3><p>现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以<br>下若干操作步骤：</p>
<ol>
<li>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</li>
<li>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</li>
<li>第二个队伍只要姓张的成员姓名；存储到一个新集合中。</li>
<li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li>
<li>将两个队伍合并为一个队伍；存储到一个新集合中。</li>
<li>根据姓名创建 Person 对象；存储到一个新集合中。</li>
<li>打印整个队伍的Person对象信息。</li>
</ol>
<p>Person 类的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个队伍（集合）的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//第一支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;宋远桥&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;苏星河&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;石中玉&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;老子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;庄子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;洪七公&quot;</span>);</span><br><span class="line">        <span class="comment">//第二支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">&quot;古力娜扎&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;赵丽颖&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;尼古拉斯赵四&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张天爱&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张二狗&quot;</span>);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// ....编写代码完成题目要求 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>参考答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//第一支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;宋远桥&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;苏星河&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;石中玉&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;老子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;庄子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;洪七公&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//第二支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">&quot;古力娜扎&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;赵丽颖&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;尼古拉斯赵四&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张天爱&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张二狗&quot;</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 第一个队伍只要名字为3个字的成员姓名；</span></span><br><span class="line">        <span class="comment">// 第一个队伍筛选之后只要前3个人；</span></span><br><span class="line">        Stream&lt;String&gt; streamOne = one.stream().filter(s ‐&gt; s.length() == <span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 第二个队伍只要姓张的成员姓名；</span></span><br><span class="line">        <span class="comment">// 第二个队伍筛选之后不要前2个人；</span></span><br><span class="line">        Stream&lt;String&gt; streamTwo = two.stream().filter(s ‐&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).skip(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 将两个队伍合并为一个队伍；</span></span><br><span class="line">        <span class="comment">// 根据姓名创建Person对象；</span></span><br><span class="line">        <span class="comment">// 打印整个队伍的Person对象信息。</span></span><br><span class="line">        Stream.concat(streamOne, streamTwo).map(Person::<span class="keyword">new</span>).forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post-share"><div class="social-share" data-image="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2023/02/18/java2023/%E7%AC%AC17%E7%AB%A0_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" title="第17章_反射机制"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第17章_反射机制</div></div></a><a class="next-post pull-right" href="/2023/02/18/java2023/%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8B%EF%BC%89/" title="第18章_JDK8-17新特性（下）"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第18章_JDK8-17新特性（下）</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" title="第01章_Java语言概述"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="title">第01章_Java语言概述</div></div></a><a href="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/" title="第02章_变量与运算符"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="title">第02章_变量与运算符</div></div></a><a href="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/" title="第04章_IDEA的安装与使用（上）"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="title">第04章_IDEA的安装与使用（上）</div></div></a><a href="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/" title="第03章_流程控制语句"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="title">第03章_流程控制语句</div></div></a><a href="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/" title="第04章_IDEA的安装与使用（下）"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="title">第04章_IDEA的安装与使用（下）</div></div></a><a href="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/" title="第05章_数组"><img class="cover" src="https://img0.baidu.com/it/u=2434210581,3590463476&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="title">第05章_数组</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">YZ</div><div class="author-info-description">YZ的博客,欢迎访问</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yangzhengyz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yangzhengyz" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2863057582yz@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/2863057582yz@gmail.com" target="_blank" title="twitter"><i class="fa-brands fa-twitter"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to  my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">第18章_JDK8-17新特性（上）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E4%B8%93%E9%A2%98%E4%B8%8E%E8%84%89%E7%BB%9C"><span class="toc-text">本章专题与脉络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%E6%A6%82%E8%BF%B0"><span class="toc-text">1. Java版本迭代概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8F%91%E5%B8%83%E7%89%B9%E7%82%B9%EF%BC%88%E5%B0%8F%E6%AD%A5%E5%BF%AB%E8%B7%91%EF%BC%8C%E5%BF%AB%E9%80%9F%E8%BF%AD%E4%BB%A3%EF%BC%89"><span class="toc-text">1.1 发布特点（小步快跑，快速迭代）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-text">1.2 名词解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%EF%BC%9AOracle-JDK%E5%92%8COpen-JDK"><span class="toc-text">名词解释：Oracle JDK和Open JDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%EF%BC%9AJEP"><span class="toc-text">名词解释：JEP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%EF%BC%9ALTS"><span class="toc-text">名词解释：LTS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%90%84%E7%89%88%E6%9C%AC%E6%94%AF%E6%8C%81%E6%97%B6%E9%97%B4%E8%B7%AF%E7%BA%BF%E5%9B%BE"><span class="toc-text">1.3 各版本支持时间路线图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%90%84%E7%89%88%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.4 各版本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-9"><span class="toc-text">jdk 9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-10"><span class="toc-text">jdk 10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-11"><span class="toc-text">jdk 11</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-12"><span class="toc-text">jdk 12</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-13"><span class="toc-text">jdk 13</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-14"><span class="toc-text">jdk 14</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-15"><span class="toc-text">jdk 15</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-16"><span class="toc-text">jdk 16</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-17"><span class="toc-text">jdk 17</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-JDK%E5%90%84%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5"><span class="toc-text">1.5 JDK各版本下载链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">1.6 如何学习新特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2. Java8新特性：Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%85%B3%E4%BA%8EJava8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B"><span class="toc-text">2.1 关于Java8新特性简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%86%97%E4%BD%99%E7%9A%84%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">2.2 冗余的匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%A5%BD%E7%94%A8%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.3 好用的lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Lambda-%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-text">2.4 Lambda 及其使用举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%AF%AD%E6%B3%95"><span class="toc-text">2.5 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%85%B3%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-text">2.6 关于类型推断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F-Functional-%E6%8E%A5%E5%8F%A3"><span class="toc-text">3. Java8新特性：函数式(Functional)接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.1 什么是函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.2 如何理解函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%B8%BE%E4%BE%8B"><span class="toc-text">3.3 举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Java-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.4 Java 内置函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E4%B9%8B%E5%89%8D%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.4.1 之前的函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.4.2 四大核心函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E5%85%B6%E5%AE%83%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.4.3 其它接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-%E5%86%85%E7%BD%AE%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-text">3.4.4 内置接口代码演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5-%E7%BB%83%E4%B9%A0"><span class="toc-text">3.4.5 练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-text">4. Java8新特性：方法引用与构造器引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">4.1 方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E6%A0%BC%E5%BC%8F"><span class="toc-text">4.1.1 方法引用格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8%E5%89%8D%E6%8F%90"><span class="toc-text">4.1.2 方法引用使用前提</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E4%B8%BE%E4%BE%8B"><span class="toc-text">4.1.3 举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-text">4.2 构造器引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E5%BC%95%E7%94%A8"><span class="toc-text">4.3 数组构造引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%BC%BA%E5%A4%A7%E7%9A%84Stream-API"><span class="toc-text">5. Java8新特性：强大的Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%AF%B4%E6%98%8E"><span class="toc-text">5.1 说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Stream-API"><span class="toc-text">5.2 为什么要使用Stream API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E4%BB%80%E4%B9%88%E6%98%AFStream"><span class="toc-text">5.3 什么是Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Stream%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-text">5.4 Stream的操作三个步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E5%88%9B%E5%BB%BAStream%E5%AE%9E%E4%BE%8B"><span class="toc-text">5.4.1 创建Stream实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-%E4%B8%80%E7%B3%BB%E5%88%97%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-text">5.4.2 一系列中间操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="toc-text">5.4.3 终止操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Java9%E6%96%B0%E5%A2%9EAPI"><span class="toc-text">5.5 Java9新增API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E7%BB%83%E4%B9%A0"><span class="toc-text">5.6 练习</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/16/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/" title="代码演示"><img src="https://img1.baidu.com/it/u=3486908499,2121835088&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码演示"/></a><div class="content"><a class="title" href="/2024/05/16/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/" title="代码演示">代码演示</a><time datetime="2024-05-16T13:02:53.090Z" title="发表于 2024-05-16 21:02:53">2024-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/16/hello-world/" title="Hello World"><img src="https://img0.baidu.com/it/u=2434210581,3590463476&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=360" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2024/05/16/hello-world/" title="Hello World">Hello World</a><time datetime="2024-05-16T13:02:41.430Z" title="发表于 2024-05-16 21:02:41">2024-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/08/Java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6/" title="泛型和通配符"><img src="https://img1:baidu:com/it/u=1777496104,822946362&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="泛型和通配符"/></a><div class="content"><a class="title" href="/2023/08/08/Java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6/" title="泛型和通配符">泛型和通配符</a><time datetime="2023-08-08T02:17:47.000Z" title="发表于 2023-08-08 10:17:47">2023-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/01/Java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EThreadLocal/" title="关于ThreadLocal"><img src="https://img1:baidu:com/it/u=1777496104,822946362&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于ThreadLocal"/></a><div class="content"><a class="title" href="/2023/08/01/Java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EThreadLocal/" title="关于ThreadLocal">关于ThreadLocal</a><time datetime="2023-08-01T03:11:23.000Z" title="发表于 2023-08-01 11:11:23">2023-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="单例模式"><img src="https://img0.baidu.com/it/u=1172543276,3142609657&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=640&amp;h=416" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单例模式"/></a><div class="content"><a class="title" href="/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="单例模式">单例模式</a><time datetime="2023-07-30T13:25:30.000Z" title="发表于 2023-07-30 21:25:30">2023-07-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By YZ</div><div class="footer_custom_text">很高兴认识你</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="7193364325" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>